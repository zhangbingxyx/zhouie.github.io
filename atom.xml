<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>北岛向南的小屋</title>
  
  <subtitle>那时我们有梦，关于文学，关于爱情，关于穿越世界的旅行</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhouie.cn/"/>
  <updated>2018-09-11T06:18:11.673Z</updated>
  <id>https://zhouie.cn/</id>
  
  <author>
    <name>zhouie</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【分享】 VPN工具整理</title>
    <link href="https://zhouie.cn/posts/201808091/"/>
    <id>https://zhouie.cn/posts/201808091/</id>
    <published>2018-08-09T21:21:43.000Z</published>
    <updated>2018-09-11T06:18:11.673Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p>近日，谷歌想借助其正在研发的过滤版搜索引擎应用程序，重返中国市场的消息在圈内传得沸沸扬扬，连官媒人民日报海外版在 Twitter 和 Facebook 上发文表示，“欢迎谷歌重返中国大陆，但前提必须遵守中国法律法规”。<br>据悉，此前8月1日，即市场首次传出谷歌将在中国大陆重启搜索业务当天，在美国上市的百度股价跌近 8% ，市值跌破 800 亿美元…</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pcx2lec2u.bkt.clouddn.com/201808091657_648.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>对此，国内搜索引擎兼AI科技巨头 <strong>百度 CEO 李彦宏</strong> 表示百度有实力和信心与谷歌再 PK 一次并再赢一次。诚然，如今的百度已不是八年前的百度，但如今的谷歌在体量和业务上与2010年相比扩张也不是一星半点，从互联网搜索、安卓系统到 AI 技术、云计算等领域，开发并提供大量基于互联网的产品与服务。</p><p>虽然明面上谷歌是否会高调回归中国市场尚未可知，但不可否认的是，这几年来，谷歌想要进入中国市场的念头从未断过。而且啊，咱们大家在 “用谷歌” 与 “用百度” 这一问题上，也是 “分歧” 蛮大的…</p><p>为此，新浪财经发出 “如果谷歌回归，用百度还是用谷歌” 之类的微博投票，一边倒似的投票结果也反映出了很多网民的态度</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pcx2lec2u.bkt.clouddn.com/201808091634_397.jpg" alt="如果谷歌回归，你选择用百度还是用谷歌" title="">                </div>                <div class="image-caption">如果谷歌回归，你选择用百度还是用谷歌</div>            </figure><p>下面给大家整理分享了几个还挺实用的 VPN 工具，网络，因互联而精彩…</p><h3 id="何为-VPN"><a href="#何为-VPN" class="headerlink" title="何为 VPN"></a>何为 VPN</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pcx2lec2u.bkt.clouddn.com/201808091633_55.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><blockquote><p>VPN属于远程访问技术，简单地说就是利用公用网络架设专用网络。例如某公司员工出差到外地，他想访问企业内网的服务器资源，这种访问就属于远程访问。</p></blockquote><p>在传统的企业网络配置中，要进行远程访问，传统的方法是租用DDN（数字数据网）专线或帧中继，这样的通讯方案必然导致高昂的网络通讯和维护费用。对于移动用户（移动办公人员）与远端个人用户而言，一般会通过拨号线路（Internet）进入企业的局域网，但这样必然带来安全上的隐患。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pcx2lec2u.bkt.clouddn.com/201808091746_317.jpg" alt="VPN" title="">                </div>                <div class="image-caption">VPN</div>            </figure><p>让外地员工访问到内网资源，利用VPN的解决方法就是在内网中架设一台VPN服务器。外地员工在当地连上互联网后，通过互联网连接VPN服务器，然后通过VPN服务器进入企业内网。为了保证数据安全，VPN服务器和客户机之间的通讯数据都进行了加密处理。</p><p>有了数据加密，就可以认为数据是在一条专用的数据链路上进行安全传输，就如同专门架设了一个专用网络一样，但实际上VPN使用的是互联网上的公用链路，因此VPN称为虚拟专用网络，其实质上就是利用加密技术在公网上封装出一个数据通讯隧道。有了VPN技术，用户无论是在外地出差还是在家中办公，只要能上互联网就能利用VPN访问内网资源，这就是VPN在企业中应用得如此广泛的原因。</p><h3 id="VPN-在中国"><a href="#VPN-在中国" class="headerlink" title="VPN 在中国"></a>VPN 在中国</h3><p>今年1月份起，工信部发布了 <strong>《工业和信息化部关于清理规范互联网网络接入服务市场的通知》</strong>，在全国范围内对互联网网络接入服务市场开展清理规范工作。</p><blockquote><p>根据 <strong>《中华人民共和国电信条例》</strong> 和 <strong>《中国人民共和国刑法》</strong> 等相关法律规定，未取得 <strong>《增值电信业务经营许可证》</strong> 的情况下，在网络上销售 VPN 代理服务，属于非法经营范畴。</p></blockquote><p>据市场研究机构 <strong>Global WebIndex</strong> 的调查研究估测，中国的 VPN 用户可能多达 <code>9000</code> 万。</p><p>我个人觉得，不论从信息安全的角度，还是政治文化上来看，如此庞大的用户规模，必然需要一定的行业监管与市场干预，毕竟，我们所发送与接收的数据会通过 VPN 服务提供商的机器，用户的账号密码、信用卡信息等存在着被 VPN 服务提供商 ISP 看到的风险。更何况，这种监管绝非中国仅有。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pcx2lec2u.bkt.clouddn.com/201808091735_103.jpg" alt="VPN 服务风险" title="">                </div>                <div class="image-caption">VPN 服务风险</div>            </figure><p>然而，形势政策上的方向性问题，可能大家很难找到或是稳定使用某一款 VPN 工具，这里的话，也只是推荐几款我用过的还好的工具（至少目前是这样）…</p><h3 id="VPN-Tool"><a href="#VPN-Tool" class="headerlink" title="VPN Tool"></a>VPN Tool</h3><h4 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pcx2lec2u.bkt.clouddn.com/201808091635_989.jpg" alt="Android Platform" title="">                </div>                <div class="image-caption">Android Platform</div>            </figure><blockquote><p>百度云链接：<br><a href="https://pan.baidu.com/s/1RytklkQWKMrn354ZKjbhmg" target="_blank" rel="noopener">https://pan.baidu.com/s/1RytklkQWKMrn354ZKjbhmg</a><br>提取密码：<br>1a2i</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pcx2lec2u.bkt.clouddn.com/201808091728_548.png" alt="扫一扫二维码也可获取" title="">                </div>                <div class="image-caption">扫一扫二维码也可获取</div>            </figure><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><ul><li>Psiphon<ul><li><a href="mailto:&#x67;&#101;&#x74;&#x40;&#112;&#115;&#x69;&#112;&#104;&#x6f;&#110;&#51;&#x2e;&#99;&#111;&#109;" target="_blank" rel="noopener">&#x67;&#101;&#x74;&#x40;&#112;&#115;&#x69;&#112;&#104;&#x6f;&#110;&#51;&#x2e;&#99;&#111;&#109;</a></li></ul></li><li>Windscribe<ul><li><a href="https://chn.windscribe.com/" target="_blank" rel="noopener">https://chn.windscribe.com/</a></li></ul></li><li>Shadowsocks<ul><li><a href="https://ss.freess.org/" target="_blank" rel="noopener">https://ss.freess.org/</a></li></ul></li><li>Betternet<ul><li><a href="https://www.betternet.co/zh/" target="_blank" rel="noopener">https://www.betternet.co/zh/</a></li></ul></li></ul><blockquote><p>百度云链接：<br><a href="https://pan.baidu.com/s/1cyI1dHnUtEztEAzZ6vU5FQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1cyI1dHnUtEztEAzZ6vU5FQ</a><br>提取密码：<br>7tam</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pcx2lec2u.bkt.clouddn.com/201808091729_892.png" alt="扫一扫二维码也可获取" title="">                </div>                <div class="image-caption">扫一扫二维码也可获取</div>            </figure><blockquote><p>ps：以上链接若是失效的话，可以邮我 <a href="mailto:nanzhouie@qq.com" target="_blank" rel="noopener">nanzhouie@qq.com</a> 获取最新链接 或 在评论区留下你的邮箱 …</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="分享" scheme="https://zhouie.cn/categories/%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Tool-share" scheme="https://zhouie.cn/tags/Tool-share/"/>
    
      <category term="VPN" scheme="https://zhouie.cn/tags/VPN/"/>
    
  </entry>
  
  <entry>
    <title>【分享】 qiniu_upload windows工具</title>
    <link href="https://zhouie.cn/posts/201808033/"/>
    <id>https://zhouie.cn/posts/201808033/</id>
    <published>2018-08-03T23:11:31.000Z</published>
    <updated>2018-09-11T06:18:11.673Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>介绍一款 <strong>提升markdown贴图体验的实用小工具</strong>，支持 <code>windows</code> 及 <code>mac</code>，基于 <code>AutoHotkey</code> 和 <code>qshell</code> 实现，支持本地文件、截图及网络图片一键上传至七牛云，并获取图片的 markdown引用 至剪贴板（<code>Ctrl+Alt+V</code>），并自动粘贴到当前编辑器。</p><ul><li>支持各种格式图片上传</li><li>支持截图及网络图片直接复制上传</li><li>支持各种格式单个文件上传</li><li><code>AutoHotkey</code>开放源码，完全免费</li><li>安装使用非常简单</li></ul><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="http://jverson.com/2017/05/28/qiniu-image-v2/" target="_blank" rel="noopener">windows版本markdown一键贴图工具（2.x及以上版本）</a></li><li><a href="https://jverson.com/2016/08/30/autohotkey-markdown-uploadImage/" target="_blank" rel="noopener">AutoHotkey&amp;qshell实现图片一键上传七牛并返回markdown引用（适用1.x版本）</a></li><li><a href="http://ahkcn.sourceforge.net/docs" target="_blank" rel="noopener">AutoHotkey中文帮助</a></li><li><a href="https://autohotkey.com/docs/Hotkeys.htm#Symbols" target="_blank" rel="noopener">You can use the following modifier symbols to define hotkeys</a></li><li><a href="https://github.com/octan3/img-clipboard-dump" target="_blank" rel="noopener">Powershell-Scripts for dumping images from clipboard</a></li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>1、 下载 qimage-win<br>首先从 <a href="https://github.com/jiwenxing/qimage-win/releases" target="_blank" rel="noopener">github</a> 下载最新的release版本(推荐使用2.*正式版)，并解压到任意目录，在<code>qimage-win</code>文件夹中看到的目录结构应该如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/qiniu_upload/1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>其中<code>dump-clipboard-png.ps1</code>是保存截图的<code>powershell</code>脚本，<code>qiniu-image-upload.ahk</code>即完成文件上传的<code>AutoHotkey</code>脚本。</p><p>2、 安装 AutoHotkey</p><p><a href="https://autohotkey.com/" target="_blank" rel="noopener">AutoHotkey</a>官网下载安装最新版本，这是一款免费的、Windows平台下开放源代码的 <strong>热键脚本语言</strong>，利用其通过 <strong>自定义热键</strong> 触发一系列系统调用从而完成自动化操作。</p><p>这款软件的安装很简单，正常安装Next就行。具体软件更多学习内容可参照——<a href="http://ahkcn.sourceforge.net/docs" target="_blank" rel="noopener">AutoHotkey中文帮助</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/qiniu_upload/2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>3、 注册七牛云账号并创建一个bucket</p><p>还没有七牛云帐号的朋友，😉欢迎通过我的邀请注册链接：<a href="https://portal.qiniu.com/signup?code=3lowm9s25ur82" target="_blank" rel="noopener">https://portal.qiniu.com/signup?code=3lowm9s25ur82</a>完成七牛云的注册，注册后会发邮件到你邮箱，通过邮件激活并登录即可。</p><blockquote><p>ps：注册的时候，你要填一项个人网站域名，如果没网站的，就请随便填一个真实存在的网站吧，<code>www.baidu.com</code>也是可以的哦~</p></blockquote><p>这个部分的操作请参照 <a href="https://zhouie.cn/posts/201808032/#Md2All%E7%9A%84%E4%BA%91%E5%9B%BE%E5%BA%8A">Md2All的云图床</a></p><p>注意，在新建七牛云存储空间(bucket)时，选择存储区域上要多加留意，<a href="https://developer.qiniu.com/kodo/manual/1671/region-endpoint" target="_blank" rel="noopener">参照文档</a></p><table><thead><tr><th style="text-align:center">存储区域</th><th style="text-align:center">地域简称</th><th style="text-align:center">上传域名</th></tr></thead><tbody><tr><td style="text-align:center">华东</td><td style="text-align:center"><code>z0</code></td><td style="text-align:center">服务器端上传：<code>http(s)://up.qiniup.com</code> 客户端上传： <code>http(s)://upload.qiniup.com</code></td></tr><tr><td style="text-align:center">华北</td><td style="text-align:center"><code>z1</code></td><td style="text-align:center">服务器端上传：<code>http(s)://up-z1.qiniup.com</code> 客户端上传：<code>http(s)://upload-z1.qiniup.com</code></td></tr><tr><td style="text-align:center">华南</td><td style="text-align:center"><code>z2</code></td><td style="text-align:center">服务器端上传：<code>http(s)://up-z2.qiniup.com</code> 客户端上传：<code>http(s)://upload-z2.qiniup.com</code></td></tr><tr><td style="text-align:center">北美</td><td style="text-align:center"><code>na0</code></td><td style="text-align:center">服务器端上传：<code>http(s)://up-na0.qiniup.com</code> 客户端上传：<code>http(s)://upload-na0.qiniup.com</code></td></tr><tr><td style="text-align:center">东南亚</td><td style="text-align:center"><code>as0</code></td><td style="text-align:center">服务器端上传：<code>http(s)://up-as0.qiniup.com</code> 客户端上传：<code>http(s)://upload-as0.qiniup.com</code></td></tr></tbody></table><p>4、 配置文件</p><p><code>qimage-win</code> 文件夹中打开<code>settings.ini</code>文件，可以看到:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/qiniu_upload/3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这里的配置项都需要根据自己的七牛云账号以及所创建的 bucket 进行修改，后面的两个配置项为可选配置，默认情况下可以暂时先不管。</p><p><code>ACCESS_KEY</code> &amp; <code>SECRET_KEY</code></p><p>这是<code>qshell</code>操作个人账号的账号凭证，登陆七牛账号后在<code>个人面板-&gt;密钥管理</code>中查看，或者直接访问<code>https://portal.qiniu.com/user/key</code>查看。</p><p><code>BUCKET_NAME</code> &amp; <code>BUCKET_DOMAIN</code></p><p>在<code>对象存储-&gt;存储空间列表</code>中选择或新建一个存储空间即 bucket，点击该 bucket 在右边看到一个测试域名，该域名<code>bucketDomain</code>便是图片上传后的访问域名，特别注意域名不要少了前面的<code>http://</code>头部。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/qiniu_upload/4.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>完成文件上传的<code>AutoHotkey</code>脚本中默认的快捷键是<code>^!V</code>，即<code>Ctrl+Alt+V</code>(其中，<code>^</code>代表<code>Ctrl</code>，<code>!</code>为<code>Alt</code>)，如果您希望修改为其它自己更习惯的快捷键，直接对<code>qiniu-image-upload.ahk</code>脚本修改即可生效。</p><p>关于<code>hotkey</code>的符号与按键对应关系请参考 <a href="https://autohotkey.com/docs/Hotkeys.htm" target="_blank" rel="noopener">You can use the following modifier symbols to define hotkeys</a></p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>配置完成后，以管理员身份运行<code>qImage.exe</code>，这时便可以参照下面的效果显示，使用<code>Ctrl+Alt+V</code>尝试一键上传图片至七牛云指定bucket了。</p><h3 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h3><p>本地图片文件上传</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/qiniu_upload/5.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>截图上传</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/qiniu_upload/6.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>其它文件上传</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/qiniu_upload/7.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><p>如果以上操作完成后，没有按照预期达到图片上传的效果，可以先自己调试找一下原因，一般报错信息会打印在cmd命令行中，但是cmd窗口一闪而过可能看不清楚，这时候需要将<code>settings.ini</code>配置文件中的可选参数<code>DEBUG_MODE = false</code>改为<code>DEBUG_MODE = true</code>以打开调试模式，再次尝试，这时候cmd窗口不会自动关闭，便可以看到具体的报错信息从而对症下药解决问题。</p><p>使用过程中的任何问题可以在github中提交<a href="https://github.com/jiwenxing/qiniu-image-tool-win/issues" target="_blank" rel="noopener">issues</a></p><h4 id="常见问题一-七牛云UP-HOST有误"><a href="#常见问题一-七牛云UP-HOST有误" class="headerlink" title="常见问题一: 七牛云UP_HOST有误"></a>常见问题一: 七牛云UP_HOST有误</h4><p>具体的错误信息如下所示：</p><blockquote><p>Uploading G:\Users\Cooper\Desktop\9999.png =&gt; markdown : 201705082057_244.png …<br>Progress: 100%<br>Put file error, 400 incorrect region, please use up-z2.qiniu.com, Reqid: 0wUAAGp6j6faorwU<br>Last time: 0.43 s, Average Speed: 415.6 KB/s</p></blockquote><p>在七牛云的官方文档中<code>UP_HOST</code>为非必填项，配置文件中使用的是默认值<code>http://up.qiniu.com</code>，而每个区域所对应的的七牛云上传域名都不同，当与你所在空间区域不匹配时便会报以上的错误信息<br>不过很友善的是，错误信息中已经给出了建议的<code>UP_HOST</code>，例如上面的错误信息就给出明确的提示 <code>please use up-z2.qiniu.com</code>，这时将可选配置项<code>UP_HOST = http://up.qiniu.com</code>修改为<code>UP_HOST = http://up-z2.qiniu.com</code>，保存即可。</p><p>参照上面的<code>存储区域-上传域名</code>表格，不难看出出现这种报错的原因其实是因为，默认情况下，bucket的默认存储区域是 华东 ，对应<code>http(s)://up.qiniup.com</code>，但我之前在新建bucket时将 存储区域 选择在了 华南 地区，显然对应配置文件中自然需要修改成<code>http://up-z2.qiniu.com</code>!</p><h4 id="常见问题二-powershell执行权限问题"><a href="#常见问题二-powershell执行权限问题" class="headerlink" title="常见问题二: powershell执行权限问题"></a>常见问题二: powershell执行权限问题</h4><p>具体的错误信息如下所示：</p><blockquote><p>set-executionpolicy : 对注册表项“HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\PowerShell\1\ShellIds\Microsoft.PowerShell”的访问被拒绝。 要更改默认(LocalMachine)作用域的执行策略，请使用“以管理员身份运行”选项启动 Windows PowerShell。要更改当前用户的执行策略，请运行 “Set-ExecutionPolicy -Scope Current User”。</p></blockquote><p>这是<code>powershell</code>执行权限问题，重新以管理员权限运行<code>qImage.exe</code>即可。</p><h3 id="推荐阅读-imp"><a href="#推荐阅读-imp" class="headerlink" title="推荐阅读 !imp"></a>推荐阅读 !imp</h3><ul><li><p>1小时编写一个支持七牛上传的 markdown 客户端 —— <a href="https://zhaopeng.me/1174.html" target="_blank" rel="noopener"> 技术实现篇 </a>，<a href="https://zhaopeng.me/1207.html" target="_blank" rel="noopener"> 代码优化篇 </a> ， <a href="https://zhaopeng.me/1218.html" target="_blank" rel="noopener"> 打包发布篇 </a>，<a href="https://github.com/zhaopengme/ndpediter" target="_blank" rel="noopener"> res</a>，<a href="https://gitee.com/imzhpe/ndpediter" target="_blank" rel="noopener"> 备份地址</a></p></li><li><p><a href="https://jverson.com/2017/05/28/qiniu-image-v2/" target="_blank" rel="noopener">qiniu-image-tool | Markdown 一键贴图工具 v.2.x </a>，<a href="https://jverson.com/2016/08/30/autohotkey-markdown-uploadImage/" target="_blank" rel="noopener"> v.1.x </a>，<a href="https://github.com/jiwenxing/qimage-win" target="_blank" rel="noopener"> res </a>，<a href="https://github.com/jiwenxing/qimage-win/issues" target="_blank" rel="noopener"> issues </a>，<a href="https://github.com/jiwenxing/qimage-win/releases" target="_blank" rel="noopener"> download</a></p></li><li><p><a href="https://jverson.com/2017/04/28/alfred-qiniu-upload/" target="_blank" rel="noopener">qimage-mac | 使用alfred在markdown中愉快的贴图 </a>，<a href="https://github.com/jiwenxing/qimage-mac" target="_blank" rel="noopener"> res </a>，<a href="https://github.com/jiwenxing/qimage-mac/releases" target="_blank" rel="noopener"> download </a></p></li><li><p><a href="https://www.cnblogs.com/haoliuhust/p/6084102.html" target="_blank" rel="noopener">QiniuUpload | 一个方便用七牛做图床然后插入markdown的小工具 </a>，<a href="https://github.com/HaoLiuHust/QiniuUpload" target="_blank" rel="noopener"> res </a>，<a href="https://developer.qiniu.com/kodo/sdk/1237/csharp" target="_blank" rel="noopener"> doc </a></p></li><li><p><a href="https://blog.csdn.net/qq_31915279/article/details/61824114" target="_blank" rel="noopener">在Atom下配置并使用MarkDown全教程 </a>，<a href="https://blog.csdn.net/fjinhao/article/details/78577212" target="_blank" rel="noopener"> 更多参考1 </a>，<a href="https://www.jianshu.com/p/af4d34d39797" target="_blank" rel="noopener"> 更多参考2 </a></p></li><li><p><a href="https://www.jianshu.com/p/c859ead1b493" target="_blank" rel="noopener">一个码字工作者的正确书写发文姿势 —— MWeb + Markdown Here + 七牛 实现一键发布</a></p></li><li><p><a href="http://www.chairis.cn/blog/article/15" target="_blank" rel="noopener">Laravel项目中使用markdown编辑器及图片粘贴上传七牛云 </a>，<a href="https://www.cnblogs.com/ChainZhang/p/7058904.html" target="_blank" rel="noopener"> 备份地址 </a></p></li><li><p><a href="https://www.jianshu.com/p/44d818f781a7" target="_blank" rel="noopener">qiniu upload files谷歌浏览器插件</a></p></li><li><p><a href="https://blog.csdn.net/sylan15/article/details/78453205" target="_blank" rel="noopener">Python实现七牛云图片和文件上传脚本实现</a>，<a href="https://github.com/sylan215/upload-to-qiniu" target="_blank" rel="noopener">res</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="分享" scheme="https://zhouie.cn/categories/%E5%88%86%E4%BA%AB/"/>
    
      <category term="博客" scheme="https://zhouie.cn/categories/%E5%88%86%E4%BA%AB/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Tool-share" scheme="https://zhouie.cn/tags/Tool-share/"/>
    
      <category term="图床" scheme="https://zhouie.cn/tags/%E5%9B%BE%E5%BA%8A/"/>
    
      <category term="七牛云" scheme="https://zhouie.cn/tags/%E4%B8%83%E7%89%9B%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>【分享】 Md2All Markdown排版利器</title>
    <link href="https://zhouie.cn/posts/201808032/"/>
    <id>https://zhouie.cn/posts/201808032/</id>
    <published>2018-08-03T17:31:22.000Z</published>
    <updated>2018-09-11T06:18:11.673Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="关于Md2All"><a href="#关于Md2All" class="headerlink" title="关于Md2All"></a>关于Md2All</h3><blockquote><p>有这样一位程序猿，也同样被公众号的Markdown排版折磨得苦不堪言，花了差不多一个星期的时间，研究各种现有的工具，但并没有找到较为满意的解决方案。<br>因为这样程序猿比较喜欢较真，于是就萌生了自己写一个公众号Markdown排版工具的想法，这就有了现在的Md2All。虽然开发的过程也因遇到的各种奇芭的坑而艰苦异常，但结果还是令人满意的，起码上面提到的问题都解决了。</p></blockquote><p><a href="http://md.aclickall.com" target="_blank" rel="noopener">Markdown排版利器：Md2All</a></p><ul><li>支持 <strong>一键排版</strong>和自定义css；</li><li>支持边编辑边预览；</li><li>支持左右滚动联动；</li><li>对IT人士特别友好，支持80多种代码主题；</li><li>支持通用的Markdown语法和部分扩展语法(如：表格，任务列表，latex数学公式，注脚等…)，并对html，css样式有很好的支持；</li><li>能让Markdown内容，无需作任何调整就能一键复制到微信公众号、博客园、掘金、知乎、csdn、51cto、wordpress、hexo等平台。</li></ul><p><strong>一键排版</strong> 中提供了几种常用的排版样式模版，也提供了足够多的注释，让初学者也能很容易根据注释中的提示个性化自己的样式。<br>如果你觉得现有的样式模板不适合你，那就大胆尝试去改吧，就算改错了也就”恢复预设值“就OK了，所以不用担心啊。ps：记得保存了才会生效啊。</p><p>Md2All教程请参考：<a href="https://www.cnblogs.com/garyyan/p/8329343.html" target="_blank" rel="noopener">https://www.cnblogs.com/garyyan/p/8329343.html</a></p><h3 id="整体体验"><a href="#整体体验" class="headerlink" title="整体体验"></a>整体体验</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/Md2All/1.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="Md2All的云图床"><a href="#Md2All的云图床" class="headerlink" title="Md2All的云图床"></a>Md2All的云图床</h3><h4 id="准备步骤"><a href="#准备步骤" class="headerlink" title="准备步骤"></a>准备步骤</h4><p>1、注册七牛云帐号</p><p>为什么用七牛云呢？<br>七牛云技术已相当成熟，在图片存储管理上已经有些年头了，从知乎上来看，在国内目前的图床服务上属于靠前的服务商了，而且，目前很多国外的图床服务还是被墙没法使用，具体可供大家参考选择的<a href="https://zhouie.cn/posts/201804241/">图床工具分享</a></p><p>还没有七牛云帐号的朋友，😉欢迎通过我的邀请注册链接：<a href="https://portal.qiniu.com/signup?code=3lowm9s25ur82" target="_blank" rel="noopener">https://portal.qiniu.com/signup?code=3lowm9s25ur82</a>完成七牛云的注册，注册后会发邮件到你邮箱，通过邮件激活并登录即可。</p><blockquote><p>ps：注册的时候，你要填一项个人网站域名，如果没网站的，就请随便填一个真实存在的网站吧，<code>www.baidu.com</code>也是可以的哦~</p></blockquote><p>2、新建七牛云存储空间(bucket)</p><blockquote><p>现在七牛云的新建存储空间要个人身份认证，这里建议用支付宝认证，十分钟左右就可以收到认证通过的信息了。ps：认证通过后会有10G/月的免费空间，这肯定是够用了吧…</p></blockquote><p>按照 <code>登录七牛云-&gt;管理控制台-&gt;对象存储-&gt;新建存储空间</code> 操作顺序新建一个存储空间即bucket</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/Md2All/5.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>点击该 bucket，在右边看到一个测试域名，该域名是图片上传后的访问域名即 <code>bucketDomain</code>。这里要特别注意域名不要少了前面的<code>http://</code>头部。</p><p>3、设置云图床</p><p>3.1、<code>Acess Key</code>和<code>Secret Key</code></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/Md2All/6.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>3.2、<code>BucketName</code>和<code>BucketDomain</code></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/Md2All/7.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>3.3、在Md2All中设置七牛图床</p><p>在 Md2All 中点击左上角的<code>图片</code>图标，然后参考下面的1,2,3,4和上图的1,2,3,4对应，并记得保存设置</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/Md2All/8.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>4、测试一下</p><p>按照下面的显示效果动图操作一番，看看<code>内容管理</code>界面是否成功上传。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/Md2All/9.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h4><ul><li>直接把图片拖到编辑框</li></ul><p>注意：Markdown内容是插入到光标处，为了避免不知内容插入到那儿，拖图片前，请先点一点光标</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/Md2All/2.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>截图，直接复制粘贴</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/Md2All/3.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>点击上传图片选择</li></ul><p>这个功能就不录屏了，相信聪明的你一定知道怎样做的</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/Md2All/4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="显示Latex公式"><a href="#显示Latex公式" class="headerlink" title="显示Latex公式"></a>显示Latex公式</h3><blockquote><p>目前国内很多的 Markdown编辑环境中还不支持功能强大的 Latex公式，以前最通常的做法是这样的：找一个支持 Latex公式 的网站（如CSDN)，先把 Latex公式 显示出来，然后再一个个去截屏保存。如果一两条公式也就算了，可如果公式很多，那工作量也是让人头痛。</p><p>原本一篇好好的 Markdown文档，本来打算复制过来直接发布的，却因为不支持 Latex公式 的原因，又得重新整理一次，这真的是很浪费时间。</p></blockquote><p>为了解决 Latex公式的显示问题，Md2All新增了对 Latex公式 到各平台显示的完美支持。</p><p>直接支持在 Markdown中包含 Latex公式，一键 <strong>复制</strong>就能转换到各平台都能正常显示的 Latex公式内容。</p><p>其实它是这样做的：一键 <strong>复制</strong>直接把 Latex公式 转换成 图片，再次复制 就能把包含转换好的 Latex公式的内容直接复制出来，完美解决了跨平台不支持Latex公式的显示问题，免去了截图保存再上传的这种麻烦。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/Md2All/10.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="CSS样式"><a href="#CSS样式" class="headerlink" title="CSS样式"></a>CSS样式</h3><p>注意，Md2All 中用的都是标准的css样式，而且在样式文件中有很多的注释。</p><p>举个例子来说，如果我想改<code>###</code>这个<code>h3</code>标题的效果，那就只要改样式文件中以<code>h3</code>为开头的样式的内容即可。如：</p><p>从 <strong>默认样式</strong>中把整个样式内容复制到 <strong>最爱样式</strong>中然后再进行修改。因为所有的样式模板都是从 <strong>默认样式</strong>中修改过来的，另外，其它的样式模板目前还有可能在不断改进中，所以在 <strong>最爱样式</strong>中定义自己的样式是最好的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.3em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">2.3em</span>;</span><br><span class="line">  <span class="attribute">color</span>:<span class="number">#159957</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以直接在后面添加，后面的会覆盖前面的，如:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.3em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">2.3em</span>;</span><br><span class="line">  <span class="attribute">color</span>:<span class="number">#159957</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="全局样式自定义"><a href="#全局样式自定义" class="headerlink" title="全局样式自定义"></a>全局样式自定义</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/Md2All/11.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>可以看到，修改<code>output_wrapper{}</code>下的样式后，就直接影响了整个文档的显示效果，而每个样式的修改，从英文单词和GIF效果中已能很清楚地看到。</p><p>可能有人会有疑问，不是说全局的吗，为什么最上面的引用块的样式没有变？这是因为，更具体定义的元素，无论放在前面还是后面，也不会被范围更大的定义覆盖，如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">blockquote</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">color</span>:<span class="number">#ffffff</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">output_wrapper</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">color</span>:<span class="number">#00000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>output_wrapper</code>的<code>color</code>不会覆盖<code>blockquote</code>（引用块）的。原因是<code>output_wrapper</code>是针对所有的，而<code>blockquote</code>只是针对引用块。<br>好吧，既然说了引用块<code>blockquote</code>，那就接着<code>blockquote{}</code>来说吧！</p><h4 id="引用块样式自定义"><a href="#引用块样式自定义" class="headerlink" title="引用块样式自定义"></a>引用块样式自定义</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/Md2All/12.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>有了上面的介绍后，这儿看起来应该没压力了吧，就是改<code>blockquote{}</code>,说白了就是英语单词的事了。</p><h4 id="段落样式自定义"><a href="#段落样式自定义" class="headerlink" title="段落样式自定义"></a>段落样式自定义</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/Md2All/13.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="粗体、斜体、删除线样式自定义"><a href="#粗体、斜体、删除线样式自定义" class="headerlink" title="粗体、斜体、删除线样式自定义"></a>粗体、斜体、删除线样式自定义</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/Md2All/14.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>可以看到，对于斜体<code>em{}</code>，我把<code>font-style:itaic</code>拿掉就不斜，对于删除线<code>del{}</code>,只要添加<code>text-decoration:none;</code>就会把删除线可掉，对于强调<code>strong{}</code>可以添加<code>font-weight:normal;</code>把粗体去掉。这样你就可以把它作为其它的作用了啊。</p><h4 id="分隔线样式自定义"><a href="#分隔线样式自定义" class="headerlink" title="分隔线样式自定义"></a>分隔线样式自定义</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/Md2All/15.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="行内代码样式自定义"><a href="#行内代码样式自定义" class="headerlink" title="行内代码样式自定义"></a>行内代码样式自定义</h4><p>行内代码，也就是改<code>code{}</code></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/Md2All/16.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>行内代码</strong>和 <strong>代码块</strong>一般情况都是用于代码显示，不过行内代码是可以和其它的内容放在同一行的，所以一般用行内代码来显示一些自己要突出的内容；而代码块，就是独立为显示一段代码的区域。</p><h4 id="代码块样式自定义"><a href="#代码块样式自定义" class="headerlink" title="代码块样式自定义"></a>代码块样式自定义</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/Md2All/17.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>看到这儿，就算工具栏没了 <strong>代码紧凑</strong>的功能，也应该知道怎样实现了，另外，代码高亮也可以随心所欲地去定义了！</p><h4 id="标题样式自定义"><a href="#标题样式自定义" class="headerlink" title="标题样式自定义"></a>标题样式自定义</h4><p>写markdown时，我比较喜欢用<code>h3</code>，即<code>###</code>，因为一般情况下，<code>h3</code>默认的<code>font-size</code>对我来说，大小刚好合适。</p><p>但这并没有什么参考性，自己把握好喜好就行。</p><p>标题酷酷的改进</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/Md2All/18.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>标题首字突出的改进</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/Md2All/19.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>标题上下边框的改进</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/Md2All/20.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="分享" scheme="https://zhouie.cn/categories/%E5%88%86%E4%BA%AB/"/>
    
      <category term="博客" scheme="https://zhouie.cn/categories/%E5%88%86%E4%BA%AB/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Tool-share" scheme="https://zhouie.cn/tags/Tool-share/"/>
    
      <category term="图床" scheme="https://zhouie.cn/tags/%E5%9B%BE%E5%BA%8A/"/>
    
      <category term="Markdown" scheme="https://zhouie.cn/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>【分享】 Markdown-Here md-2-html渲染</title>
    <link href="https://zhouie.cn/posts/201808031/"/>
    <id>https://zhouie.cn/posts/201808031/</id>
    <published>2018-08-03T12:36:45.000Z</published>
    <updated>2018-09-11T06:18:11.673Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p>写在前面</p></blockquote><p>最近在编排微信公众号的时候，竟然发现这里没有支持 <strong>代码块</strong> 这种语块，更别谈 <strong>高亮处理</strong> 了，而且啊，一直也想不明白，微信公众号的编辑器怎么还没有支持 Markdown 这个目前最高效的写作语言模块。</p><p>试想一下，如果你正在通过 Markdown 来写文章，需要将此文章发布到公众号，那么，你可能就得这样：</p><ul><li>第一步，删除 Markdown 特定的语法标记</li><li>第二步，将文字内容复制到公众号编辑框中再进行排版</li></ul><p>这种方法，仅仅偶尔一次两次也没有问题，要是使用频繁的话，就太浪费时间和精力了。</p><p>当然了，也有一些手段可以将 Markdown 转换成 HTML ，再来将其中的内容复制到公众号编辑框中进行排版调整。<br><a href="https://markdowntohtml.com/" target="_blank" rel="noopener">Convert Markdown to HTML</a></p><p>综上，这里介绍这样一款浏览器插件 —— <a href="https://markdown-here.com/" target="_blank" rel="noopener">Markdown Here</a> ，通过其提供的一键渲染功能，可将 Markdown 格式直接达到（渲染）我们需要的样式。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>下载地址：<a href="http://sina.lt/fCA8" target="_blank" rel="noopener">http://sina.lt/fCA8</a>(也提供有 Firefox、Safari 插件)，需要翻墙。<br>备份地址：<a href="https://github.com/zhouie/Google-Chrome-Extensions/blob/master/Markdown%20Here%20for%20Chrome.crx" target="_blank" rel="noopener">Markdown Here for Chrome.crx</a></p><h3 id="渲染-CSS-样式"><a href="#渲染-CSS-样式" class="headerlink" title="渲染 CSS 样式"></a>渲染 CSS 样式</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/Markdown-Here/1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>打开 Markdown Here 选项，将 <strong>自定义的基本渲染CSS样式</strong>直接覆盖到 Primary Styling CSS（<strong>基本渲染CSS</strong>）框中。</p><p>其中，至于自定义的基本渲染CSS样式，有着一定CSS知识的你完全可以根据自己的喜好来设置，当然，我这里也提供了一些<a href="https://gist.github.com/zhouie" target="_blank" rel="noopener">Gist Snippets</a> 以供学习参阅。</p><p>至于右边的 <strong>语法高亮CSS</strong>，提供有很多可选主题，就看你喜欢哪一款了。下面的 <strong>预览框</strong>中会自动保存修改并同步显示渲染效果预览。</p><h3 id="多平台使用"><a href="#多平台使用" class="headerlink" title="多平台使用"></a>多平台使用</h3><p>打开微信公众号后台编辑器，直接复制带有 Markdown 语法的文章或者笔记到编辑器中（不再需要删除 Markdown 特定的语法标记），点击浏览器右上角 Markdown Here图标(也可以试试快捷键<code>CTRL+ALT+M</code>)，Markdown Here 会自动将你的文章进行了全新的渲染排版（转成HTML样式），文章标题层级、加粗、引用、表格、图片、代码块、甚至最不好弄的数学公式，一目了然。</p><p>得说一下，这里只是拿微信公众号为例来讲，其实 Markdown Here 这款插件能让 Markdown 内容，无需作任何调整就能在 微信公众号、CSDN、博客园、掘金、知乎、51CTO、WordPress 等多种平台正确显示渲染后的效果。</p><p>同时啊，Markdown Here 还可以用来渲染用 Markdown 写的邮件内容，似乎这才是它的推广方向…</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/Markdown-Here/2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h3><ul><li><a href="http://aclickall.com/" target="_blank" rel="noopener">Md2All | Markdown排版利器</a></li><li><a href="http://blog.didispace.com/tools/online-markdown/" target="_blank" rel="noopener">程序猿DD | Markdown转换工具</a></li><li><a href="https://www.zhihu.com/question/23640203" target="_blank" rel="noopener">如何排版微信公众平台的文章？ - 知乎</a></li><li><a href="http://md.barretlee.com/" target="_blank" rel="noopener">在线Markdown转微信公众号内容开源项目</a></li><li><a href="https://zhouie.cn/posts/201804111/">走进Markdown园子</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="分享" scheme="https://zhouie.cn/categories/%E5%88%86%E4%BA%AB/"/>
    
      <category term="博客" scheme="https://zhouie.cn/categories/%E5%88%86%E4%BA%AB/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Tool-share" scheme="https://zhouie.cn/tags/Tool-share/"/>
    
      <category term="Markdown" scheme="https://zhouie.cn/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>【分享】 Cmder - 命令行增强工具</title>
    <link href="https://zhouie.cn/posts/201807311/"/>
    <id>https://zhouie.cn/posts/201807311/</id>
    <published>2018-07-31T17:23:51.000Z</published>
    <updated>2018-09-11T06:18:11.673Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="cmder"><a href="#cmder" class="headerlink" title="cmder"></a>cmder</h3><p><a href="http://cmder.net/" target="_blank" rel="noopener">cmder</a>是一款Windows环境下非常简洁美观易用的cmd替代者，它是一个跨平台的命令行增强工具，可以集成windows batch, power shell, git, linux bash等多种命令行于一体，支持了大部分的Linux命令，比如 grep, curl(没有 wget)，vim，grep，tar，unzip，ssh，ls，bash，perl等。还可以通过自定义，让它更方便。最重要的是颜值也比Windows自带的cmd好得多，支持文字颜色区分。</p><p>Windows自带的cmd有哪些缺点</p><ol><li>复制文本，不能直接用鼠标拷贝，还需要多一道菜单操作；而且，还只能块状拷贝，而不是按行字符，极其不便</li><li>不支持多Tab页，多窗口管理不便</li></ol><hr><h3 id="安装cmder"><a href="#安装cmder" class="headerlink" title="安装cmder"></a>安装cmder</h3><p>在<a href="http://cmder.net/" target="_blank" rel="noopener">cmder官网</a>下载Full版本（内建Git for Windows），直接解压便可以使用啦</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/cmder/1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><hr><h3 id="让cmder便于使用"><a href="#让cmder便于使用" class="headerlink" title="让cmder便于使用"></a>让cmder便于使用</h3><h4 id="将cmder添加到右键菜单中"><a href="#将cmder添加到右键菜单中" class="headerlink" title="将cmder添加到右键菜单中"></a>将cmder添加到右键菜单中</h4><ol><li>在<code>PATH</code>中增加<code>Cmder.exe</code>所在目录（如D:\Program Files\cmder）</li><li>然后进入Cmder的根目录，在命令行中执行<code>Cmder.exe /REGISTER USER</code>或<code>Cmder.exe /REGISTER ALL</code>注册表命令，就可以在右键中出现Cmder Here了</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/cmder/2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>另外呢，在网上我又看到这样一段gist描述去添加右键</p><blockquote><p>在Cmder根目录新建一个init.bat，输入以下代码：</p><blockquote><p>@echo offSET CMDER_ROOT=%~dp0reg add “HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\Background\shell\Cmder” /ve /d “Cmder Here” /freg add “HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\Background\shell\Cmder” /v “Icon” /d “\”%CMDER_ROOT%cmder.exe\”” /freg add “HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\Background\shell\Cmder” /v “Extended” /freg add “HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\Background\shell\Cmder\command” /ve /d “\”%CMDER_ROOT%cmder.exe\” \”%%V\”” /fpause</p></blockquote><p>以管理员身份运行init.bat即可。删除的话再在根目录新建一个uninit.bat，依然是以管理员身份运行。代码如下：</p><blockquote><p>@echo offReg delete “HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\Background\shell\Cmder” /fpause</p></blockquote></blockquote><hr><h4 id="在设置中添加语言环境"><a href="#在设置中添加语言环境" class="headerlink" title="在设置中添加语言环境"></a>在设置中添加语言环境</h4><p><code>set LANG=zh_CN.UTF8</code></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/cmder/3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><hr><h4 id="设置默认使用cmd、PowerShell还是bash"><a href="#设置默认使用cmd、PowerShell还是bash" class="headerlink" title="设置默认使用cmd、PowerShell还是bash"></a>设置默认使用cmd、PowerShell还是bash</h4><p>安装之后默认的是<code>cmd</code>，至于选择哪个得看个人需求</p><p>对于普通使用者来说，这里从几个方面来比较一下 <code>cmd</code> 以及 <code>PowerShell</code></p><ul><li>资源占用</li></ul><p>当我们运行 <code>Cmd</code> 时，大概只需占用不到 1M 的内存，几乎可以忽略不计。</p><p>而使用 <code>PowerShell</code> 时，需要占用大约 20M的内存，两者几乎相差 40~50 倍。从这里可以看出，如果你的电脑比较老旧，性能较低，使用 <code>Cmd</code> 无疑可以获得更高的流畅性。</p><ul><li>界面</li></ul><p>当我们使用 <code>Cmd</code> 时，所有的字符都是同一个颜色的，无法实现语法高亮。但是，如果使用的是 <code>PowerShell</code>，关键字会被高亮，而且错误信息将以红色显示，确实美观不少。</p><ul><li>排版</li></ul><p>当我们使用 <code>Cmd</code> 运行一些较为复杂、较为耗时的命令时，随意拖动命令行窗口时，窗口中的内容依然能够保持原样，整洁美观。</p><p>但是，若是使用 <code>PowerShell</code> 执行同样的命令，情况就不容乐观了。如果在执行命令期间快速拖动命令行窗口，其窗口中的中文字符就会出现叠影，严重影响了阅读感。</p><ul><li>命令支持程度</li></ul><p><code>Cmd</code> 只能支持传统的 Windows 命令，既不能使用 <code>.net</code> 库中的命令，也不能使用 Linux 下的命令。但这方面 <code>PowerShell</code> 就强大多了，不仅完美支持传统 Windows 命令和 <code>.net</code> 库中的命令，也支持部分常用的 Linux 命令。</p><p>如果你并不常用命令行工具，建议使用 <code>Cmd</code>，它的资源占用更小，启动速度更快，而且更为成熟可靠稳定。但如果你是一个程序员，或是追求新奇特性，可以尝试使用 <code>PowerShell</code>，毕竟，它支持更多的命令内容，界面也更绚丽。</p><hr><h4 id="调节背景的透明度"><a href="#调节背景的透明度" class="headerlink" title="调节背景的透明度"></a>调节背景的透明度</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/cmder/4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><hr><h4 id="添加ll等命令"><a href="#添加ll等命令" class="headerlink" title="添加ll等命令"></a>添加<code>ll</code>等命令</h4><p>在<code>cmder-&gt;config-&gt;aliases</code>，打开<code>aliases</code>文件（我这里的便是<code>user-aliases.cmd</code>文件），将</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l=ls --show-control-chars </span><br><span class="line">la=ls -aF --show-control-chars </span><br><span class="line">ll=ls -alF --show-control-chars </span><br><span class="line">ls=ls --show-control-chars -F</span><br></pre></td></tr></table></figure><p>添加至文件末尾，用于增强命令并添加颜色区分。</p><hr><h3 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h3><table><thead><tr><th style="text-align:center">快捷键</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">Tab</td><td style="text-align:center">自动路径补全</td></tr><tr><td style="text-align:center">Ctrl+t</td><td style="text-align:center">建立新页签</td></tr><tr><td style="text-align:center">Ctrl+W</td><td style="text-align:center">关闭页签</td></tr><tr><td style="text-align:center">Ctrl+Tab</td><td style="text-align:center">切换页签</td></tr><tr><td style="text-align:center">Alt+F4</td><td style="text-align:center">关闭所有页签</td></tr><tr><td style="text-align:center">Alt+Shift+1</td><td style="text-align:center">开启cmd.exe</td></tr><tr><td style="text-align:center">Alt+Shift+2</td><td style="text-align:center">开启powershell.exe</td></tr><tr><td style="text-align:center">Alt+Shift+3</td><td style="text-align:center">开启powershell.exe (系统管理员权限)</td></tr><tr><td style="text-align:center">Ctrl+1</td><td style="text-align:center">快速切换到第1个页签</td></tr><tr><td style="text-align:center">Ctrl+n</td><td style="text-align:center">快速切换到第n个页签( n值无上限)</td></tr><tr><td style="text-align:center">Alt+enter</td><td style="text-align:center">切换到全屏状态</td></tr><tr><td style="text-align:center">Ctr+r</td><td style="text-align:center">历史命令搜索</td></tr><tr><td style="text-align:center">Win+Alt+P</td><td style="text-align:center">开启工具选项视窗</td></tr><tr><td style="text-align:center">Ctrl + Shift + v</td><td style="text-align:center">复制</td></tr></tbody></table><hr><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><h4 id="解决文字重叠问题"><a href="#解决文字重叠问题" class="headerlink" title="解决文字重叠问题"></a>解决文字重叠问题</h4><p><code>Win + Ait + P</code>唤出设置界面，<code>General-&gt; Fonts-&gt; monospce</code>,去掉那勾勾即可。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/cmder/5.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><hr><h4 id="修改命令提示符号λ"><a href="#修改命令提示符号λ" class="headerlink" title="修改命令提示符号λ"></a>修改命令提示符号<code>λ</code></h4><p>将<code>λ</code>符号修改成<code>$</code>，在<code>../cmder/vendor/clink.lua</code>批处理文件中，修改其中第43行的将<code>λ</code>为<code>$</code></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/cmder/6.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>修改前 <code>local lambda = &quot;λ&quot;</code>，修改后 <code>local lambda = &quot;$&quot;</code></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/cmder/7.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="分享" scheme="https://zhouie.cn/categories/%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Tool-share" scheme="https://zhouie.cn/tags/Tool-share/"/>
    
      <category term="Cmder" scheme="https://zhouie.cn/tags/Cmder/"/>
    
  </entry>
  
  <entry>
    <title>【Python学习实践】 speech智能语音模块</title>
    <link href="https://zhouie.cn/posts/201807271/"/>
    <id>https://zhouie.cn/posts/201807271/</id>
    <published>2018-07-27T20:25:11.000Z</published>
    <updated>2018-09-11T06:18:11.673Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p>🤷‍️最近的生活、学习节奏很是容易被打断，终于，在今天，既实习结束之后，夏令营也结束了。<br>前几天，一个人在复习地很累的时候，又重新将Python捡了起来，看了挺多的知识点。 真是太有意(wu)思(liao)了！</p></blockquote><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>1️⃣  <code>python2.*</code> 或 <code>python3.*</code></p><p>2️⃣  安装<code>pywin32</code>扩展库</p><p>3️⃣  安装<code>speech</code>模块</p><h4 id="安装Python-2-3"><a href="#安装Python-2-3" class="headerlink" title="安装Python 2/3"></a>安装Python 2/3</h4><ul><li>安装Python2还是Python3的选择上，我个人是推荐两个都装上，在某些地方用的时候稍微多个切换环境变量的步骤而已。当然了，我觉得就目前Python3已经推出的时长来看，初学者的话，还是建议先选择安装Python2熟悉Python的一些语法结构定义，而且使用上应该较舒适一些吧。毕竟Python2推出的时间更久一些，遇到一些问题，可供搜索的解决方案也丰富些；同时啊，目前仍让存有部分模块功能无法适应Python3或是Python3.*的较高版本。</li><li>具体安装的的过程就不详讲了，不管哪个版本都几乎大同小异，很容易上手也是Python的特性之一</li><li>安装完Python环境之后啊，毕竟也是一门编程语言，选择一个合适的IDE是必不可少的，这里的话，我推荐阅读一下<a href="http://www.runoob.com/python/python-ide.html" target="_blank" rel="noopener">Python IDE</a>，更多 Python IDE 请参阅：<a href="http://wiki.python.org/moin/PythonEditors" target="_blank" rel="noopener">http://wiki.python.org/moin/PythonEditors</a></li></ul><h4 id="PyCharm-IDE"><a href="#PyCharm-IDE" class="headerlink" title="PyCharm IDE"></a>PyCharm IDE</h4><p>在众多IDE中，最受大家追捧的一款便是PyCharm了，作为 <strong>JetBrains</strong>全家桶的一份子，这款软件具备完善功能，如：调试、语法高亮、项目管理、代码跳转、智能提示、自动完成，单元测试甚至版本控制等。另外，它还提供了一些很好的功能用于 <strong>Django 开发</strong>，同时支持 <strong>Google App Engine</strong>，更酷的是，PyCharm 支持 <strong>IronPython</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/speech/1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>官方下载地址：<a href="http://www.jetbrains.com/pycharm/download/" target="_blank" rel="noopener">http://www.jetbrains.com/pycharm/download/</a></p><p>IntelliJ IDEA 注册码:<a href="http://idea.lanyus.com/" target="_blank" rel="noopener">http://idea.lanyus.com/</a>以及提供的<a href="http://idea.lanyus.com/help/help.html" target="_blank" rel="noopener">破解帮助文档</a></p><p>IDEA系列主题下载地址：<a href="http://www.riaway.com/theme.php" target="_blank" rel="noopener">http://www.riaway.com/theme.php</a>，这些主题支持的IDE包括：InteliJ IDEA, PhpStorm, PyCharm, RubyMine, WebStorm and AppCode。</p><p>注：怎么安装下载的主题</p><ol><li>从主菜单打开你的编辑器选择<code>File-&gt;Import Setting</code> ，选择你下载的jar文件;</li><li>等待重启之后进行配置：打开<code>File-&gt;Settings-&gt;Editor-&gt;Colors and fonts</code>，然后选择你安装的主题即可完成。</li></ol><h4 id="安装pywin32扩展库"><a href="#安装pywin32扩展库" class="headerlink" title="安装pywin32扩展库"></a>安装pywin32扩展库</h4><p>pywin32即 <code>Python for Windows Extensions</code>，提供了Pyhton访问和调用Windows底层功能函数的接口，pywin32包括了<code>win32api</code>、<code>win32com</code>、<code>win32gui</code>、<code>win32process</code>等模块</p><p>下载地址：<a href="https://sourceforge.net/projects/pywin32/files/pywin32/Build%20221/" target="_blank" rel="noopener">https://sourceforge.net/projects/pywin32/files/pywin32/Build%20221/</a></p><p>这个要 <strong>根据Python版本（2.*/3.*）和CPU位数（32位/64位）下载相应版本并安装</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/speech/2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>比如，像我这种情况，就需要安装 <code>pywin32-221.win-amd64-py3.7.exe</code></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/speech/3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="安装speech模块"><a href="#安装speech模块" class="headerlink" title="安装speech模块"></a>安装speech模块</h4><p>使用<code>pip install speech</code>命令即可安装，但对于安装了Python3的用户来说，还需要针对Python3的一些新特性对安装后的配置文件做些修改</p><blockquote><p>至于这里的<code>pip</code>，它是Python包管理工具，该工具提供了对Python包的查找、下载、安装、卸载的功能；<br>同时，<code>Python 2.7.9 +</code> 和 <code>Python 3.4+</code> 以上版本都自带pip工具，只要安装的时候没取消勾选那个选项，一般都不用再特别安装了的，可以通过命令<code>pip --version</code>来判断是否已安装；<br>pip官网下载地址:<a href="https://pypi.org/project/pip/" target="_blank" rel="noopener">https://pypi.org/project/pip/</a>，注意，用哪个版本的 Python 运行安装脚本，pip 就被关联到哪个版本；<br>值得注意的是，部分 Linux 发行版可直接用包管理器安装 pip，如 Debian 和 Ubuntu：<code>sudo apt-get install python-pip</code>。</p></blockquote><h4 id="pip常用相关指令"><a href="#pip常用相关指令" class="headerlink" title="pip常用相关指令"></a>pip常用相关指令</h4><table><thead><tr><th style="text-align:center">功能</th><th style="text-align:center">指令</th></tr></thead><tbody><tr><td style="text-align:center">显示版本和路径</td><td style="text-align:center">pip –version</td></tr><tr><td style="text-align:center">获取帮助</td><td style="text-align:center">pip –help</td></tr><tr><td style="text-align:center">升级 pip</td><td style="text-align:center">pip install -U pip</td></tr><tr><td style="text-align:center">安装最新版本包</td><td style="text-align:center">pip install SomePackage</td></tr><tr><td style="text-align:center">安装指定版本</td><td style="text-align:center">pip install SomePackage==1.0.4</td></tr><tr><td style="text-align:center">最小版本</td><td style="text-align:center">pip install ‘SomePackage&gt;=1.0.4’</td></tr><tr><td style="text-align:center">升级包</td><td style="text-align:center">pip install –upgrade SomePackage</td></tr><tr><td style="text-align:center">升级至指定的包</td><td style="text-align:center">使用== 、 &gt;=</td></tr><tr><td style="text-align:center">卸载包</td><td style="text-align:center">pip uninstall SomePackage</td></tr><tr><td style="text-align:center">搜索包</td><td style="text-align:center">pip search SomePackage</td></tr><tr><td style="text-align:center">显示安装包信息</td><td style="text-align:center">pip show</td></tr><tr><td style="text-align:center">查看指定包的详细信息</td><td style="text-align:center">pip show -f SomePackage</td></tr><tr><td style="text-align:center">列出已安装的包</td><td style="text-align:center">pip list</td></tr><tr><td style="text-align:center">查看可升级的包</td><td style="text-align:center">pip list -o</td></tr></tbody></table><p>注：如果上面那个 <strong>升级pip命令</strong>出现问题 ，可以使用以下命令：<code>sudo easy_install --upgrade pip</code></p><h4 id="Python3-环境下正常使用speech的解决方法"><a href="#Python3-环境下正常使用speech的解决方法" class="headerlink" title="Python3.*环境下正常使用speech的解决方法"></a>Python3.*环境下正常使用speech的解决方法</h4><p><a href="https://pypi.org/project/speech/0.5.2/#description" target="_blank" rel="noopener">speech’s Project description</a></p><p>安装完speech模块后，需要去修改 <strong>speech.py</strong>文件，该文件路径在<code>..\Python37\Lib\site-packages</code>下</p><ol><li>line59 修改<code>import thread</code>，改成<code>import threading</code>；</li><li>line157 修改<code>print prompt</code>，改成<code>print(prompt)</code>；</li><li>对最后的函数<code>_ensure_event_thread</code>修改如下：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_ensure_event_thread</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Make sure the eventthread is running, which checks the handlerqueue</span></span><br><span class="line"><span class="string">    for new eventhandlers to create, and runs the message pump.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">global</span> _eventthread</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> _eventthread:</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">loop</span><span class="params">()</span>:</span></span><br><span class="line">            <span class="keyword">while</span> _eventthread:</span><br><span class="line">                pythoncom.PumpWaitingMessages()</span><br><span class="line">                <span class="keyword">if</span> _handlerqueue:</span><br><span class="line">                    (context,listener,callback) = _handlerqueue.pop()</span><br><span class="line">                    <span class="comment"># Just creating a _ListenerCallback object makes events</span></span><br><span class="line">                    <span class="comment"># fire till listener loses reference to its grammar object</span></span><br><span class="line">                    _ListenerCallback(context, listener, callback)</span><br><span class="line">                time.sleep(<span class="number">.5</span>)</span><br><span class="line">        _eventthread = T()</span><br><span class="line">        _eventthread.start()</span><br></pre></td></tr></table></figure><h3 id="智能语音自动读词脚本"><a href="#智能语音自动读词脚本" class="headerlink" title="智能语音自动读词脚本"></a>智能语音自动读词脚本</h3><p>前几天，朋友分享给我一个关于计算机专业相关英语词汇的文件，接收之后一直放在电脑桌面上，也不知道有没有用。今天下午的时候，因为最近的夏令营活动也一直有和AI相关研究领域团队交流，所以突然就想到可不可以将这些英语单词用已有的Python语音扩展包去实现一种类似于”课堂听写”的自动(谈不上智能)模式。</p><p>具体的源程序下面也可以看到，整个的程序结构很简陋，也没花多少时间，相信理解起来也并不难。</p><p>值得说明的有这么几点：</p><ol><li>提供的样例单词都是计算机专业相关的，如果你想换成别的单词，只需要修改<code>test.csv</code>文件即可。其中，<code>test.csv</code>文件中共有两列数据，分别代表英语词汇与相应中文释义，要想实现中英互译的功能，只要去将这列的顺序去对调一下即可。</li><li>和”课堂听写”模式相像，每次会相隔<code>Interval_Time</code>时间按行语音输出词汇两次（听写的时候，一般老师会间隔着地读2~3次），之后的话，每听写一小组词汇（LOOP_NUM个），就会将它们一起展示出来（中英对照），也以便看看自己的”正确率”有多高。</li><li>在选择哪个智能语音模块上，其实也有做了很多了解和实验<ul><li>最开始是打算用<a href="https://github.com/RapidWareTech/pyttsx" target="_blank" rel="noopener">pyttsx</a>（Python3好像要用<a href="https://github.com/nateshmbhat/pyttsx3" target="_blank" rel="noopener">pyttsx3</a>），期间碰到了不少的问题，尤其对于Python3来说，只能多去搜搜看了，<a href="http://www.cnblogs.com/leenid/p/6875031.html" target="_blank" rel="noopener">pyttsx的中文语音识别问题及探究之路</a>、<a href="https://pyttsx3.readthedocs.io/en/latest/" target="_blank" rel="noopener">pyttsx3 - Text-to-speech x-platform</a>、<a href="https://www.cnblogs.com/qq21270/p/7899622.html" target="_blank" rel="noopener">py库：文本转为语音（pywin32、pyttsx</a></li><li>之后也接触到了<a href="http://pydub.com/" target="_blank" rel="noopener">pydub</a>，pydub需要依赖<a href="https://libav.org/" target="_blank" rel="noopener">libav</a>或者<a href="https://zhouie.cn/posts/201807241">ffmpeg</a>，推荐阅读：<a href="https://www.jianshu.com/p/a9291fa603f6" target="_blank" rel="noopener">五十音听写：Python 音频处理库 pydub</a>、<a href="http://appleu0.sinaapp.com/?p=588" target="_blank" rel="noopener">python音频处理库：pydub</a>。</li></ul></li><li><p>既然谈到这儿，就多聊一些关于音频方面的内容，比如，如何使用Python播放<code>mp3</code>、<code>wav</code>、<code>ogg</code>格式的音频文件</p><ul><li><p>调用系统默认播放器播放</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">file = <span class="string">r'F:/Test/musicT/Hello.mp3'</span></span><br><span class="line">os.system(file)</span><br><span class="line">time.sleep(<span class="number">10</span>)</span><br></pre></td></tr></table></figure></li><li><p>pygame 播放，但存在语速失真的不足，pygame提供了两个加载音乐文件的方法</p><ul><li>pygame.mixer.Sound，主要加载ogg和wav音频文件。</li><li>pygame.mixer.music，主要加载mp3音频文件。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line">file = <span class="string">r'F:/Test/musicT/Hello.mp3'</span></span><br><span class="line">pygame.mixer.init()</span><br><span class="line">track = pygame.mixer.music.load(file)</span><br><span class="line">pygame.mixer.music.play()</span><br><span class="line">time.sleep(<span class="number">10</span>)</span><br><span class="line">pygame.mixer.music.stop()</span><br></pre></td></tr></table></figure></li><li><p>mp3play播放，语速正常，但貌似目前只能用于python2.*，不支持python3.*</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> mp3play</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">playmusic</span><span class="params">(path)</span>:</span></span><br><span class="line">    clip = mp3play.load(path)</span><br><span class="line">    clip.play()</span><br><span class="line">    time.sleep(<span class="number">10</span>)</span><br><span class="line">    clip.stop()</span><br><span class="line"></span><br><span class="line">file = <span class="string">r'F:/Test/musicT/Hello.mp3'</span></span><br><span class="line">playmusic(file)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>在编程过程中，有遇到了下面这种问题，针对这种情形的解决方案便是去任务管理下找到并结束智能语音进程。</p></li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/speech/4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h3><p>当然，也可以<a href="https://github.com/zhouie/vir_speaker" target="_blank" rel="noopener">去GitHub上Download Latest Version</a>，嗯emmm..，提前感谢您的<code>star</code> ⭐</p><pre><code class="python"><span class="comment">#!/usr/bin/env python</span><span class="comment"># -*- coding: utf-8 -*-</span><span class="comment"># @Time    : 2018/7/27 18:01</span><span class="comment"># @Author  : zhouie</span><span class="comment"># @File    : main.py</span><span class="comment"># @Software: PyCharm</span><span class="keyword">import</span> speech<span class="keyword">import</span> time<span class="keyword">import</span> csvdata = []  <span class="comment"># 暂存 *.csv 文件每行数据</span>Interval_Time = <span class="number">4</span>  <span class="comment"># 两次读词的间隔时间</span>LOOP_NUM = <span class="number">8</span>  <span class="comment"># 循环基数</span>Think_Time = <span class="number">15</span>  <span class="comment"># 回顾等待时间</span>csv_file = open(<span class="string">'./res/test.csv'</span>, encoding=<span class="string">'utf-8'</span>)csv_reader_lines = csv.reader(csv_file)<span class="comment"># print(csv_reader_lines)</span>num = <span class="number">0</span><span class="keyword">for</span> one_line <span class="keyword">in</span> csv_reader_lines:    data.append(one_line)    num = num + <span class="number">1</span>speech.say(<span class="string">"计算机专业相关的英语单词 中英互译 测试小程序，demo版"</span>)speech.say(<span class="string">"This is a small routine (compiled by Python) for exercise about English phrases in the field of computer"</span>)i = <span class="number">0</span><span class="keyword">while</span> i &lt; num:    <span class="comment"># print(i + 1, data[i][0])</span>    <span class="comment"># speech.say(i + 1)</span>    <span class="comment"># speech.say(data[i][0])</span>    <span class="comment"># time.sleep(Interval_Time)</span>    <span class="comment"># speech.say(data[i][0])</span>    <span class="keyword">if</span> <span class="number">0</span> == (i + <span class="number">1</span>) % LOOP_NUM:        speech.say(<span class="string">"来回顾一下 以上所学的几个词汇吧"</span>)        speech.say(<span class="string">"Just follow me , look back on the words you have learned..."</span>)        print(<span class="string">"!--#######--*--#######--!"</span>)        print(<span class="string">"第"</span>, int(i / LOOP_NUM) + <span class="number">1</span>, <span class="string">"组词汇："</span>)        <span class="keyword">for</span> j <span class="keyword">in</span> range(i - (LOOP_NUM - <span class="number">1</span>), i + <span class="number">1</span>):            print(data[j][<span class="number">0</span>], data[j][<span class="number">1</span>])            speech.say(data[j][<span class="number">0</span>])            speech.say(data[j][<span class="number">1</span>])        print(<span class="string">"!--#######--*--#######--!"</span>)        speech.say(<span class="string">"你的正确率如何呢？"</span>)        speech.say(<span class="string">"So , What about your correct rate?"</span>)        time.sleep(Think_Time)    i = i + <span class="number">1</span>speech.say(<span class="string">"Congratulation!"</span>)</code></pre><h3 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h3><iframe frameborder="0" width="100%" height="500" src="https://v.qq.com/iframe/player.html?vid=o0737zviriw&tiny=0&auto=0" allowfullscreen></iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Python学习实践" scheme="https://zhouie.cn/categories/Python%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="Python" scheme="https://zhouie.cn/tags/Python/"/>
    
      <category term="speech" scheme="https://zhouie.cn/tags/speech/"/>
    
  </entry>
  
  <entry>
    <title>【软件测试】 实习分享与总结</title>
    <link href="https://zhouie.cn/posts/201807191/"/>
    <id>https://zhouie.cn/posts/201807191/</id>
    <published>2018-07-19T14:55:42.000Z</published>
    <updated>2018-09-11T06:18:11.673Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="100%" height="86" src="//music.163.com/outchain/player?type=2&id=139377&auto=0&height=66"></iframe><hr><blockquote><p>实习方向：软件测试<br>实习时间：2018/07/02 —— 2018/07/18<br>实习地点：湖南省长沙市天心区五一广场五一新干线（实际上呢…SANY）<br>授课内容：功能测试、性能测试、UI自动化测试、Linux基本指令以及SVN版本控制系统相关知识。</p></blockquote><p>总结来说，<br>学会了如何规范编写测试样例、缺陷记录并基本掌握了功能测试课程基本内容，对于软件测试行业也有了一定的认知和把握；</p><p>学会了如何使用Loadrunner性能测试工具进行测试脚本录制，并创建模拟场景进行分析，撰写性能测试分析报告；</p><p>学会了使用Selenium + Webdriver进行UI自动化测试脚本的编写，能够编写针对百度、京东购物网站几项主要功能的Java测试脚本；</p><p>同时，也掌握了SVN版本控制相关知识和一些Linux基本指令，并基于RedHat Linux服务端发布Bugzilla网站加以锻炼。</p><p>好吧，就记这些了，再补上几张图片吧！</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/softTest/1.jpeg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/softTest/2.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/softTest/3-1.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/softTest/3-2.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/softTest/4-1.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/softTest/4-2.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/softTest/4-3.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/softTest/4-4.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/softTest/5-1.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/softTest/7.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="软件测试" scheme="https://zhouie.cn/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="XTU" scheme="https://zhouie.cn/tags/XTU/"/>
    
      <category term="实习" scheme="https://zhouie.cn/tags/%E5%AE%9E%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>【软件测试】 Bugzilla的安装配置 - RedHat Linux</title>
    <link href="https://zhouie.cn/posts/201807181/"/>
    <id>https://zhouie.cn/posts/201807181/</id>
    <published>2018-07-18T22:13:31.000Z</published>
    <updated>2018-09-11T06:18:11.673Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>这次长沙实习中接触到了 “Linux环境下安装配置Bugzilla” 这个需求，其实最开始也是不明所以的，连Bugzilla是什么都不清楚，也是安装教程稀里糊涂地给装好了。至于安装教程下面也会讲到，不过在这之前，先看一下Bugzilla系统究竟是什么吧？</p><blockquote><p>Bugzilla是Mozilla公司向我们提供的一个开源的免费缺陷跟踪工具,它能够为你建立一个完善的Bug跟踪体系，包括报告Bug、查询Bug记录并产生报表、处理解决、管理员系统初始化和设置四部分</p></blockquote><p>因为Bugzilla是开源的，所以在网上也有很多基于此开发出的在线缺陷跟踪站点；我这里讲的是如何在Linux环境下安装配置Bugzilla，当然，在windows平台下依然可以成功安装使用，这个有兴趣的可以自行去尝试一下，我个人觉得没必要。毕竟将服务端部署在Linux环境下维护起来更加灵活方便一些。</p><p>注意：以下操作是在虚拟机上进行的…</p><h3 id="准备点什么"><a href="#准备点什么" class="headerlink" title="准备点什么"></a>准备点什么</h3><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p><a href="https://pan.baidu.com/s/1jGPsHFOiDGD47gHHXhhfdA" target="_blank" rel="noopener">Red Hat Linux光盘映像文件</a>，提取码：skny<br><a href="https://pan.baidu.com/s/1xENl7EHPPNOlkxAIlWpXQg" target="_blank" rel="noopener">Bugzilla光盘映像文件</a>，提取码：3f4f</p><h4 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h4><ul><li>操作系统：<ul><li>发行版本 Red Hat Linux Realease 9（Shrike）</li><li>内核版本 Linux 2.4.20-8 #1 Thu Mar 13 17:54:28 EST 2003 i686 i686 i386 GNU/Linux</li></ul></li><li>Perl解释器：Perl-5.8.0-88</li><li>数据库：MySQL Ver 12.22 Distrib 4.0.21 ,for pc-linux</li><li>Web服务器(Apache)：httpd-2.0.40-21</li></ul><p>补充说明：</p><p>1、如何查看发行版本、内核版本</p><p>查看内核版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uname -a            #显示电脑以及操作系统的相关信息</span><br><span class="line">或</span><br><span class="line">cat /proc/version   #正在运行的内核版本</span><br></pre></td></tr></table></figure><p>查看发行版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/redhat-release</span><br><span class="line">或</span><br><span class="line">cat /etc/issue</span><br></pre></td></tr></table></figure><blockquote><p>说明一下：<br>内核版本 Linux 2.4.20-8 #1 Thu Mar 13 17:54:28 EST 2003 i686 i686 i386 GNU/Linux<br>其中，2是主版本，4是次版本（偶数代表稳定版本，奇数代表测试版本），20是release version，8是revised version。</p></blockquote><p>2、如何查看perl解释器、MySQL数据库、Apache服务器版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -q perl         #perl解释器</span><br><span class="line">rpm -q httpd        #Apache服务器版本</span><br><span class="line">mysql --version     #MySQL数据库</span><br></pre></td></tr></table></figure><h3 id="正式安装配置"><a href="#正式安装配置" class="headerlink" title="正式安装配置"></a>正式安装配置</h3><h4 id="提前准备"><a href="#提前准备" class="headerlink" title="提前准备"></a>提前准备</h4><h5 id="安装Apache-httpd服务"><a href="#安装Apache-httpd服务" class="headerlink" title="安装Apache(httpd服务)"></a>安装Apache(httpd服务)</h5><p>注意，这需要挂载至磁盘1，也就是<code>shrike-i386-disc1.iso</code>磁盘下，至于怎么挂载，请参照下面的动图来操作即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/cdrom /mnt/cdrom</span><br></pre></td></tr></table></figure><p>挂载之后，再去安装httpd服务（因为Linux镜像文件自带httpd服务的安装包，所以没去在线下载，当然了在线下载也是可以的），因为我之前已经安装过一次了，所以，再次安装它会提示我<code>Already installed</code>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/bugzilla/1.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h5 id="修改IP信息"><a href="#修改IP信息" class="headerlink" title="修改IP信息"></a>修改IP信息</h5><p>修改IP地址确保虚拟机与主机网络地址相同（前三个字段），这样互相才能ping通。因为我的网络IP地址是随机分配的，所以我这里选择临时修改IP地址方式。当然网上也有更多一些其他方式，自查</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 192.168.1.103 netmask 255.255.255.0</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/bugzilla/2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h4><p>将磁盘挂起至<code>/mnt/cdrom</code>目录下，挂起步骤如上所示（ps：<code>umount /mnt/cdrom</code> 解开挂载指令）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/cdrom /mnt/cdrom</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/bugzilla/3.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>磁盘挂载后，这个目录<code>/mnt/cdrom</code>下有着这些文件：(3个MySQL.rpm文件、gcc.rpm文件、perl文件夹、buzilla压缩包)</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/bugzilla/4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>之后我们需要将<code>/mnt/cdrom</code>中的文件复制cp到<code>/tmp</code>目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /tmp/perl</span><br><span class="line">cp /mnt/cdrom/* /tmp/</span><br><span class="line">cp /mnt/cdrom/perl/* /tmp/perl/</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/bugzilla/5.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>解压bugzilla文件包，然后将文件移到<code>/var/www/html/bugzilla</code>目录下（ps:<code>/var/www/html</code>为apache的 docroot，可以在<code>httpd.conf</code>中修改<code>DocumentRoot &quot;/var/www/html&quot;</code>这条语句来换个位置）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/bugzilla/6-1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/bugzilla/6-2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>注意：记住上面提到的几个目录：<code>/tmp</code>、<code>/tmp/perl</code>、<code>/var/www/html/bugzilla</code>，在整个安装过程中可能会在这几个目录来回切入切出，所以心里要有点数：每个目录下的文件有哪些？是干嘛的？</p><h4 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h4><p>下面就算是正式进入Perl模块的安装了，很多操作可能是重复的，所以有点耐心吧</p><p>主要安装的组件有哪些呢？可以通过这个命令来实时看一下自己还需要安装哪些</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/bugzilla/7-1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/bugzilla/7-2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/bugzilla/7-3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>AppConfig</li><li>CGI</li><li>TimeDate</li><li>DBI</li><li>MySQL</li><li>DBD(要在MySQL装了之后再装)</li><li>gcc</li><li>gd</li><li>GD</li><li>Template-toolkit</li><li>GDTextUtil</li><li>GDGraph</li><li>Chart</li></ul><p>perl指令说明<br><code>perl Makefile.PL</code>(生成Makefile安装文件，没生成功的，删除Makefile文件、再装)、<code>make</code>(编译)、<code>make test</code>(测试能不能安装，有无系统或文件依赖) 、<code>make install</code>(安装)、<code>cd  /var/www/html/bugzilla</code>(返回bugzailla看看是否安装成功)、<code>perl checksetup.pl |more</code>(或 <code>./checksetup.pl|more</code>，看到Appconfig为OK就是安装好了)</p><p>注意：<code>make test</code>、<code>cd  /var/www/html/bugzilla</code>、<code>perl checksetup.pl |more</code>这些在接下来的安装过程中是用来检查安装情况的，是可以不用每次都敲一遍的。</p><p>安装下面的顺序来安装即可</p><p>(一)、安装AppConfig-1.56<br>进入/tmp/perl,解压AppConfig-1.56.tar.gz，然后进入AppConfig-1.56文件，perl Makefile.PL、make、make test 、make install、cd /var/www/html/bugzilla、perl checksetup.pl |more</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/bugzilla/8-1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/bugzilla/8-2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>(二)、安装CGI.pm-3.05<br>进入/tmp/perl,解压CGI.pm-3.05.tar.gz，然后进入CGI.pm-3.05,perl Makefile.PL、make、make test 、make install、cd /var/www/html/bugzilla、perl checksetup.pl |more</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/bugzilla/9-1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/bugzilla/9-2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/bugzilla/9-3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>(三)、安装TimeDate-1.16<br>进入/tmp/perl,解压TimeDate-1.16.tar.gz，然后进入TimeDate-1.16,perl Makefile.PL、make、make test 、make install、cd  /var/www/html/bugzilla、perl checksetup.pl |more</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/bugzilla/10-1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/bugzilla/10-2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>(四)、安装DBI-1.45<br>进入/tmp/perl,解压DBI-1.45.tar.gz，然后进入DBI-1.45,perl Makefile.PL、make、make test 、make install、cd /var/www/html/bugzilla、perl checksetup.pl |more</p><p>这里就不放截图了哦，过程步骤同上面是类似的。</p><p>(五)、安装MySQL-client-4.0.21-0.i386.rpm、MySQL-devel-4.0.21-0.i386.rpm、MySQL-server-4.0.21-0.i386.rpm</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/bugzilla/11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>(六)、安装DBD-mysql-2.9004(要在安装了数据库之后安装)<br>进入/tmp/perl,解压DBD-mysql-2.9004.tar.gz，然后进入DBD-mysql-2.9004.,unset LANG(清掉设置，如有Makefile文件将它删掉)、perl Makefile.PL、make、make test 、make install、cd  /var/www/html/bugzilla、perl checksetup.pl |more</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/bugzilla/12-1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/bugzilla/12-2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>(七)、安装gcc -3.2.2-5.i386.rpm</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/bugzilla/13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>(八)、安装gd-2.0.33<br>进入/tmp/perl,解压gd-2.0.33.tar.gz，然后进入gd-2.0.33,./configure、make、make check、make install、cd /var/www/html/bugzilla、perl checksetup.pl |more</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/bugzilla/14-1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/bugzilla/14-2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>(九)、安装GD-2.30<br>进入/tmp/perl,解压GD-2.30.tar.gz ，然后进入GD-2.30,perl Makefile.PL、make、make test、make install、cd /var/www/html/bugzilla、perl checksetup.pl |more</p><p>这里就不放截图了哦，过程步骤同上面是类似的。</p><p>(十)、安装Template-Toolkit-2.14<br>进入/tmp/perl,解压Template-Toolkit-2.14.tar.gz，然后进入Template-Toolkit-2.14,perl Makefile.PL、make、make test、make install、cd  /var/www/html/bugzilla、perl checksetup.pl |more</p><p>这里就不放截图了哦，过程步骤同上面是类似的。</p><p>(十一)、安装GDTextUtil -0.86<br>进入/tmp/perl,解压GDTextUtil -0.86.tar.gz，然后进入GDTextUtil -0.86,perl Makefile.PL、make、make test、make install、cd  /var/www/html/bugzilla、perl checksetup.pl |more</p><p>这里就不放截图了哦，过程步骤同上面是类似的。</p><p>(十二)、安装GDGraph-1.43<br>进入/tmp/perl,解压GDGraph-1.43.tar.gz，然后进入GDGraph-1.43,perl Makefile.PL、make、make test、make install、cd /var/www/html/bugzilla、perl checksetup.pl |more</p><p>这里就不放截图了哦，过程步骤同上面是类似的。</p><p>(十三)、安装Chart-2.3<br>进入/tmp/perl,解压Chart-2.3.tar.gz，然后进入Chart-2.3,perl Makefile.PL、make、make test、make install、cd /var/www/html/bugzilla、perl checksetup.pl |more</p><p>这里就不放截图了哦，过程步骤同上面是类似的。</p><p>(十四)、验证检查一下目前的安装情况</p><p>再次执行perl checksetup.pl |more 命令，看看是否以上组件是否都安装好了</p><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><p>(一)、修改localconfig文件</p><blockquote><p>localconfig文件包含安装时需要设定的很多重要信息，比如比如，<code>$webservergroup=&#39;daemon&#39;</code> 表示apache使用的group；<code>$db_driver = &#39;mysql&#39;;</code>表示使用的数据库；<code>$db_host = &#39;localhost&#39;;</code>表示数据库服务器ip；<code>$db_name = &#39;bugs&#39;;</code>表示数据库名称；<code>$db_user = &#39;bugs&#39;;</code>表示连接数据库的用户名；<code>$db_pass = &#39;bugs&#39;;</code>表示连接数据库的用户密码。</p></blockquote><p>我们需要根据实际情况来手动修改这些配制项。特别的数据库账户，需要我们事先在数据库中创建出这个账户并赋予其相应权限，以便下一步安装时通过通过该用户执行建库脚本！</p><p><code>cd /var/www/html/bugzilla</code>，进入修改bugzilla目录下，<code>vi localconfig</code>，修改localconfig文件</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/bugzilla/15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>(二)、修改Apache的配置</p><blockquote><p>我们需要通过配置来告诉Apache新安装的bugzilla的位置，并且特别告知它是一个cgi程序，具体配制方法就是在apache的conf/httpd.conf文件中加入以下代码：</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/bugzilla/16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>说明：<br><code>AddHandler cgi-script .cgi</code> 指明这个目录是cgi应用；<code>Options Indexes ExecCGI</code> 赋予执行 cgi应用的权力<br>Apache的配置文件 httpd.conf 在<code>/etc/httpd/conf</code>目录下，注意，修改后需重启Apache服务！ </p><h4 id="最后一步"><a href="#最后一步" class="headerlink" title="最后一步"></a>最后一步</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/bugzilla/17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>按照上面的操作走完之后，将会提示输入管理员邮件地址、真实用户名、密码，至于，bugzilla的安装已经完成。</p><p>访问服务器IP/bugzilla（这里的服务器IP就是之前配置的临时IP地址，这个依照你主机的IP地址来定就好，比如我的就是<a href="http://192.168.1.103/bugzilla/index.cgi）" target="_blank" rel="noopener">http://192.168.1.103/bugzilla/index.cgi）</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/bugzilla/18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="软件测试" scheme="https://zhouie.cn/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="实习" scheme="https://zhouie.cn/tags/%E5%AE%9E%E4%B9%A0/"/>
    
      <category term="Bugzilla" scheme="https://zhouie.cn/tags/Bugzilla/"/>
    
      <category term="缺陷管理" scheme="https://zhouie.cn/tags/%E7%BC%BA%E9%99%B7%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>【分享】 目录文件同步工具</title>
    <link href="https://zhouie.cn/posts/201807121/"/>
    <id>https://zhouie.cn/posts/201807121/</id>
    <published>2018-07-12T15:33:21.000Z</published>
    <updated>2018-09-11T06:18:11.673Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>将两个文件夹内的文件内容进行分析，可选择性的让两个文件夹内容保存一致，可以称为一种同步机制。这种实现各个物理设备间的数据及时同步更新，在有些时候，能够为你节省很多时间和操作，同时免去一些不必要的失误与遗忘。比如说：同步U盘上的数据和软件设置，查找软件版本区别和更新，同步FTP上的数据。网上有这样一些案例：</p><blockquote><p>案例1：工作中有很多的资料，保存在公司的电脑硬盘上，但是经常要带回去加班，总是会将资料拷贝到移动硬盘中，但是在家做完以后，回到公司有的文件会忘记覆盖，搞得经常会重复劳动。</p><p>案例2：自从买了新的台式机之后，为了兼顾到外出常带着的PC，如何将一些资料档案的同步问题着实令人伤脑筋。以人工的方式在两台电脑上反复复制，很容易忘记哪一台电脑缺少了哪些资料文档。</p></blockquote><p>当然了，网络云服务的逐渐普及开来，也削减了这种不便，但这并不影响我坚持使用下面的一些本地数据同步工具。</p><h3 id="PathSync-para"><a href="#PathSync-para" class="headerlink" title="PathSync &para;"></a>PathSync &para;</h3><h4 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h4><p><a href="https://www.cockos.com/pathsync/" target="_blank" rel="noopener">官网地址</a><br><a href="https://pan.baidu.com/s/1Jc4uo6-zYA1WwJUIOLem6g" target="_blank" rel="noopener">百度云分享</a>（提取码：a2py）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/path_sync/1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="PathSync是什么"><a href="#PathSync是什么" class="headerlink" title="PathSync是什么"></a>PathSync是什么</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">an interactive directory (path) synchronizer <span class="keyword">for</span> windows</span><br><span class="line">PathSync can analyze two directories <span class="keyword">and</span> show the<span class="built_in"> user </span>a list of differences between the directories. </span><br><span class="line">The<span class="built_in"> user </span>can select what actions should occur (which files <span class="keyword">to</span> overwrite, which <span class="keyword">to</span> delete, which <span class="keyword">to</span> ignore), <span class="keyword">and</span> allow PathSync <span class="keyword">to</span> synchronize. </span><br><span class="line">PathSync provides nifty statistics during the synchronization, so that the<span class="built_in"> user </span>is never wondering how much time is left, etc. </span><br><span class="line">PathSync is GPL free software, each download package includes the source.</span><br></pre></td></tr></table></figure><p>PathSync 是由<a href="http://www.cockos.com/products.php" target="_blank" rel="noopener">Cockos</a> 出品的一款小应用，估计他们本来也就是随便玩玩的，结果是无心插柳柳成荫，反而将Pathsync做成了一个体积小巧，功能强大的同步工具。从04年到现在，已经陆续推出了10个版本，最后一次更新是在2015年12月28日。</p><p>其中，Cockos 是 <a href="http://zhouie.cn/posts/201803161">Justin Frankel</a> (开发 <a href="http://www.winamp.com/" target="_blank" rel="noopener">Winamp</a> 的那个家伙) 成立的公司，开发的产品也是和音频有关的。</p><p>另外，PathSync 是一款<a href="https://baike.baidu.com/item/GPL/2357903?fr=aladdin" target="_blank" rel="noopener">GPL协议</a>免费软件，每一个下载安装包都应当包含源码。</p><h3 id="SyncBack-para"><a href="#SyncBack-para" class="headerlink" title="SyncBack &para;"></a>SyncBack &para;</h3><h4 id="下载地址-1"><a href="#下载地址-1" class="headerlink" title="下载地址"></a>下载地址</h4><p><a href="https://www.2brightsparks.com/" target="_blank" rel="noopener">官网地址</a></p><p>官网同时提供了付费版本及免费版本的下载，个人建议一般使用者使用免费版本的就足够了。</p><h4 id="SyncBack是什么"><a href="#SyncBack是什么" class="headerlink" title="SyncBack是什么"></a>SyncBack是什么</h4><p>SyncBack是一套很强大的档案备份及同步软体，对于同步的规则定义的很详细，可以很容易的依需要做设定</p><p>SyncBack不止对于同步本机的资料夹、档案表现相当良好, 对于FTP 上的的档案及资料夹的同步也是没问题的，可以节省很多时间</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/path_sync/2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="分享" scheme="https://zhouie.cn/categories/%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Tool-share" scheme="https://zhouie.cn/tags/Tool-share/"/>
    
      <category term="cockos" scheme="https://zhouie.cn/tags/cockos/"/>
    
      <category term="文件同步" scheme="https://zhouie.cn/tags/%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>【软件测试】 Selenium环境搭建-Eclipse 简易教程</title>
    <link href="https://zhouie.cn/posts/201807101/"/>
    <id>https://zhouie.cn/posts/201807101/</id>
    <published>2018-07-10T23:30:11.000Z</published>
    <updated>2018-09-11T06:18:11.673Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><ul><li>selenium是可以支持多平台的，本身的环境安装也是很简单的</li><li>学习的测试脚本编写是Java语言，所以之后要将selenium与eclipse集联起来</li><li>将selenium与eclipse集联起来也是这次配置体验中可能会出现的（一些）难点</li><li>对软件测试还算不上熟练掌握，如果错误，欢迎指正</li></ul><h3 id="安装（配置）步骤说明"><a href="#安装（配置）步骤说明" class="headerlink" title="安装（配置）步骤说明"></a>安装（配置）步骤说明</h3><ol><li>安装配置好JAVA环境（JDK 1.8以上）以及Eclipse（建议使用高版本）</li><li>安装配置好mvn（Maven）本地环境</li><li>Eclipse安装Maven插件</li><li>准备好与浏览器对应的WebDriver</li><li>在Eclipse中新建<code>Maven Projects -&gt; pom.xml文件中安装selenium-java dependency（依赖） -&gt; 编写一个简易的测试脚本代码演示</code></li></ol><p>其中，selenium与eclipse集联的关键步骤在于第5步，后面也会提到。</p><h3 id="安装配置JAVA环境"><a href="#安装配置JAVA环境" class="headerlink" title="安装配置JAVA环境"></a>安装配置JAVA环境</h3><h4 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h4><p>这里提供一下一直在用版本号为”1.8.0_92”的JDK安装包下载链接</p><p><a href="https://pan.baidu.com/s/1vKczTd4XobGMFLmiiVDRIQ" target="_blank" rel="noopener">JDK-1.8.0_92</a>，提取密码：929a</p><p>特别注意：可以不用我这里所提供的JDK安装包，去<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">Oracle 官网</a>去找相应版本JDK，那么你所下载的JDK版本也要保证至少要1.8以上</p><p>相信不少朋友的电脑上都安装配置有JAVA环境（JDK），那么可以通过<code>Win + R</code> -&gt; <code>cmd</code> -&gt; <code>java -version</code> 来查看是否安装了JAVA环境以及相应JDK版本</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/selenium/1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>至于安装JDK的步骤，一直默认Next即可，没有什么需要特别注意的。</p><h4 id="配置本机JAVA环境"><a href="#配置本机JAVA环境" class="headerlink" title="配置本机JAVA环境"></a>配置本机JAVA环境</h4><ul><li>安装完成后，右击”我的电脑”，点击”属性”，选择”高级系统设置”</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/selenium/2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>选择”高级”选项卡，点击”环境变量”</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/selenium/3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>然后就会出现如下图所示的画面：</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/selenium/4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>在”<strong>系统变量</strong>“中设置3项属性，JAVA_HOME,PATH,CLASSPATH(大小写无所谓),若已存在则点击”编辑”，不存在则点击”新建”。变量设置参数如下：</li></ul><table><thead><tr><th style="text-align:center">变量名</th><th style="text-align:center">变量值</th></tr></thead><tbody><tr><td style="text-align:center">JAVA_HOME</td><td style="text-align:center">C:\Program Files (x86)\Java\jdk1.8.0_91 //根据自己的实际路径配置</td></tr><tr><td style="text-align:center">CLASSPATH</td><td style="text-align:center">.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;//记得前面有个”.”</td></tr><tr><td style="text-align:center">Path</td><td style="text-align:center">%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;</td></tr></tbody></table><blockquote><p>注意：在 Windows10 中，因为系统的限制，path 变量只可以使用 JDK 的绝对路径。%JAVA_HOME% 会无法识别，导致配置失败。如下所示：</p><blockquote><p>C:\Program Files (x86)\Java\jdk1.8.0_91\bin;C:\Program Files (x86)\Java\jdk1.8.0_91\jre\bin;</p></blockquote><p>如果使用1.5以上版本的JDK，不用设置CLASSPATH环境变量，也可以正常编译和运行Java程序。</p></blockquote><ul><li>测试JDK是否安装成功<ul><li><code>Win + R</code> -&gt; <code>cmd</code></li><li>键入命令: <code>java -version</code>、<code>java</code>、<code>javac</code> 几个命令，出现以下信息，说明环境变量配置成功</li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/selenium/5.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="Eclipse-IDE"><a href="#Eclipse-IDE" class="headerlink" title="Eclipse IDE"></a>Eclipse IDE</h4><p>至于Eclipse IDE，网上版本有很多，不过我个人还是建议到<a href="http://www.eclipse.org/" target="_blank" rel="noopener">Eclipse官网</a>下载安装，功能完善还很放心</p><p>考虑到高版本的Eclipse IDE自带了mvn插件，不用安装能免去一些步骤，建议去安装较高版本的</p><blockquote><p>在eclipse的4.4以上的版本加入了对maven的支持，即不需要安装maven插件，但对4.4以下的版本需要自己安装插件</p></blockquote><p>这里提供一个Eclipse压缩文件（该Eclipse版本号为：Neon.3 Release-4.6.3，解压打开即可使用）</p><p><a href="https://pan.baidu.com/s/1RiSIkljL1PGwVoE062Nq9w" target="_blank" rel="noopener">eclipse-jee-neon-R-win32-x86_64</a>，提取密码：g440。</p><h3 id="安装配置mvn（Maven）本地环境"><a href="#安装配置mvn（Maven）本地环境" class="headerlink" title="安装配置mvn（Maven）本地环境"></a>安装配置mvn（Maven）本地环境</h3><h4 id="下载与安装-1"><a href="#下载与安装-1" class="headerlink" title="下载与安装"></a>下载与安装</h4><p>这里提供一个Maven程序包：<a href="https://pan.baidu.com/s/1vnn9JAZ57nKqfPjskUTAvw" target="_blank" rel="noopener">apache-maven-3.3.9</a>，提取密码：3xwe。当然，也可前往<a href="https://maven.apache.org/download.cgi" target="_blank" rel="noopener">https://maven.apache.org/download.cgi</a>下载编译过的版本</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/selenium/6.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>将文件解压到<code>D:\Program Files\apache-maven-3.3.9</code>目录下，文件目录结构如下所示：<ul><li>bin目录：该目录包含了mvn运行的脚本，这些脚本用来配置Java命令；</li><li>boot目录：只包含一个文件：plexus-classworlds-2.5.2.jar，是一个类加载器框架，相当于java类的默认加载器。</li><li>conf目录：包含了settings.xml，一个重要的配置文件，可以全局定制Maven的行为。</li><li>lib目录：该目录包含了所有Maven运行时需要的Java类库。</li><li>LICENSE.txt</li><li>NOTICE.txt：记录了Maven包含的第三方软件。</li><li>README.txt</li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/selenium/7.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>同JDK环境配置一样，新建环境变量 <code>MAVEN_HOME</code>，赋值<code>D:\Program Files\apache-maven-3.3.9</code></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/selenium/8.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>新建环境变量 <code>MAVEN</code> ，赋值 <code>%MAVEN_HOME%\bin</code></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/selenium/9.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>新建环境变量 <code>MAVEN_OPTS</code> ，赋值 <code>-Xms256m -Xmx512m</code></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/selenium/10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>编辑环境变量<code>Path</code>，增加<code>%MAVEN%;</code></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/selenium/11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>测试mvn是否安装成功<ul><li><code>Win + R</code> -&gt; <code>cmd</code></li><li>键入命令: <code>mvn -v</code>，出现以下信息，说明mvn环境配置成功</li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/selenium/12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="配置Maven本地仓库"><a href="#配置Maven本地仓库" class="headerlink" title="配置Maven本地仓库"></a>配置Maven本地仓库</h4><ul><li><p>在E盘目录下新建<code>maven-repository</code>文件夹，该目录用作maven的本地仓库。</p></li><li><p>打开<code>D:\Program Files\apache-maven-3.3.9\conf\settings.xml</code>文件，查找下面这行代码：</p></li></ul><blockquote><localrepository>/path/to/local/repo</localrepository></blockquote><p><code>localRepository</code>节点默认是被注释掉的，需要把它移到注释之外，然后将<code>localRepository</code>节点的值改为我们在上面创建的目录<code>E:\maven-repository</code>，这里记得写成绝对路径，你所下载的包就会放在你填写的目录下了。</p><p>说明：<code>localRepository</code>节点用于配置本地仓库，本地仓库其实起到了一个缓存的作用，它的默认地址是 <code>C:\Users\计算机用户名\.m2</code>，我们一般会自己定义一个文件夹，让maven的依赖包装在你所想要放在文件夹下，便于以后自己的维护和管理。<br>当我们从maven中获取jar包的时候，maven首先会在本地仓库中查找，如果本地仓库有则返回；如果没有则从远程仓库中获取包，并在本地仓库中保存。<br>此外，我们在maven项目中运行<code>mvn install</code>，项目将会自动打包并安装到本地仓库中。</p><ul><li>仓库镜像的配置 </li></ul><p>maven自带的仓库是国外的maven官方的一个仓库<a href="http://repo1.maven.org/maven2/" target="_blank" rel="noopener">http://repo1.maven.org/maven2/</a>，一般不翻墙的话速度非常慢</p><p>在setting.xml中找到<code>&lt;mirrors&gt;…………&lt;/mirrors&gt;</code>的位置，在<code>&lt;mirrors&gt;…………&lt;/mirrors&gt;</code>中间加入你想要的仓库的标签，这里推荐几个国内网速比较快，资源比较全的仓库</p><p>1、阿里云的maven仓库</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>        </span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、开源中国的仓库</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-osc<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus osc<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.oschina.net/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-osc-thirdparty<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>thirdparty<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus osc thirdparty<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.oschina.net/content/repositories/thirdparty/<span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>运行<code>mvn help:system</code>命令验证一下，运行情况应该如下图所示，如果前面的配置成功，那么<code>E:\maven-repository</code>会出现一些文件。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/selenium/13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>这里补充一下，要不要设置HTTP代理呢？</li></ul><p>如果上网没使用代理，这里则不需要配置。但是之前帮别的同学在Eclipse中安装Maven插件时失败了好多次，我也不知道是不是之前没有设置HTTP代理的原因，所以保险起见，最好还是配置一下吧</p><p>首先在cmd中输入：<code>ping repo1.maven.org</code>，如果不能ping通，则一定要先设置一下代理，设置的方式为：</p><p>进入Maven目录下，找到settings.xml文件，然后在<code>&lt;proxies&gt;</code>标签中加入如下信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">proxies</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">proxy</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>my-proxy<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">active</span>&gt;</span>true<span class="tag">&lt;/<span class="name">active</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">protocol</span>&gt;</span>http<span class="tag">&lt;/<span class="name">protocol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">host</span>&gt;</span>114.212.80.250<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span>&gt;</span>80<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">username</span>&gt;</span>PARK<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">password</span>&gt;</span>****<span class="tag">&lt;/<span class="name">password</span>&gt;</span>     </span><br><span class="line">  <span class="tag">&lt;<span class="name">nonProxyHosts</span>&gt;</span>www.park.com|*.host.com<span class="tag">&lt;/<span class="name">nonProxyHosts</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">proxy</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">标签名</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">id</td><td style="text-align:center">代理ID，标识代理</td></tr><tr><td style="text-align:center">active</td><td style="text-align:center">设置代理是否启用</td></tr><tr><td style="text-align:center">protocol</td><td style="text-align:center">代理使用的协议</td></tr><tr><td style="text-align:center">username</td><td style="text-align:center">连接代理的用户名，如此代理不需要用户名，则可把此标签删掉</td></tr><tr><td style="text-align:center">password</td><td style="text-align:center">连接代理的密码，同上</td></tr><tr><td style="text-align:center">host</td><td style="text-align:center">代理的网址</td></tr><tr><td style="text-align:center">port</td><td style="text-align:center">代理使用的端口</td></tr></tbody></table><p>其中，<code>&lt;host&gt;</code>, <code>&lt;username&gt;</code>, <code>&lt;password&gt;</code>标签中改为自己的<code>IP地址</code>，<code>主机名</code>和<code>密码</code>即可</p><h3 id="配置Eclipse的Maven环境"><a href="#配置Eclipse的Maven环境" class="headerlink" title="配置Eclipse的Maven环境"></a>配置Eclipse的Maven环境</h3><p>对于一些低版本的或是功能不完整的Eclipse IDE，在做这一步之前，可能就需要手动去Eclipse安装Maven插件，主要有以下两种在线安装方式：</p><h4 id="方式一、在线安装"><a href="#方式一、在线安装" class="headerlink" title="方式一、在线安装"></a>方式一、在线安装</h4><p>这可以分为两种方式来下载安装<br>（1）、Install New Software</p><p>打开eclipse，点击<code>help–&gt;Install New Software</code>,然后输入要下载插件的链接地址：<code>http://m2eclipse.sonatype.org/sites/m2e</code>，如下图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/selenium/14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>勾选择要下载的项，点击下一步进行下载。下载完成会自动安装。安装速度跟你自身网速和服务器有关。</p><p>（2）、Eclipse Marketplace</p><p>打开eclipse，点击<code>help–&gt;Eclipse Marketplace</code>,然后输入<code>maven</code>回车搜索，选择以下勾选的插件”<code>Maven Integration for Eclipse (Luna)</code>“，点击<code>Install</code>安装<br>参考网站：<a href="http://marketplace.eclipse.org/content/maven-integration-eclipse-luna" target="_blank" rel="noopener">http://marketplace.eclipse.org/content/maven-integration-eclipse-luna</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/selenium/15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="方式二、离线安装"><a href="#方式二、离线安装" class="headerlink" title="方式二、离线安装"></a>方式二、离线安装</h4><p><a href="https://pan.baidu.com/s/1UXkFZloKFgmWQhSQL1Hnjg" target="_blank" rel="noopener">eclipse-maven3-plugin.zip</a>，提取密码：x5hq。</p><p>这也可以分为两种方式来下载安装</p><p>（1）、link方式（自定义方式）</p><ol><li>在你的 eclipse安装的根目录下创建两个文件夹：<code>links</code>，<code>mavenPlugins</code>（文件夹名称可自定义），把<code>eclipse-maven3-plugin.zip</code>解压后的<code>features</code>和<code>plugins</code>文件夹放到<code>mavenPlugins</code>文件夹下（必须如此，注意解压后文件夹的嵌套情况）。</li><li>在 <code>links</code>目录下创建一个<code>maven.link</code>（文件名称可自定义）文件，打开并输入：<code>path=mavenPlugins文件夹绝对路径</code>（需要注意文件夹路径中是”/“或者”\“  而不是”\” ）。</li><li>重启 eclipse后，再次打开<code>Window ---&gt; Preferences</code>会发现一个多了一个选项Maven，说明Maven插件安装成功了。</li></ol><p>（2）、直接粗暴的方式</p><p>将解压后的子文件夹<code>features</code>和<code>plugins</code>的<code>jar包文件</code>分别导入Eclipse安装目录下的<code>features</code>和<code>plugins</code>文件夹内，然后重启Eclipse就可以在<code>Preferences</code>中看到Maven选项了，即Maven插件配置成功。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/selenium/16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>保证Eclipse有了Maven插件后，那么就按照下面的步骤来 <strong>配置Maven</strong>:</p><ul><li>在<code>windows -&gt; preferences</code>中找到maven选项，下图</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/selenium/16-1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>找到<code>maven -&gt; installations</code>，选择<code>add按钮</code>，找到的maven的对应路径，如下</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/selenium/16-2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>eclipse中更新配置文件</li></ul><p>找到<code>User settings</code>，修改配置文件为之前已经修改好了的配置文件<code>settings.xml</code></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/selenium/16-3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>至此，Maven和eclipse的集成已经完成！</p><h3 id="下载浏览器对应的Driver"><a href="#下载浏览器对应的Driver" class="headerlink" title="下载浏览器对应的Driver"></a>下载浏览器对应的Driver</h3><p>这里需要说明的是，Driver对应<code>IE浏览器</code>、<code>Mozilla Firefox浏览器</code>、<code>Chrome Google浏览器</code>可分为3种</p><p>下面三个链接分别对应IE浏览器、Firefox浏览器、Google浏览器的driver下载：</p><p><a href="https://www.nuget.org/packages/Selenium.WebDriver.IEDriver/" target="_blank" rel="noopener">Selenium.WebDriver.IEDriver</a></p><p><a href="https://github.com/mozilla/geckodriver/releases/" target="_blank" rel="noopener">mozilla-geckodriver</a></p><p><a href="http://npm.taobao.org/mirrors/chromedriver" target="_blank" rel="noopener">chromedriver</a>、<a href="http://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">chromedriver2</a></p><p><strong>注意</strong>：为了避免浏览器与Driver版本上的不匹配，所以建议大家下载相应的最新版driver，并将浏览器更新至最新版，这样就可以避免出现不必要的错误。</p><p>下载好对应浏览器的Driver之后，将其解压放在浏览器安装目录下。比如，我用的是google浏览器，所以对应下载的是最高版本的<code>chromedriver.exe</code>，解压后放在对应Google浏览器的安装目录下，如下图所示</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/selenium/16-4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="Eclipse中新建Maven项目并安装selenium依赖"><a href="#Eclipse中新建Maven项目并安装selenium依赖" class="headerlink" title="Eclipse中新建Maven项目并安装selenium依赖"></a>Eclipse中新建Maven项目并安装selenium依赖</h3><ul><li>打开eclipse，点击<code>File –&gt; New -&gt; Project</code>,输入<code>Maven</code>搜索，选择<code>Maven Project</code></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/selenium/17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>一直点击Next（3次），填入相关名称信息，点击Finish完成。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/selenium/18.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>如果没有什么问题的话，侧边栏<code>Project Explorer</code>中会出现一个正常的文件夹（这里的正常意味着未爆红，并且有<code>Maven Dependencies</code>这样一个目录）</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/selenium/19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>打开新建Maven项目<code>xtu2018</code>下的<code>pom.xml</code>文件，搜索定位到<code>&lt;dependencies&gt;</code>标签处</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/selenium/20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>去<a href="http://mvnrepository.com/" target="_blank" rel="noopener">http://mvnrepository.com/</a><strong>maven公共库网站</strong>搜索<code>selenium</code>，选择第一项<code>Selenium Java</code>，点击进入，建议选择最新版本（也可以结合用户数参考）</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/selenium/21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/selenium/22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>比如我这里选择了<code>Selenium Java 3.13.0</code>，那么点击<code>3.13.0</code>进入后，复制页面下方Maven对应代码块，粘贴至<code>pom.xml</code>文件对应位置并保存修改。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/selenium/23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>pom.xml文件修改前：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>pom.xml文件修改后：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.seleniumhq.selenium/selenium-java --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.seleniumhq.selenium<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>selenium-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.13.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></p><ul><li>在对<code>pom.xml</code>修改后并保存，Maven项目文件下的<code>Maven Dependencies</code>文件目录下会多出很多这样的<code>*.jar</code>包，如果是第一次创建Maven项目，那么加入这些<code>*.jar</code>包的时间要求很长，需要耐心等待才能看到这样的变化，当然也不乏会出一些问题，当然，这都是后话…</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/selenium/24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>如果这些<code>*.jar</code>包加入正常，没出什么问题，也就意味着selenium依赖安装完成（其实这在上面截图中的<code>*.jar</code>包中可以找到），那么就可以很愉快地直接进入代码编写阶段了…</li></ul><h3 id="编写一个简易的测试脚本代码演示"><a href="#编写一个简易的测试脚本代码演示" class="headerlink" title="编写一个简易的测试脚本代码演示"></a>编写一个简易的测试脚本代码演示</h3><ul><li>移除掉<code>src/test/java</code>下的<code>com.xtu2018</code>包</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/selenium/25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>并在<code>src/test/java</code>下新建一个包package<code>com.xtu2018.one</code>，再在该包下新建一个类<code>demo01.java</code></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/selenium/26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>编写一段如下所示的Demo代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xtu2018.one;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.openqa.selenium.By;</span><br><span class="line"><span class="keyword">import</span> org.openqa.selenium.WebDriver;</span><br><span class="line"><span class="keyword">import</span> org.openqa.selenium.WebElement;</span><br><span class="line"><span class="keyword">import</span> org.openqa.selenium.chrome.ChromeDriver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="comment">//1、找到driver路径</span></span><br><span class="line">        System.setProperty(<span class="string">"webdriver.chrome.driver"</span>, <span class="string">"C:\\Program Files (x86)\\Google\\Chrome\\Application\\chromedriver.exe"</span>);</span><br><span class="line">        <span class="comment">//2、创建一个浏览器</span></span><br><span class="line">        WebDriver driver = (WebDriver) <span class="keyword">new</span> ChromeDriver();</span><br><span class="line">        <span class="comment">//3、打开URL</span></span><br><span class="line">        driver.get(<span class="string">"http://www.baidu.com"</span>);</span><br><span class="line">        <span class="comment">//4、浏览器窗口最大化</span></span><br><span class="line">        driver.manage().window().maximize();</span><br><span class="line">        <span class="comment">//5、在搜索框输入内容</span></span><br><span class="line">        driver.findElement(By.id(<span class="string">"kw"</span>)).sendKeys(<span class="string">"12306"</span>);</span><br><span class="line">        WebElement btn =driver.findElement(By.id(<span class="string">"su"</span>));</span><br><span class="line">        btn.click();</span><br><span class="line">        <span class="comment">//延时等待</span></span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="comment">//6、后退</span></span><br><span class="line">        driver.navigate().back();</span><br><span class="line">        <span class="comment">//7、前进</span></span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        driver.navigate().forward();</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        driver.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/selenium/27.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="软件测试" scheme="https://zhouie.cn/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="实习" scheme="https://zhouie.cn/tags/%E5%AE%9E%E4%B9%A0/"/>
    
      <category term="selenium" scheme="https://zhouie.cn/tags/selenium/"/>
    
      <category term="UI自动化" scheme="https://zhouie.cn/tags/UI%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>【分享】 屏幕截图与录屏工具</title>
    <link href="https://zhouie.cn/posts/201806252/"/>
    <id>https://zhouie.cn/posts/201806252/</id>
    <published>2018-06-25T17:33:21.000Z</published>
    <updated>2018-09-11T06:18:11.669Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p>有没有办法把多页的Word或PDF文档保存成一整张图片？</p></blockquote><p>思路一：<br>把Word存为网页格式，用浏览器打开，然后用浏览器插件截取整个网页。确实可以这样截屏，但是在Word转为网页后，很多格式和排版可能会发生改变，效果并不理想。</p><p>思路二：<br>用电脑上已有的ABBYY打开一个PDF文档，然后另存为图片格式。这样确实也可以，只不过每一页文档都被单独保存成了一张图片，而不是一整张大图。</p><hr><p>这里，主要介绍一款还不错的软件—— <code>FastStone Capture</code>, 它的“捕获滚动窗口”功能能够较好地满足上述需求</p><p>下载地址：<br><a href="https://pan.baidu.com/s/1umdpPUR95f48bOXhrBPDlQ" target="_blank" rel="noopener">百度云分享</a>（提取码：rq1t）</p><p>说明：<br>下载解压后，直接双击“FSCapture.exe”即可运行，也可以右键“发送到”+“桌面快捷方式”,方便使用；<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/jt&lp/1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>功能列表见下图<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/jt&lp/2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>下面主要谈谈这两个特殊一点的功能：<br>1、 滚动截屏<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/jt&lp/3.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>2、 视频录制：<br>尝试了一下，整体效果还是蛮不错的。</p><ul><li>录的视频还算很清晰，视频格式是<code>.WMV</code>；</li><li>支持鼠标高亮和点击声；</li><li>支持录制声音，同时录制麦克风和系统声音；</li><li>视频录制后，支持编辑，尽管仅限于更改尺寸。</li></ul><p>注意：<br>对word或pdf滚动截图，可能会出现下面这种不和谐的情况<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/jt&lp/4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这是因为，翻页效果太强烈，导致截图内容有折叠。<br>这个时候，大家可以去尝试将word或pdf文件导出为XPS文件，之后再滚动截图就不会出现这种不完美了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/jt&lp/5.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="分享" scheme="https://zhouie.cn/categories/%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Tool-share" scheme="https://zhouie.cn/tags/Tool-share/"/>
    
      <category term="截图" scheme="https://zhouie.cn/tags/%E6%88%AA%E5%9B%BE/"/>
    
      <category term="录屏" scheme="https://zhouie.cn/tags/%E5%BD%95%E5%B1%8F/"/>
    
  </entry>
  
  <entry>
    <title>【分享】 Gif相关工具</title>
    <link href="https://zhouie.cn/posts/201806251/"/>
    <id>https://zhouie.cn/posts/201806251/</id>
    <published>2018-06-25T15:25:39.000Z</published>
    <updated>2018-09-11T06:18:11.669Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="LICEcap"><a href="#LICEcap" class="headerlink" title="LICEcap"></a>LICEcap</h3><p>LICEcap 是一款屏幕录制工具，支持导出GIF动画图片格式，轻量级、使用简单，录制过程中可以随意改变录屏范围。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/gif/1.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>下载地址：<br><a href="https://www.cockos.com/licecap/" target="_blank" rel="noopener">官方地址</a><br><a href="https://pan.baidu.com/s/1xMk_J96GmJr_53lv1C2L-w" target="_blank" rel="noopener">百度云分享</a>（提取码：36ru）</p><p>说明：<br>运行后会以窗口的方式显示在桌面，拖动选取一个合适的大小范围，点击Record选取保存路径就开始录屏了。LICEcap在录屏过程中可以随时拖动窗口改变录屏范围，Stop过后即自动保存为GIF格式。</p><p>注意：</p><ul><li>录屏暂停时（pause）可以插入文本（Insert），但目前仅支持英文插入（中文无效）。</li><li>安装路径不可以有中文，否则无法保存。</li></ul><h3 id="GiFResizer"><a href="#GiFResizer" class="headerlink" title="GiFResizer"></a>GiFResizer</h3><p>大家可能都碰到这样一个难题：动态图片尺寸的调整。使用一般的图片处理工具，缩放后的动态图片可能就变成了静态图片。</p><p>下载地址：<br><a href="https://pan.baidu.com/s/1U10yeyk9HvX1i7xgjXxRLA" target="_blank" rel="noopener">百度云分享</a>（提取码：qpym）</p><p>说明：<br>GiF Resizer，它的界面非常简单干脆，既能调整GiF动画图片的尺寸，又能完美保留图片的动态效果。</p><p>注意：</p><ul><li>建议修改尺寸时，勾选“保持比例”，转换后显得更加自然。</li><li>想保留高画质的话，请勾选“高质量”（转换稍微会慢一点）。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="分享" scheme="https://zhouie.cn/categories/%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Tool-share" scheme="https://zhouie.cn/tags/Tool-share/"/>
    
      <category term="Gif" scheme="https://zhouie.cn/tags/Gif/"/>
    
      <category term="cockos" scheme="https://zhouie.cn/tags/cockos/"/>
    
  </entry>
  
  <entry>
    <title>【分享】 自定义属于自己的U盘图标</title>
    <link href="https://zhouie.cn/posts/201806191/"/>
    <id>https://zhouie.cn/posts/201806191/</id>
    <published>2018-06-19T18:27:49.000Z</published>
    <updated>2018-09-11T06:18:11.669Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>怎么样？想不想也可以自定义自己的U盘图标？其实，这并不难<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/uptb/1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>来来来，follow me…</p><p>① <a href="https://zhouie.cn/posts/201804291/#%E7%9F%A2%E9%87%8F%E5%9B%BE%E6%A0%87%E5%BA%93">在网上下载ICO格式的图标</a>，也可以将自己喜欢的图片转换成ICO格式，并将图片命名为<code>123.ico</code>；</p><p>② 点击这里打开记事本，复制以下两行代码，并另存为<code>autorun.inf</code>；<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[autorun]</span></span><br><span class="line"><span class="attr">ICON</span>=<span class="number">123</span>.ico,<span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>说明：以上代码中的<code>123.ico</code>，就是第①步中准备的ICO图标名，你也可以自定义命名，不过要保持上下文一致。</p><p>③ 将上面两步中准备的图标<code>123.ico</code>和文件<code>autorun.inf</code>复制到U盘<a href="https://baike.baidu.com/item/%E6%A0%B9%E7%9B%AE%E5%BD%95" target="_blank" rel="noopener">根目录</a>即可。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/uptb/2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>注意：</p><ul><li>为了避免不小心被改动或删除，大家可以将上面的两个文件的属性设置为“只读”和“隐藏”；</li><li>如果日后还需要修改图标的话，只需要替换U盘中的<code>123.ico</code>即可；</li><li>按照上面三步操作之后，U盘图标可能还是没有什么改变。其实，你只需要把U盘安全退出，再重新插上就可以显示了。万一还是不行，清理下电脑垃圾，并重启电脑，就一定会有图标的。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="分享" scheme="https://zhouie.cn/categories/%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Tool-share" scheme="https://zhouie.cn/tags/Tool-share/"/>
    
      <category term="U盘图标" scheme="https://zhouie.cn/tags/U%E7%9B%98%E5%9B%BE%E6%A0%87/"/>
    
  </entry>
  
  <entry>
    <title>【分享】 图片处理相关工具</title>
    <link href="https://zhouie.cn/posts/201806171/"/>
    <id>https://zhouie.cn/posts/201806171/</id>
    <published>2018-06-17T08:17:39.000Z</published>
    <updated>2018-09-11T06:18:11.669Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p>注：熟练使用PS的高手，请忽略本文。</p></blockquote><h3 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h3><p>1、 在线压缩<br>这里有这样一个网站提供这项服务：<a href="https://tinypng.com/" target="_blank" rel="noopener">https://tinypng.com/</a><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/picAbout/1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>说明：<br>支持图片格式<code>.png</code>和<code>.jpg</code>；<br>单张图片大小不得超过5M；<br>图片总数不能超过20个；<br>不支持修改图片尺寸。</p><p>2、 本地压缩软件</p><p>这里主要分享这款软件—— <code>Caesium</code>图片压缩软件</p><p>下载地址：<br><a href="https://pan.baidu.com/s/1JT8eSV3vW1jkz5SLFA3FYA" target="_blank" rel="noopener">百度云分享</a>（提取码：t7ez）</p><p>说明：<br>支持图片格式<code>.png</code>、<code>.jpg</code> 和<code>.bmp</code>；<br>支持批量处理，文件总数和大小无限制；<br>可修改图片尺寸。</p><p>软件的使用并不难，就不多说了，主要提醒注意一点：<br>一定要注意在点击“压缩”之前，确认选择好“输出文件夹”，要和原图片位置不一样，不然的话，会覆盖原图！！！</p><p>下图是压缩后的情况：（原图16.2Mb，压缩后为289Kb）<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/picAbout/2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="图片添加水波纹倒影"><a href="#图片添加水波纹倒影" class="headerlink" title="图片添加水波纹倒影"></a>图片添加水波纹倒影</h3><p>给图片添加水波纹倒影，效果如下图：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/picAbout/3.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>还可以自定义波纹类型、波纹速度，以及倒影高度哦！</p><p>下载地址：<br><a href="https://pan.baidu.com/s/1T6NvgbledolckA6lXgZYPg" target="_blank" rel="noopener">百度云分享</a>（提取码：st2f）</p><h3 id="改图宝"><a href="#改图宝" class="headerlink" title="改图宝"></a>改图宝</h3><p>最快速、最简单的在线修改图片工具。</p><p>改图宝要可以对各种数码照片、图片进行修改大小、压缩文件大小和局部剪切的操作，目前主要提供了修改大小和更改尺寸的两种服务。</p><ul><li>修改大小可以把你的图片大改为800像素以内的任意大小。</li><li>同样，更改尺寸也是可以任意设定不超过图片范围的尺寸，特别提供了1寸、两寸、正方形网络头像和公务员考试报名等一些常见尺寸的快捷方式供大家使用；</li><li>除在线改图外，改图宝也提供了生成印章、二维码、条码、文字识别、文档转换等服务。<br>除了免费的在线自助改图外，也提供付费的专业在线改图网站以及人工改图等附加服务。</li></ul><p>官方网址：<br><a href="http://www.gaitubao.com/" target="_blank" rel="noopener">http://www.gaitubao.com/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="分享" scheme="https://zhouie.cn/categories/%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Tool-share" scheme="https://zhouie.cn/tags/Tool-share/"/>
    
      <category term="图片处理" scheme="https://zhouie.cn/tags/%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>【复习】 人工智能入门复习总结</title>
    <link href="https://zhouie.cn/posts/201806111/"/>
    <id>https://zhouie.cn/posts/201806111/</id>
    <published>2018-06-11T13:03:51.000Z</published>
    <updated>2018-09-11T06:18:11.669Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p>写在前面</p></blockquote><ul><li>本文严禁转载，只限于学习<a href="mailto:nanzhouie@gmail.com" target="_blank" rel="noopener">交流</a>。</li><li>课件分享在<a href="https://download.csdn.net/download/jave_f/10470736" target="_blank" rel="noopener">这里</a>了。</li><li>还有<a href="https://download.csdn.net/download/jave_f/10464580" target="_blank" rel="noopener">人工智能标准化白皮书(2018版)</a>也一并分享了。</li></ul><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><h3 id="人工智能的定义与发展"><a href="#人工智能的定义与发展" class="headerlink" title="人工智能的定义与发展"></a>人工智能的定义与发展</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ol><li><em>一般解释</em>：人工智能就是用 <strong>人工</strong>的方法在 <strong>机器（计算机）</strong>上实现的智能，或称 <strong>机器智能</strong>；</li><li><em>人工智能(学科)</em>：从学科的角度来说，人工智能是一门研究如何 <strong>构造智能机器或智能系统</strong>，使之能模拟、延伸、扩展人类智能的学科；</li><li><em>人工智能(能力)</em>：从智能能力的角度来说，人工智能是智能机器所执行的通常 <strong>与人类智能有关的智能行为</strong>，如判断、推理、证明、识别、感知、理解、通信、设计、思考、规划、学习和问题求解等思维活动。 </li></ol><p>【<strong>补充</strong>】 2018年1月发布的<a href="https://download.csdn.net/download/jave_f/10464580" target="_blank" rel="noopener">人工智能标准化白皮书</a>上关于“人工智能的概念”有如下一段详尽描述（仅供参考）：</p><blockquote><p>2.1.2 人工智能的概念</p><p>人工智能作为一门前沿交叉学科，其定义一直存有不同的观点：<strong>《人工智能——一种现代方法》</strong>中将已有的一些人工智能定义分为四类：像人一样思考的系统、像人一样行动的系统、理性地思考的系统、理性地行动的系统。<strong>维基百科</strong>上定义“人工智能就是机器展现出的智能”，即只要是某种机器，具有某种或某些“智能”的特征或表现，都应该算作“人工智能”。<strong>大英百科全书</strong>则限定人工智能是数字计算机或者数字计算机控制的机器人在执行智能生物体才有的一些任务上的能力。<strong>百度百科</strong>定义人工智能是“研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门新的技术科学”，将其视为计算机科学的一个分支，指出其研究包括机器人、语言识别、图像识别、自然语言处理和专家系统等。</p><p>本白皮书认为，<strong>人工智能是利用数字计算机或者数字计算机控制的机器模拟、延伸和扩展人的智能，感知环境、获取知识并使用知识获得最佳结果的理论、方法、技术及应用系统。</strong></p><p>人工智能的定义对人工智能学科的基本思想和内容作出了解释，即围绕智能活动而构造的人工系统。人工智能是知识的工程，是机器模仿人类利用知识完成一定行为的过程。根据人工智能是否能真正实现推理、思考和解决问题，可以将人工智能分为弱人工智能和强人工智能。</p><p><strong>弱人工智能</strong>是指不能真正实现推理和解决问题的智能机器，这些机器表面看像是智能的，但是并不真正拥有智能，也不会有自主意识。迄今为止的人工智能系统都还是实现特定功能的专用智能，而不是像人类智能那样能够不断适应复杂的新环境并不断涌现出新的功能，因此都还是弱人工智能。目前的主流研究仍然集中于弱人工智能，并取得了显著进步，如语音识别、图像处理和物体分割、机器翻译等方面取得了重大突破，甚至可以接近或超越人类水平。</p><p><strong>强人工智能</strong>是指真正能思维的智能机器，并且认为这样的机器是有知觉的和自我意识的，这类机器可分为类人（机器的思考和推理类似人的思维）与非类人（机器产生了和人完全不一样的知觉和意识，使用和人完全不一样的推理方式）两大类。从一般意义来说，达到人类水平的、能够自适应地应对外界环境挑战的、具有自我意识的人工智能称为“通用人工智能”、“强人工智能”或“类人智能”。强人工智能不仅在哲学上存在巨大争论（涉及到思维与意识等根本问题的讨论），在技术上的研究也具有极大的挑战性。强人工智能当前鲜有进展，美国私营部门的专家及国家科技委员会比较支持的观点是，至少在未来几十年内难以实现。</p><p>靠符号主义、连接主义、行为主义和统计主义这四个流派的经典路线就能设计制造出强人工智能吗？其中一个主流看法是：即使有更高性能的计算平台和更大规模的大数据助力，也还只是量变，不是质变，人类对自身智能的认识还处在初级阶段，在人类真正理解智能机理之前，不可能制造出强人工智能。理解大脑产生智能的机理是脑科学的终极性问题，绝大多数脑科学专家都认为这是一个数百年乃至数千年甚至永远都解决不了的问题。</p><p>通向强人工智能还有一条“新”路线，这里称为“仿真主义”。这条新路线通过制造先进的大脑探测工具从结构上解析大脑，再利用工程技术手段构造出模仿大脑神经网络基元及结构的仿脑装置，最后通过环境刺激和交互训练仿真大脑实现类人智能，简言之，“先结构，后功能”。虽然这项工程也十分困难，但都是有可能在数十年内解决的工程技术问题，而不像“理解大脑”这个科学问题那样遥不可及。</p><p>仿真主义可以说是符号主义、连接主义、行为主义和统计主义之后的第五个流派，和前四个流派有着千丝万缕的联系，也是前四个流派通向强人工智能的关键一环。经典计算机是数理逻辑的开关电路实现，采用冯•诺依曼体系结构，可以作为逻辑推理等专用智能的实现载体。但要靠经典计算机不可能实现强人工智能。要按仿真主义的路线“仿脑”，就必须设计制造全新的软硬件系统，这就是“类脑计算机”，或者更准确地称为“仿脑机”。“仿脑机”是“仿真工程”的标志性成果，也是“仿脑工程”通向强人工智能之路的重要里程碑。</p></blockquote><h4 id="起源与发展"><a href="#起源与发展" class="headerlink" title="起源与发展"></a>起源与发展</h4><p>人工智能始于20世纪50年代，50多年来，人工智能走过了一条起伏和曲折的发展道路。回顾历史，可以按照不同时期的主要特征，将其产生与发展过程分为5个阶段。</p><p>1、孕育期（1956年前）</p><p>2、形成期（1956-1970年）</p><p>1956年夏，麦卡锡 (J.McCarthy，数学家、计算机专家)、明斯基(M.L.Minsky，哈佛大学数学家、神经学家)、洛切斯特(N.Lochester，IBM公司信息中心负责人)、香农(C.E.Shannon，贝尔实验室信息部数学家和信息学家)<br>邀请莫尔(T.more)、塞缪尔(A.L.Samuel) 、塞尔夫里奇(O.Selfridge)、索罗蒙夫(R.Solomonff)、纽厄尔(A.Newell)、西蒙(H.A.Simon)在 <strong>美国达特茅斯(Dartmouth)大学</strong>举办了长达历时两个月的研讨会。会上，麦卡锡正式使用“<strong>人工智能AI</strong>”这一术语。这是人类历史上首次第一次人工智能研讨会，<strong>标志着人工智能学科的诞生</strong>。</p><p>3、暗淡期（1966-1974年）</p><p><strong>失败的预言</strong>给人工智能的声誉造成重大伤害<br>60年代初，西蒙预言：10年内计算机将成为世界冠军、将证明一个未发现的数学定理、将能谱写出具有优秀作曲家水平的乐曲、大多数心理学理论将在计算机上形成。</p><p><strong>挫折和困境</strong></p><ul><li>在博弈方面：塞缪尔的下棋程序在与世界冠军对弈时，5局败了4局。</li><li>在定理证明方面：发现鲁宾逊归结法的能力有限。当用归结原理证明两个连续函数之和还是连续函数时，推了10万步也没证出结果。</li><li>在问题求解方面：对于不良结构，会产生 <strong>组合爆炸</strong>问题。</li><li>在机器翻译方面：发现并不那么简单，甚至会闹出笑话。例如，把“心有余而力不足”的英语句子翻译成俄语，再翻译回来时竟变成了“酒是好的，肉变质了”</li><li>在神经生理学方面：研究发现人脑有1011-12以上的神经元，在现有技术条件下用机器从结构上模拟人脑是根本不可能的。</li><li>在其它方面：人工智能也遇到了不少问题。在英国，剑桥大学的詹姆教授指责“人工智能研究不是骗局，也是庸人自扰” 。从此，形势急转直下，在全世界范围内人工智能研究陷入困境、落入低谷。 </li></ul><p><strong>Minsky的批评</strong><br>1969年 M. Minsky 和 S.Papert 在《感知机》一书中指出了感知机无法解决异或（XOR）问题的缺陷，并表示出对这方面研究的悲观态度，使得神经网络的研究从兴起期进入了停滞期。<br>该批评对人工智能的发展造成了重要的影响</p><ul><li>在以后的二十年，感知机的研究方向被忽视</li><li>基于符号的知识表示成为主流</li><li>基于逻辑的推理成为主要研究方向</li></ul><p><strong>当时的人工智能存在三个方面的局限性</strong></p><ul><li>知识局限性：早期开发的人工智能程序中包含了太少的主题知识，甚至没有知识，而且只采用简单的句法处理。</li><li>解法局限性：求解方法和步骤的局限性使得设计的人工智能程序在实际上无法求得问题的解答，或者只能得到简单问题的解答，而这种简单问题并不需要人工智能的参与。</li><li>结构局限性：用于产生智能行为的人工智能系统或程序在一些基本结构上严重局限，如没有考虑不良结构，无法处理组合爆炸问题，因而只能用于解决比较简单的问题，影响到人工智能系统的推广应用。</li></ul><p>4、知识应用期（ 1970-1988年）</p><p>5、集成发展期（1986年至今）</p><p>人工智能具体的发展历程图示如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/AI_history.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>这两年人工智能得到了突飞猛进的发展，实现这种发展的基本条件有三个：</p><ul><li><strong>大数据的积累</strong></li><li><strong>计算能力的提升</strong></li><li><strong>理论算法的革新</strong></li></ul><h3 id="各种认知观"><a href="#各种认知观" class="headerlink" title="各种认知观"></a>各种认知观</h3><h4 id="目前人工智能主要有以下三个学派："><a href="#目前人工智能主要有以下三个学派：" class="headerlink" title="目前人工智能主要有以下三个学派："></a>目前人工智能主要有以下三个学派：</h4><ul><li><strong>符号主义</strong>（Symbolicism）: 基于物理符号系统假设和有限合理性原理（逻辑）</li></ul><p>符号主义观点认为：<strong>智能的基础是知识</strong>，其核心是知识表示和知识推理；知识可用符号表示，也可用符号进行推理，因而可以建立基于知识的人类智能和机器智能的统一的理论体系。</p><ul><li><strong>连接主义</strong>（Connectionism）: 基于神经网络及其间的连接机制与学习算法（仿生）</li></ul><p>连接主义观点认为：<strong>思维的基元是神经元</strong>，而不是符号；思维过程是神经元的联结活动过程，而不是符号运算过程；反对符号主义关于物理符号系统的假设。</p><ul><li><strong>行为主义</strong>（Actionism）: 基于控制论及感知—动作型控制系统（进化）</li></ul><p>行为主义观点认为：<strong>智能取决于感知和行动</strong>，提出了智能行为的“感知—动作”模型；<strong>智能不需要知识、不需要表示、不需要推理</strong>；人工智能可以像人类智能那样逐步进化。</p><p>此外，还有一种由<a href="https://baike.baidu.com/item/%E9%92%9F%E4%B9%89%E4%BF%A1/7371623?fr=aladdin" target="_blank" rel="noopener">钟义信</a>院士提出的一种认知学派：</p><ul><li><strong>机制主义</strong>（mechanism）：结构（连接）主义、功能（符号）主义、行为主义的和谐统一。</li></ul><h4 id="几种学派各自不足之处："><a href="#几种学派各自不足之处：" class="headerlink" title="几种学派各自不足之处："></a>几种学派各自不足之处：</h4><ul><li><p><strong>符号主义的不足</strong>(功能模拟法/认知学观点)</p><ul><li>在用符号表示知识的概念时，有效性很大程度上取决于符号表示的正确性和准确性</li><li>将知识概念转换成符号时，可能丢失一些重要信息</li><li>难于对含噪信息、不确定性信息和不完全性信息进行处理</li></ul></li><li><p><strong>连接主义的不足</strong>(结构模拟法/生物学观点)</p><ul><li>由于大脑的生理结构和工作机理还远未搞清楚，因而现在只能对人脑的局部进行模拟或进行近似模拟</li><li>不适合模拟人的逻辑思维过程</li><li>受大规模人工神经网络制造的制约</li><li>尚不能满足人脑完全模拟的要求</li></ul></li><li><p><strong>行为主义的不足</strong></p><ul><li>难以获得高级智能控制行为</li></ul></li></ul><h3 id="研究目标与内容"><a href="#研究目标与内容" class="headerlink" title="研究目标与内容"></a>研究目标与内容</h3><h4 id="研究目标"><a href="#研究目标" class="headerlink" title="研究目标"></a>研究目标</h4><p>远期目标：构造出可以实现人类思维活动和智力功能的智能系统。<br>近期目标：使现有的计算机更聪明更有用，使它不仅能够进行一般的数值计算和非数值信息的处理，而且能够运用知识去处理问题，能够模拟人类的智能行为。</p><h4 id="研究的基本内容"><a href="#研究的基本内容" class="headerlink" title="研究的基本内容"></a>研究的基本内容</h4><p>1、认知建模<br>认知：可一般地认为是和情感、动机、意志相对应的理智或认识过程，或者是为了一定的目的，在一定的心理结构中进行的信息加工过程。</p><p>2、知识表示：基础</p><p>3、知识推理：实现问题求解</p><p>4、知识应用：目的</p><blockquote><p>知识表示、知识推理、知识应用是传统人工智能的三大核心研究内容。</p></blockquote><p>5、<strong>机器感知</strong>：就是要让计算机具有类似于人的感知能力，如视觉、听觉、触觉、嗅觉、味觉……，是机器获取外部信息的基本途径</p><ul><li>相当于智能系统的输入部分</li><li>机器视觉（或叫计算机视觉）：就是给计算机配上能看的视觉器官，如摄像机等，使它可以识别并理解文字、图像、景物等</li><li>机器听觉（或叫计算机听觉）：就是给计算配上能听的听觉器官，如话筒等，使计算机能够识别并理解语言、声音等。</li><li>模式识别：对客体的识别与分类</li><li>自然语言理解：实现人机对话</li><li>机器翻译</li></ul><p>6、<strong>机器思维</strong>：<br>机器思维是让计算机能够对感知到的外界信息和自己产生的内部信息进行思维性加工，包括逻辑思维、形象思维和灵感思维，涉及信息的表示，组织，积累，管理，搜索，推理等过程。</p><p>7、<strong>机器学习</strong>：</p><ul><li>让计算机能够像人那样自动地获取新知识，并在实践中不断地完善自我和增强能力。</li><li>是机器获取智能的途径</li><li>学习是一个有特定目的的知识获取过程，学习的本质是对信息的理解与应用</li></ul><p>8、<strong>机器行为</strong>：</p><ul><li>让计算机能够具有像人那样地行动和表达能力，如走、跑、拿、说、唱、写画等。</li><li>相当于智能系统的输出部分</li></ul><p>9、<strong>智能系统构建</strong></p><ul><li>无论是人工智能的近期目标还是远期目标，都需要建立智能系统或构造智能机器</li><li>需要开展对系统模型、构造技术、构造工具及语言环境等研究</li></ul><h3 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h3><p>问题求解、机器学习、自然语言理解、专家系统、模式识别、计算机视觉、机器人学、博弈、计算智能、人工生命、自动定理证明、自动程序设计、智能控制、智能检索、智能调度与指挥、智能决策支持系统、人工神经网络、数据挖掘与知识发现……</p><h3 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h3><p>1-1 什么是人工智能？是从科学与能力两方面加以说明。<br>1-3 在人工智能的发展过程中，有哪些思想和思潮起到了重要作用？<br>1-5 人工智能有哪些学派？他们的认知观是什么？现在这些学派的关系如何？<br>1-9 人工智能的基本研究方法有哪些类？<br>1-10 人工智能的主要研究和应用领域是什么？其中，哪些是新的研究热点？</p><h2 id="知识表示与推理"><a href="#知识表示与推理" class="headerlink" title="知识表示与推理"></a>知识表示与推理</h2><h3 id="知识表示方法"><a href="#知识表示方法" class="headerlink" title="知识表示方法"></a>知识表示方法</h3><blockquote><p>知识的一般概念</p></blockquote><p>知识是人们在改造客观世界的实践中积累起来的 <strong>认识</strong>和 <strong>经验</strong>。<br>其中，<strong>认识</strong>与 <strong>经验</strong>可以这样定义：</p><ul><li>认识：包括对事物现象、本质、属性、状态、联系等的认识</li><li>经验：包括解决问题的微观方法和宏观方法<ul><li>微观方法：如步骤、操作、规则、过程、技巧等</li><li>宏观方法：如战略、战术、计谋、策略等</li></ul></li></ul><blockquote><p>人工智能系统中的知识</p></blockquote><p>一个智能程序高水平的运行需要有关的 <strong>事实知识</strong>、 <strong>规则知识</strong>、 <strong>控制知识</strong>和 <strong>元知识</strong>。</p><ul><li>事实知识 ：是有关问题环境的一些事物的知识，常以“…是…”的形式出现。<ul><li>如事物的分类、属性、事物间关系、科学事实、客观事实等。</li><li>事实是静态的为人们共享的可公开获得的公认的知识，在知识库中属低层的知识，如：雪是白色的、鸟有翅膀、张三李四是好朋友、这辆车是张三的……</li></ul></li><li>规则知识 ：是有关问题中与事物的行动、动作相联系的因果关系知识，是动态的，常以“如果…那么…” 形式出现。</li><li>控制知识 ：是有关问题的求解步骤、技巧的知识，告诉人们怎么做一件事，也包括当有多个动作同时被激活时应选哪一个动作来执行的知识。控制知识常与程序结合在一起出现，如一个问题求解的算法可以看做是一种知识表示。</li><li>元知识 ：是有关知识的知识，是知识库中的高层知识。包括怎样使用规则、解释规则、校验规则、解释程序结构等知识。</li></ul><p>元知识与控制知识是有重迭的，对一个大的程序来说，以元知识或说元规则形式体现控制知识更为方便，因为元知识存于知识库中，而控制知识常与程序结合在一起出现，从而不容易修改。 </p><blockquote><p>知识表示</p></blockquote><p>研究用机器表示知识的可行性、有效性的一般方法，是一种数据结构与控制结构的统一体，既考虑知识的存储又考虑知识的使用。</p><p>知识表示的要求：</p><ul><li>表示能力：能否正确、有效地表示问题。包括：表范围的广泛性、领域知识表示的高效性、对非确定性知识表示的支持程度；</li><li>可利用性：可利用这些知识进行有效推理。包括：对推理的适应性，对高效算法的支持程度；</li><li>可实现性：要便于计算机直接对其进行处理；</li><li>可组织性：可以按某种方式把知识组织成某种知识结构；</li><li>可维护性：便于对知识的增、删、改等操作；</li><li>自然性：符合人们的日常习惯；</li><li>可理解性：知识应易读、易懂、易获取等。</li></ul><h4 id="状态空间法"><a href="#状态空间法" class="headerlink" title="状态空间法"></a>状态空间法</h4><p>状态空间法是一种 <strong>基于解答空间的问题表示和求解方法</strong>，它是以“<strong>状态</strong>（state）”和“<strong>算符</strong>（operator）”为基础的，它是人工智能中最基本的 <strong>形式化方法</strong>。<br>由于状态空间法需要扩展过多的节点，容易出现“<strong>组合爆炸</strong>”，因而 <strong>只适用于表示比较简单的问题</strong>。</p><blockquote><p>状态空间法的三要素： </p></blockquote><ol><li><strong>状态</strong>（state）：描述某类不同事物间的差别而引入的一组最少变量 <code>q0，q1，…，qn</code>的有序集合，是表示问题解法中每一步问题状况的数据结构。有序集合中每个元素qi（i= 0,1,…,n）为集合的分量，称为状态变量。给定每个分量的一组值就得到一个具体的状态。</li><li><strong>算符</strong>（operator）：使问题从一种状态变化为另一种状态的手段称为操作符或算符。</li><li><strong>问题的状态空间**</strong>：即解答空间，也就是一个表示该问题全部可能状态及其关系的图。它是以状态和算符为基础来表示和求解问题的。它包含三种说明的集合，即S：所有可能的问题初始状态集合、F：操作符集合、G：目标状态集合。可将状态空间记为三元状态<code>（S，F，G）</code>。</li></ol><hr><p>【例子】<br><strong>猴子和香蕉问题</strong>：在一个房间内有一只猴子、一个箱子和一束香蕉。香蕉挂在天花板下方，但猴子的高度不足以碰到它。那么这只猴子怎样才能摘到香蕉呢?<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E7%8C%B4%E5%AD%90%E6%91%98%E9%A6%99%E8%95%89.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p><strong>解题过程</strong><br>用一个四元表列<code>(W，x，Y，z)</code>来表示这个问题状态空间<br>其中W：猴子的水平位置；x：当猴子在箱子顶上时取1；否则取0；Y：箱子的水平位置；z：当猴子摘到香蕉时取1；否则取0。<br>则可见初始状态为<code>(a,0,b,0)</code>，目标状态为<code>(c,1,c,1)</code> </p><p>这个问题的算符如下：<br><code>goto(U)</code>表示猴子走到水平位置U；<code>pushbox(V)</code>表示猴子把箱子推到水平位置V；<code>climbbox</code>表示猴子爬上箱顶；<code>grasp</code>表示猴子摘到香蕉。</p><p>由初始状态变换为目标状态的操作序列为：<br>    Step1: <code>goto(b)</code><br>    Step2: <code>pushbox(c)</code><br>    Step3: <code>climbbox</code><br>    Step4: <code>grasp</code><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E7%8A%B6%E6%80%81%E7%A9%BA%E9%97%B4%E6%B3%95.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><hr><h4 id="问题归约法"><a href="#问题归约法" class="headerlink" title="问题归约法"></a>问题归约法</h4><blockquote><p>问题规约（Problem Reduction）：</p></blockquote><ul><li>另外一种 <strong>基于状态空间</strong>的问题描述与求解方法；</li><li>已知问题的描述，通过一系列 <strong>变换</strong> 把此问题变为一个 <strong>子问题集合</strong>；</li><li>这些子问题的解可以直接得到（<strong>本原问题</strong>），从而解决了初始问题。</li></ul><blockquote><p>问题归约的组成部分：</p></blockquote><ul><li>一个初始问题描述；</li><li>一套把问题变换为子问题的 <strong>操作符</strong>；</li><li>一套本原问题描述。(本原问题:不能再分解或变换且直接可解的子问题)。</li></ul><blockquote><p>问题归约的 <strong>实质</strong>：</p></blockquote><ul><li>从目标（要解决的问题）出发 <strong>逆向推理</strong>，建立子问题以及子问题的子问题，直到 <strong>最后把初始问题归约为一个本原问题集合</strong>。</li></ul><blockquote><p>问题归约法举例：</p></blockquote><hr><p>【例子】<br><strong>汉诺塔问题</strong>(Hanoi):规定每次移动一个盘子、且总个过程中大盘在下小盘在上、目标是将盘子从柱子1移到柱子3。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/Hanoi.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p><strong>解题过程</strong></p><p>原始问题可以归约为下列3个子问题：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E9%97%AE%E9%A2%98%E8%A7%84%E7%BA%A6%E6%B3%95.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>规约过程：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E8%A7%84%E7%BA%A6%E8%BF%87%E7%A8%8B.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>归约图示：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E8%A7%84%E7%BA%A6%E5%9B%BE.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><hr><blockquote><p>与或图表示</p></blockquote><p>用一个类似于图的结构来表示,把问题归约为后继问题的替换集合。</p><ul><li><p>与图：把一个复杂问题分解为若干个较为简单的子问题，形成“与”树。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E4%B8%8E%E5%9B%BE.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li><li><p>或图：把原问题变换为若干个较为容易求解的新问题，形成“或”树。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%88%96%E5%9B%BE.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ul><h4 id="谓词逻辑法"><a href="#谓词逻辑法" class="headerlink" title="谓词逻辑法"></a>谓词逻辑法</h4><p>谓词逻辑法采用谓词合式公式和一阶谓词演算将要解决的问题变成一个有待证明的问题，然后利用消解定理和消解反演来证明一个新语句是从已知的正确语句中导出的，从而证明这个新语句也是正确的。<br>谓词逻辑是一种 <strong>形式语言</strong>，能够将数学中的逻辑论证符号化，谓词逻辑经常与其他表示方法混合使用，<strong>可以表示比较复杂的问题</strong>。</p><h5 id="谓词演算"><a href="#谓词演算" class="headerlink" title="谓词演算"></a>谓词演算</h5><blockquote><p>语法和语义</p></blockquote><ul><li>基本符号：谓词符号、变量符号、函数符号、常量符号、括号和逗号</li><li>原子公式由若干谓词符号和项组成</li></ul><blockquote><p>连词和量词</p></blockquote><ul><li><p>连词<br>合取、析取、蕴涵、非、双条件</p></li><li><p>量词<br>全称量词、存在量词</p></li></ul><blockquote><p>谓词公式</p></blockquote><ul><li><p>原子谓词公式<br>由谓词符号和若干项组成的谓词演算</p></li><li><p>分子谓词公式<br>可以用 <strong>连词</strong>把原子谓词公式组成复合谓词公式，并把它叫做分子谓词公式<br>通常把合式公式叫做谓词公式。在谓词演算中合式公式的递归定义如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E5%90%88%E5%BC%8F%E5%85%AC%E5%BC%8F.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ul><blockquote><p>合式公式的性质</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%80%A7%E8%B4%A8.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h5 id="置换与合一"><a href="#置换与合一" class="headerlink" title="置换与合一"></a>置换与合一</h5><blockquote><p>置换</p></blockquote><p>置换是用变元、常量、函数来替换变元，使该变元不在公式中出现，形如<code>{t1/x1, t2/x2,...，tn/xn}</code>的有限集合，其中：</p><ul><li><code>t1，t2，...，tn</code>是项；</li><li><code>x1，x2，...，xn</code>是互不相同的变元；</li><li><code>ti/xi</code>表示用ti项替换变元<code>xi</code>，不允许<code>ti</code>和<code>xi</code>相同，也不允许变元<code>xi</code>循环地出现在另一个tj中。</li></ul><p>推理规则：用合式公式的集合产生新的合式公式<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%8E%A8%E7%90%86%E8%A7%84%E5%88%99.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>置换是 <strong>可结合的</strong>；<br>用<code>s1s2</code>表示两个置换s1和s2的合成，L表示一个表达式，则有<code>(Ls1)s2 = L(s1s2)</code>以及<code>(s1s2)s3 = s1(s2s3)</code>，即用s1和s2相继作用于表达式L是与用<code>s1s2</code>作用于L一样的。<br>一般说来，置换是 <strong>不可交换的</strong>，即<code>s1s2 ≠ s2s1</code>。</p><blockquote><p>合一</p></blockquote><p>寻找项对变量的置换，以使两表达式一致，叫做合一。<br>如果一个置换s作用于表达式集合<code>{Ei}</code>的每个元素，则用<code>{Ei}s</code>来表示置换的集。称表达式{Ei}是可合一的，如果存在一个置换s使得：<code>E1s = E2s =  E3s =……</code>，那么，称此s为<code>{Ei}</code>的合一者，因为s的作用是使集合<code>{Ei}</code>成为单一形式。<br>例如：设有公式集<code>E={ P( x, y, f(y)),  P( a, g(x), z) }</code>，则<code>s={a/x, g(a)/y, f(g(a))/z}</code>是它的一个合一。</p><h4 id="语义网路法"><a href="#语义网路法" class="headerlink" title="语义网路法"></a>语义网路法</h4><p>语义网络是通过概念及其语义关系来表达知识一种网络图，是一种 <strong>结构化表示方法</strong>。<br>从图论的观点看，语义网络是一个“带标识的有向图”，它由 <strong>节点</strong>和 <strong>弧线或链线</strong>组成。<strong>节点代表实体、概念、情况等</strong>，<strong>弧线代表节点间的关系</strong>，必须带标识。<br>语义网络的解答是一个经过推理和匹配而得到的具有明确结果的新的语义网路，扩展后可以表示更复杂的问题。</p><p>语义网络中最基本的语义单元称为语义基元，可用三元组表示为：(结点1，弧，结点2)。</p><blockquote><p>二元语义网络的表示</p></blockquote><p>例如：用语义网络表示：李新的汽车的款式是“捷达”、银灰色；王红的汽车的款式是“凯越”、红色；李新和王红的汽车均属于具体概念,可增加“汽车” 这个抽象概念。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E8%AF%AD%E4%B9%89%E7%BD%91%E7%BB%9C.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><blockquote><p>多元语义网络的表示</p></blockquote><ul><li>增加情况和动作节点；</li><li>增加事件节点；</li><li>连接词和量词的表示；</li><li>……</li></ul><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><ul><li>框架表示法<br>这是一种 <strong>结构化方法</strong>；<br>框架理论是明斯基于1975年作为理解视觉、自然语言对话及其它复杂行为的一种基础提出来的；<br>框架理论认为，人们对现实世界中各种事物的认识都是以一种类似于框架的结构存储在记忆中的。当遇到一个新事物时，就从记忆中找出一个合适的框架，并根据新的情况对其细节加以修改、补充，从而形成对这个新事物的认识。</li></ul><p>框架网络：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%A1%86%E6%9E%B6%E7%BD%91%E7%BB%9C.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>框架结构：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%A1%86%E6%9E%B6%E7%BB%93%E6%9E%84.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><ul><li>每个框架都有框架名，代表某一类对象</li><li>一个框架由若干个槽（项目）组成，用于表示对象的某个方面的属性</li><li><p>有时一个槽（属性）还要从不同的侧面来描述，每个侧面可具有一个或多个值。<br>注意：框架中的槽与侧面可任意定义，也可以是另一框架，形成框架网络系统。</p></li><li><p>剧本表示法(ppt-6)</p></li><li>过程表示法(ppt-6)</li><li>……</li></ul><h3 id="确定性推理"><a href="#确定性推理" class="headerlink" title="确定性推理"></a>确定性推理</h3><h4 id="推理的基本概念"><a href="#推理的基本概念" class="headerlink" title="推理的基本概念"></a>推理的基本概念</h4><blockquote><p>推理方法及其分类</p></blockquote><ol><li>按推理的逻辑基础分：演绎推理，归纳推理，类比归纳推理</li><li>按推理过程所用知识的确定性分：确定性推理、 不确定性推理</li><li>按推理过程推出的结论是否单调增加分：单调推理、非单调推理</li><li>按推理过程是否利用问题的启发性知识分：启发式推理、非启发式推理</li></ol><blockquote><p>推理的控制策略及其分类</p></blockquote><p>推理的控制策略是指如何使用领域知识使推理过程尽快达到目标的策略。</p><ul><li>推理策略<ul><li><strong>推理方向控制策略</strong>可分为<ul><li>正向推理</li><li>逆向推理</li><li>混合推理</li><li>双向推理</li></ul></li><li><strong>求解策略</strong>：是指仅求一个解，还是求所有解或最优解等。</li><li><strong>限制策略</strong>：是指对推理的深度、宽度、时间、空间等进行的限制。</li><li><strong>冲突消解策略</strong>：是指当推理过程有多条知识可用时，如何从这多条可用知识中选出一条最佳知识用于推理的策略。</li></ul></li><li>搜索策略（下面会详述）</li></ul><h4 id="搜索策略"><a href="#搜索策略" class="headerlink" title="搜索策略"></a>搜索策略</h4><ul><li>按是否使用启发式信息：<ul><li>盲目搜索：按预定的控制策略进行搜索，在搜索过程中获得的中间信息并不改变控制策略。 </li><li>启发式搜索：在搜索中加入了与问题有关的启发性信息，用于指导搜索朝着最有希望的方向前进，加速问题的求解过程并找到最优解。 </li></ul></li><li>按问题的表示方式：<ul><li>状态空间搜索：用指用状态空间法来表示问题所进行的搜索 </li><li>与或树搜索：用指用问题归约法来表示问题所进行的搜索 </li></ul></li></ul><h5 id="状态空间的搜索策略"><a href="#状态空间的搜索策略" class="headerlink" title="状态空间的搜索策略"></a>状态空间的搜索策略</h5><ul><li>状态空间的盲目搜索<ul><li>广度优先搜索</li><li>深度优先搜索</li><li>代价树搜索</li></ul></li><li>状态空间的启发式搜索<ul><li>启发性信息和估价函数</li><li>A算法和A*算法</li></ul></li><li>基本思想<ul><li>先把问题的初始状态作为当前扩展节点对其进行扩展，生成一组子节点。</li><li>然后检查问题的目标状态是否出现在这些子节点中。若出现，则搜索成功，找到了问题的解；若没出现，则再 <strong>按照某种搜索策略</strong>从已生成的子节点中选择一个节点作为当前扩展节点。</li><li>重复上述过程，直到目标状态出现在子节点中或者没有可供操作的节点为止。</li><li>所谓对一个节点进行“扩展”是指对该节点用某个可用操作进行作用，生成该节点的一组子节点。 </li></ul></li><li>数据结构和符号约定<ul><li><strong>OPEN表</strong>：未扩展节点表，用于存放刚生成节点</li><li><strong>CLOSED表</strong>：已扩展节点表，用于存放已经扩展或将要扩展的节点</li><li>S：用表示问题的初始状态</li><li>G：表示搜索过程所得到的搜索图</li><li>M：表示当前扩展节点新生成的且不为自己先辈的子节点集</li></ul></li></ul><p><em>各种搜索策略的主要区别在于对OPEN表中节点的排列顺序不同。</em>例如，广度优先搜索把先生成的子节点排在前面，而深度优先搜索则把后生成的子节点排在前面。</p><blockquote><p>广度优先搜索算法流程：</p></blockquote><ol><li>把初始节点S放入OPEN表中；</li><li>如果OPEN表为空，则问题无解，失败退出；</li><li>把OPEN表的第一个节点取出放入CLOSED表，并记该节点为n；</li><li>考察节点n是否为目标节点。若是，则得到问题的解，成功退出；</li><li>若节点n不可扩展，则转第(2)步；</li><li>扩展节点n，将其子节点放入OPEN表的 <strong>尾部</strong>，并为每一个子节点设置指向父节点的指针，然后转第(2)步。</li></ol><p>以八数码问题为例，得到下面这个广度优先搜索树：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>在上述广度优先算法中需要注意两个问题：</p><ul><li>对于任意一个可扩展的节点，总是按照固定的操作符的顺序对其进行扩展（空格左移、上移、右移、下移）。</li><li>在对任一节点进行扩展的时候，如果所得的某个子节点（状态）前面已经出现过，则立即将其放弃，不再重复画出（不送入OPEN表）。<br>因此，广度优先搜索的本质是，以初始节点为根节点，在状态空间图中按照广度优先的原则，生成一棵搜索树。</li></ul><p>广度优先搜索的优缺点：</p><ul><li>优点<ul><li>只要问题有解，用广度优先搜索总可以得到解，而且得到的是路径最短的解。</li></ul></li><li>缺点<ul><li>广度优先搜索盲目性较大，当目标节点距初始节点较远时将会产生许多无用节点，搜索效率低。</li></ul></li></ul><blockquote><p>深度优先搜索算法流程： </p></blockquote><ol><li>把初始节点S放入OPEN表中；</li><li>如果OPEN表为空，则问题无解 ，失败退出；</li><li>把OPEN表的第一个节点取出放入CLOSED表，并记该节点为n；</li><li>考察节点n是否为目标节点。若是，则得到问题的解，成功退出；</li><li>若节点n不可扩展，则转第(2)步； </li><li>扩展节点n，将其子节点放入OPEN表的 <strong>首部</strong>，并为每一个子节点设置 指向父节点的指针，然后转第(2)步。</li></ol><p>在深度优先搜索中，搜索一旦进入某个分支，就将沿着该分支一直向下搜索。如果目标节点恰好在此分支上，则可较快地得到解。但是，如果目标节点不在此分支上，而该分支又是一个无穷分支，则就不可能得到解。所以深度优先搜索是不完备的，即使问题有解，它也不一定能求得解。<br>因此，为了防止搜索过程沿着无益的路径扩展下去，往往给出一个节点扩展的最大深度，即 <strong>深度界限</strong>。当搜索深度达到了深度界限而仍未出现目标节点时，就换一个分支进行搜索。</p><p>有界深度优先搜索的特点：</p><ul><li>从某种意义上讲，有界深度优先搜索具有一定的启发性；</li><li>如果问题有解，且其路径长度≤dm，则上述搜索过程一定能求得解。</li><li>但是若解的路径长度&gt; dm,则上述搜索过程就得不到解。。</li><li>这说明在有界深度优先搜索中，深度界限的选择是很重要的，但是要恰当地给出dm的值是比较困难的。</li><li>即使能求出解，它也不一定是最优解。</li></ul><blockquote><p>代价树搜索</p></blockquote><p>考虑边的代价的搜索方法，代价树搜索的目的是为了找到一条代价最小的解路径。代价树搜索方法包括：</p><ul><li>代价树的广度优先搜索</li><li>代价树的深度优先搜索</li></ul><blockquote><p>启发式信息与代价函数</p></blockquote><p>采用问题自身的特性信息，以指导搜索朝着最有希望的方向前进。<br>启发性信息是指那种与具体问题求解过程有关的，并可指导搜索过程朝着最有希望方向前进的控制信息。启发信息的启发能力越强，扩展的无用结点越少。</p><p>启发性信息的种类</p><ul><li>有效地帮助确定扩展节点的信息；</li><li>有效的帮助决定哪些后继节点应被生成的信息；</li><li>能决定在扩展一个节点时哪些节点应从搜索树上删除的信息。</li></ul><p>估价函数的一般形式为：<code>f(x) = g(x)+h(x)</code>，其中<code>g(x)</code>表示从初始节点S0到节点x的代价；<code>h(x)</code>是从节点x到目标节点Sg的最优路径的代价的估计，它体现了问题的启发性信息，<code>h(x)</code>称为启发函数。</p><blockquote><p>A算法与A*算法</p></blockquote><p>A算法：在图搜索算法中，如果能在搜索的每一步都利用估价函数<code>f(n)=g(n)+h(n)</code>对OPEN表中的节点进行排序，则该搜索算法为A算法。</p><p>A算法的类型<br>可根据搜索过程中选择扩展节点的范围，将启发式搜索算法分为：</p><ul><li>全局择优搜索算法： 从OPEN表的所有节点中选择一个估价函数值最小的一个进行扩展。</li><li>局部择优搜索算法：仅从刚生成的子节点中选择一个估价函数值最小的一个进行扩展。</li></ul><p>A*算法是对A算法的估价函数<code>f(n)=g(n)+h(n)</code>加上某些限制后得到的一种启发式搜索算法。</p><p>假设<code>f*(n)</code>是从初始节点出发经过节点n达到目标节点的最小代价，估价函数<code>f(n)</code>是对<code>f*(n)</code>的 <strong>估计值</strong>。且<code>f*(n)=g*(n)+h*(n)</code>，<code>g*(n)</code>是从初始节点S0到节点n的最小代价。<code>h*(n)</code>是从节点n到目标节点的最小代价，<strong>若有多个目标节点，则为其中最小的一个</strong>。</p><p>A*算法对A算法（全局择优的启发式搜索算法）中的<code>g(n)</code>和<code>h(n)</code>分别提出如下限制：</p><ul><li>第一，<code>g(n)</code>是对最小代价<code>g*(n)</code>的估计，且<code>g(n)&gt;0</code>；</li><li>第二，<code>h(n)</code>是最小代价<code>h*(n)</code>的下界，即对任意节点n均有<code>h(n)≤h*(n)</code>。</li></ul><p>即：满足上述两条限制的A算法称为A*算法。</p><h5 id="与-或树的搜索策略-ppt-9-10"><a href="#与-或树的搜索策略-ppt-9-10" class="headerlink" title="与/或树的搜索策略(ppt-9~10)"></a>与/或树的搜索策略(ppt-9~10)</h5><p>1、 与/或树的一般搜索过程</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(1)</span> 把原始问题作为初始节点S<span class="number">0</span>，并把它作为当前节点； </span><br><span class="line"><span class="comment">(2)</span> 应用分解或等价变换操作对当前节点进行扩展； </span><br><span class="line"><span class="comment">(3)</span> 为每个子节点设置指向父节点的指针； </span><br><span class="line"><span class="comment">(4)</span> 选择合适的子节点作为当前节点，反复执行第<span class="comment">(2)</span>步和第<span class="comment">(3)</span>步，在此期间需要多次调用可解标记过程或不可解标记过程，直到初始节点被标记为可解节点或不可解节点为止。</span><br></pre></td></tr></table></figure><p>2、 与/或树的广度优先搜索</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)把初始节点<span class="symbol">S0</span>放入OPEN表中； </span><br><span class="line">(<span class="number">2</span>)把OPEN表的第一个节点取出放入CLOSED表，并记该节点为<span class="built_in">n</span>； </span><br><span class="line">(<span class="number">3</span>)如果节点<span class="built_in">n</span>可扩展，则做下列工作：</span><br><span class="line">    ① 扩展节点<span class="built_in">n</span>，将其子节点放入OPEN表的尾部，并为每一个子节点设置指向父节点的指针；</span><br><span class="line">    ② 考察这些子节点中有否终止节点。若有，则标记这些终止节点为可解节点，并用可解标记过程对其父节点及先辈节点中的可解解节点进行标记。如果初始解节点<span class="symbol">S0</span>能够被标记为可解节点，就得到了解树，搜索成功，退出搜索过程；如果不能确定<span class="symbol">S0</span>为可解节点，则从OPEN表中删去具有可解先辈的节点。</span><br><span class="line">    ③ 转第(<span class="number">2</span>)步。</span><br><span class="line">(<span class="number">4</span>) 如果节点<span class="built_in">n</span>不可扩展，则作下列工作： </span><br><span class="line">    ① 标记节点<span class="built_in">n</span>为不可解节点；</span><br><span class="line">    ② 应用不可解标记过程对节点<span class="built_in">n</span>的先辈中不可解解的节点进行标记。如果初始解节点<span class="symbol">S0</span>也被标记为不可解节点，则搜索失败，表明原始问题无解，退出搜索过程；如果不能确定<span class="symbol">S0</span>为不可解节点，则从Open表中删去具有不可解先辈的节点。</span><br><span class="line">    ③ 转第(<span class="number">2</span>)步。</span><br></pre></td></tr></table></figure><hr><p>【例子】 设有下图所示的与/或树，节点按标注顺序进行扩展，其中标有t1、t2、t3的节点是终止节点，A、B、C为不可解的端节点。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E4%BE%8B%E5%AD%90.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>本例中与/或树的广度优先搜索过程：</p><p>(1) 先扩展1号节点，生成2号节点和3号节点。<br>(2) 扩展2号节点，生成A节点和4号节点。<br>(3) 扩展3号节点，生成t1节点和5号节点。由于t1为终止节点，则标记它为可解节点，并应用可解标记过程，不能确定3号节点是否可节。<br>(4)  扩展节点A，由于A是端节点，因此不可扩展。调用不可解标记过程。<br>(5) 扩展4号节点，生成t2节点和B节点。由于t2为终止节点，标记为可解节点，应用可解标记过程，可标记2号节点为可解，但不能标记1号节点为可解。<br>(6) 扩展5号节点，生成t3节点和C节点。由于t3为终止节点，标记它为可解节点，应用可解标记过程，可标记1号节点为可解节点。<br>(7) 搜索成功，得到由1、2、3、4、5号节点和t1、t2、t3节点构成的解树。</p><hr><p>3、 与/或树的深度优先搜索</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)把初始节点S0放入OPEN表中； </span><br><span class="line">(<span class="number">2</span>)把OPEN表第一个节点取出放入CLOSED表，并记该节点为n； </span><br><span class="line">与/或树的深度优先搜索算法如下：</span><br><span class="line">(<span class="number">3</span>)如果节点n的深度等于dm，则转第(<span class="number">5</span>)步的第①点； </span><br><span class="line">(<span class="number">4</span>)如果节点n可扩展，则做下列工作： </span><br><span class="line">    ① 扩展节点n，将其子节点放入OPEN表的首部，并为每一个子节点设置指向父节点的指针；  </span><br><span class="line">    ② 考察这些子节点中是否有终止节点。若有，则标记这些终止节点为可解节点，并用可解标记过程对其父节点及先辈节点中的可解解节点进行标记。如果初始解节点S0能够被标记为可解节点，就得到了解树，搜索成功；如果不能确定S0为可解节点，则从OPEN表中删去具有可解先辈的节点。</span><br><span class="line">    ③ 转第(<span class="number">2</span>)步。 </span><br><span class="line">(<span class="number">5</span>)如果节点n不可扩展，则作下列工作： </span><br><span class="line">    ① 标记节点n为不可解节点；</span><br><span class="line">    ② 应用不可解标记过程对节点n的先辈中不可解解的节点进行标记。如果初始解节点S0也被标记为不可解节点，则搜索失败，表明原始问题无解，退出搜索过程；如果不能确定S0为不可解节点，则从Open表中删去具有不可解先辈的节点。</span><br><span class="line">    ③ 转第(<span class="number">2</span>)步。</span><br></pre></td></tr></table></figure><p>4、 与/或树的启发式搜索</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>) 把初始节点<span class="symbol">S0</span>放入OPEN表中；</span><br><span class="line">(<span class="number">2</span>) 求出希望树<span class="built_in">T</span>，即根据当前搜索树中节点的代价h求出以<span class="symbol">S0</span>为根的希望树<span class="built_in">T</span>； </span><br><span class="line">(<span class="number">3</span>) 依次在OPEN表中取出<span class="built_in">T</span>的端节点放入CLOSED表，并记该节点为<span class="built_in">n</span>；节点<span class="built_in">n</span>有三种不同情况：</span><br><span class="line">    ①<span class="built_in">n</span>为终止节点，</span><br><span class="line">    ②<span class="built_in">n</span>不是终止节点，但可扩展，</span><br><span class="line">    ③<span class="built_in">n</span>不是终止节点，且不可扩展，</span><br><span class="line">对三种情况分别进行步骤(<span class="number">4</span>) (<span class="number">5</span>) (<span class="number">6</span>)的操作过程； </span><br><span class="line">(<span class="number">4</span>)如果节点<span class="built_in">n</span>为终止节点，则： </span><br><span class="line">    ① 标记节点<span class="built_in">n</span>为可解节点；</span><br><span class="line">    ② 在<span class="built_in">T</span>上应用可解标记过程，对<span class="built_in">n</span>的先辈节点中的所有可解解节点进行标记；</span><br><span class="line">    ③ 如果初始解节点<span class="symbol">S0</span>能够被标记为可解节点，则<span class="built_in">T</span>就是最优解树，成功退出；</span><br><span class="line">    ④ 否则，从OPEN表中删去具有可解先辈的所有节点。 </span><br><span class="line">    ⑤ 转第(<span class="number">2</span>)步。 </span><br><span class="line">(<span class="number">5</span>) 如果节点<span class="built_in">n</span>不是终止节点，但可扩展，则： </span><br><span class="line">    ① 扩展节点<span class="built_in">n</span>，生成<span class="built_in">n</span>的所有子节点；</span><br><span class="line">    ② 把这些子节点都放入OPEN表中，并为每一个子节点设置指向父节点<span class="built_in">n</span>的指针；</span><br><span class="line">    ③ 计算这些子节点及其先辈节点的h值；</span><br><span class="line">    ④ 转第(<span class="number">2</span>)步。</span><br><span class="line">(<span class="number">6</span>) 如果节点<span class="built_in">n</span>不是终止节点，且不可扩展，则： </span><br><span class="line">    ① 标记节点<span class="built_in">n</span>为不可解节点；</span><br><span class="line">    ② 在<span class="built_in">T</span>上应用不可解标记过程，对<span class="built_in">n</span>的先辈节点中的所有不可解解节点进行标记；</span><br><span class="line">    ③ 如果初始解节点<span class="symbol">S0</span>能够被标记为不可解节点，则问题无解，失败退出；</span><br><span class="line">    ④ 否则，从OPEN表中删去具有不可解先辈的所有节点。 </span><br><span class="line">    ⑤ 转第(<span class="number">2</span>)步。</span><br></pre></td></tr></table></figure><p>5、 博弈树的启发式搜索<br>6、 α-β剪枝技术</p><blockquote><p>搜索的完备性与效率</p></blockquote><p><strong>完备性</strong></p><ul><li>对于一类 <strong>可解的问题</strong>和一个搜索过程，如果运用该搜索过程一定能求得该类问题的解，则称该搜索过程为 <strong>完备</strong>的，否则为不完备的。</li><li>完备的搜索过程称为“搜索算法”。不完备的搜索过程不是算法，称为“过程”。</li><li>广度优先搜索、代价树的广度优先搜索、改进后的有界深度优先搜索以及A*算法都是完备的搜索过程，其它搜索过程都是不完备的。</li></ul><p><strong>搜索效率</strong></p><ul><li>一个搜索过程的搜索效率不仅取决于过程自身的启发能力，而且还与被解问题的有关属性等多种因素有关。</li><li>为了比较求解同一问题的不同搜索方法的效率，常用以下两种指标来衡量：<ul><li><strong>外显率</strong></li><li><strong>有效分支因数</strong></li></ul></li></ul><p>其中，外显率定义为：<code>P=L/T</code>；L为从初始节点到目标节点的路径长度；T为整个搜索过程中所生成的节点总数。<br>外显率反映了搜索过程中从初始节点向目标节点前进时 <strong>搜索区域的宽度</strong>。当<code>T=L</code>时，<code>P=1</code>，表示搜索过程中每次只生成一个节点，它恰好是解路径上的节点，搜索效率最高。P越小表示搜索时产生的无用节点愈多，搜索效率愈低。</p><p>有效分枝因数B定义为：<code>B+B^2+…+B^L=T</code>；B是有效分枝因数，它表示在整个搜索过程中 <strong>每个节点平均生成的子节点数目</strong>；L为从初始节点到目标节点的路径长度；T为整个搜索过程中所生成的节点总数。当<code>B＝1</code>时，<code>L=T</code>，此时所生成的节点数最少，搜索效率最高。</p><h4 id="自然演绎推理"><a href="#自然演绎推理" class="headerlink" title="自然演绎推理"></a>自然演绎推理</h4><p>从一组已知为真的事实出发，直接运用经典逻辑中的推理规则推出结论的过程称为自然演绎推理。<br>自然演绎推理最基本的推理规则是三段论推理，它包括：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E8%87%AA%E7%84%B6%E6%BC%94%E7%BB%8E%E6%8E%A8%E7%90%86.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><hr><p>【例子】 设已知如下事实：<br>(1) 只要是需要编程序的课，王程都喜欢。<br>(2) 所有的程序设计语言课都是需要编程序的课。<br>(3) C是一门程序设计语言课。<br>求证：王程喜欢C这门课。</p><p>证明：<br>第一步，首先定义谓词<br>    <code>Prog(x)</code>：x是需要编程序的课。<br>    <code>Like(x, y)</code>: x喜欢y。<br>    <code>Lang(x)</code>: x是一门程序设计语言课<br>第二步，把已知事实及待求解问题用谓词公式表示如下：<br>    <code>Prog(x)→Like(Wang , x)</code><br>    <code>(∀x)( Lang(x)→Prog(x))</code><br>    <code>Lang(C)</code><br>第三步，应用推理规则进行推理：<br>    <code>Lang(y)→Prog(y)</code>                                    全称固化<br>    <code>Lang(C)，Lang(y)→Prog(y) ⇒ Prog(C)</code>                 假言推理 {C/y}<br>    <code>Prog(C),  Prog(x)→Like(Wang , x) ⇒ Like(Wang , C)</code>  假言推理  {C/x}<br>因此，王程喜欢C这门课。</p><hr><h5 id="注意避免以下两类错误："><a href="#注意避免以下两类错误：" class="headerlink" title="注意避免以下两类错误："></a>注意避免以下两类错误：</h5><ul><li>肯定后件的错误：当<code>P→Q</code>为真时，希望通过肯定后件Q为真来推出前件P为真，这是不允许的。</li><li>否定前件的错误：当<code>P→Q</code>为真时，希望通过否定前件P来推出后件Q为假，这也是不允许的。</li></ul><h5 id="自然演绎推理的优缺点"><a href="#自然演绎推理的优缺点" class="headerlink" title="自然演绎推理的优缺点"></a>自然演绎推理的优缺点</h5><ul><li>优点<ul><li>定理证明过程自然，易于理解，并且有丰富的推理规则可用。</li></ul></li><li>缺点<ul><li>是容易产生知识爆炸，推理过程中得到的中间结论一般按指数规律递增，对于复杂问题的推理不利，甚至难以实现。</li></ul></li></ul><h4 id="消解演绎推理"><a href="#消解演绎推理" class="headerlink" title="消解演绎推理"></a>消解演绎推理</h4><p>一种基于 <strong>鲁滨逊（Robinson）消解原理</strong>的机器推理技术。鲁滨逊消解原理亦称为消解原理，是鲁滨逊于1965年在海伯伦（Herbrand）理论的基础上提出的一种基于逻辑的“反证法”。</p><blockquote><p>在人工智能中，几乎所有的问题都可以转化为一个定理证明问题。定理证明的实质，就是要对前提P和结论Q，证明<code>P→Q</code>永真。<br>而要证明<code>P→Q</code>永真，就是要证明<code>P→Q</code>在任何一个非空的个体域上都是永真的。这将是非常困难的，甚至是不可实现的。</p></blockquote><p><strong>鲁滨逊消解原理</strong>把永真性的证明转化为关于 <strong>不可满足性</strong>的证明。即：要证明<code>P→Q</code>永真，只需证明<code>P∧¬Q</code>不可满足。（<code>¬(P→Q) ⇔ ¬(¬P∨Q) ⇔ P∧¬Q</code>）</p><h5 id="子句集及其化简"><a href="#子句集及其化简" class="headerlink" title="子句集及其化简"></a>子句集及其化简</h5><blockquote><p>鲁滨逊消解原理是在子句集的基础上讨论问题的。因此，讨论消解演绎推理之前，需要先讨论子句集的有关概念。</p></blockquote><ul><li>原子谓词公式及其否定统称为 <strong>文字</strong>。例如: P(x)、Q(x)、¬ P(x)、 ¬ Q(x)等都是文字。</li><li>任何文字的析取式称为 <strong>子句</strong>。例如，P(x)∨Q(x)，P(x，f(x))∨Q(x，g(x))都是子句。</li><li>不含任何文字的子句称为 <strong>空子句</strong>。<ul><li>由于空子句不含有任何文字，也就不能被任何解释所满足，因此 <strong>空子句是永假的</strong>，不可满足的。</li><li>空子句一般被记为NIL。</li></ul></li><li>由子句或空子句所构成的集合称为 <strong>子句集</strong>。<ul><li>在子句集中，子句之间是 <strong>合取关系</strong>；</li><li>子句集中的变元受 <strong>全称量词</strong>的约束；</li><li>任何谓词公式都可通过等价关系及推理规则化为相应的子句集。</li></ul></li></ul><p>把谓词公式化成子句集的步骤<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E5%8C%96%E5%AD%90%E5%8F%A5%E9%9B%86.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>子句集的意义<br>在上述化简过程中，由于在消去存在量词时所用的Skolem函数可以不同，因此化简后的标准子句集是不唯一的。因此，当原谓词公式为非永假时，它与其标准子句集并不等价。但当原谓词公式为永假（或不可满足）时，其标准子句集则一定是永假的，即Skolem化并不影响原谓词公式的永假性。</p><p>不可满足性<br>对于任意论域中的任意一个解释，S中的子句不能同时取得真值T。</p><blockquote><p>定理：设有谓词公式F，其子句集为S，则F不可满足的充要条件是S不可满足。</p></blockquote><ul><li>由此定理可知，要证明一个谓词公式是不可满足的，只要证明其相应的标准子句集是不可满足的就可以了。</li><li>由于子句集中的子句之间是合取关系，<strong>子句集中只要有一个子句为不可满足，则整个子句集就是不可满足的</strong>。</li><li>空子句是不可满足的。因此，<strong>一个子句集中如果包含有空子句，则此子句集就一定是不可满足的</strong>。</li><li>这个定理是 <strong>鲁滨逊消解原理的主要依据</strong>。</li></ul><h5 id="鲁滨逊消解原理"><a href="#鲁滨逊消解原理" class="headerlink" title="鲁滨逊消解原理"></a>鲁滨逊消解原理</h5><p>鲁滨逊消解原理的基本思想</p><ul><li>首先把欲证明问题的 <strong>结论否定</strong>，并加入子句集，得到一个扩充的子句集S’；</li><li>然后设法检验子句集S’是否含有空子句，若含有空子句，则表明S’是不可满足的；若不含有空子句，则继续使用消解法，在子句集中选择合适的子句进行消解，<strong>直至导出空子句或不能继续消解为止</strong>。</li></ul><p>鲁滨逊消解原理包括</p><ul><li>命题逻辑的消解</li><li>谓词逻辑的消解</li></ul><blockquote><p>命题逻辑的消解</p></blockquote><p>消解推理的核心是求两个子句的 <strong>消解式</strong>。</p><ul><li>设C1和C2是子句集中的任意两个子句，如果C1中的文字L1与C2中的文字L2 <strong>互补</strong>，那么可从C1和C2中分别消去L1和L2，并将C1和C2中余下的部分按析取关系构成一个新的子句C12，则称这一过程为 <strong>消解</strong>，称C12为C1和C2的 <strong>消解式</strong>，称C1和C2为C12的 <strong>亲本子句</strong>。</li></ul><hr><p>【例子】</p><ol><li>设C1=¬Q，C2=Q，则C1和C2的消解式C12 = NIL .</li><li>设C1=P∨Q∨R，C2=¬P∨S，则C1和C2的消解式C12 = Q∨R∨S .</li><li>设C1 =¬P ∨ Q ，C2=¬Q，C3=P，则C1、C2、C3的消解式C123 = NIL .</li></ol><hr><ul><li>很显然，可以得出定理：<strong>消解式C12是其亲本子句C1和C2的逻辑结论。</strong>根据该定理，可以得到以下推论：<ul><li>推论1：设C1和C2是子句集S中的两个子句，C12是C1和C2的消解式，若用C12代替C1和C2后得到新的子句集S1，则由S1的不可满足性可以推出原子句集S的不可满足性。即：<br><code>S1的不可满足性⇔S的不可满足性</code></li><li>推论2：设C1和C2是子句集S中的两个子句，C12是C1和C2的消解式，若把C12加入S中得到新的子句集S2，则S与S2的不可满足性是等价的。即：<br><code>S2的不可满足性⇔S的不可满足性</code></li></ul></li></ul><p>上述两个推论说明，<em>为证明子句集S的不可满足性，只要对其中可进行消解得子句进行消解，<strong>并把消解式加入到子句集S中，或者用消解式代替他的亲本子句</strong>，然后对新的子句集证明其不可满足性就可以了</em>。<br>如果经消解能得到空子句，根据空子句的不可满足性，即可得到原子句集S是不可满足的结论。<br>在命题逻辑中，对不可满足的子句集S，其消解原理是完备的。即：<strong>子句集S是不可满足的，当且仅当存在一个从S到空子句的消解过程。</strong></p><p>应用消解原理证明定理的过程称为 <strong>消解反演</strong>。</p><blockquote><p>命题逻辑的消解反演：</p></blockquote><p>在命题逻辑中，已知F，证明G为真的消解反演过程如下：</p><ol><li>否定目标公式G，得¬G;</li><li>把¬G并入到公式集F中，得到{F，¬G}；</li><li>把{F，¬G}化为子句集S；</li><li>应用消解原理对子句集S中的子句进行消解，并把每次得到的消解式并入S中。如此反复进行，若 <strong>出现空子句</strong>，则停止消解，此时就证明了G为真。</li></ol><hr><p>【例子】 设已知的公式集为<code>{P,(P∧Q)→R,(S∨T)→Q,T}</code>，求证：R为真。</p><p>解：假设结论R为假, 将¬R加入公式集，并化为子句集：<br>    <code>S={P,¬P∨¬Q∨R,¬S∨Q,¬T∨Q,T,¬R}</code><br>其消解过程如下图的消解演绎树所示。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%B6%88%E8%A7%A3%E6%A0%91.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>该树根为空子句NIL，则子句集S不可满足，即假设有误，于是证得R为真。</p><hr><blockquote><p>谓词逻辑的消解</p></blockquote><ul><li>在谓词逻辑中，由于子句集中的谓词一般都含有变元，因此不能象命题逻辑那样直接消去互补文字。</li><li>对于谓词逻辑，需要先用一个最一般合一对变元进行置换，然后才能进行消解。</li></ul><p>设C1和C2是两个没有公共变元的子句，L1和L2分别是C1和C2中的文字。如果 σ 是L1和¬ L2存在的<code>最一般合一</code>，则称：<br>    <code>C12=({C1σ}-{ L1σ})∪({ C2σ}-{ L2σ})</code><br>为C1和C2的二元消解式，L1和L2为消解式上的文字。</p><p><strong>注意</strong>：在谓词逻辑的消解过程中，要注意以下几个问题：</p><ol><li>若C1和C2有相同的变元x，需要将其中一个变元更名。（例2）</li><li>求消解式不能同时消去两个互补对，消去这两个互补文字所得的结果不是两个亲本子句的逻辑结论。(例3)</li><li>对参加消解的某个子句，若其内部有可合一的文字，则在进行消解之前应先对这些文字进行合一，以实现这些子句内部的化简。(例4)</li></ol><hr><p>【例子】<br>例1、设<code>C1=P(a)∨R(x)</code>，<code>C2=¬P(y)∨Q(b)</code>，求 C12。<br>解：取<code>L1= P(a)</code>, <code>L2=¬P(y)</code>，则L1和¬L2的最一般合一是<code>σ={a/y}</code>。因此：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C<span class="number">12</span> = <span class="comment">( &#123;C1σ&#125;-&#123;L1σ&#125;)</span> ∪ <span class="comment">(&#123;C2σ&#125;-&#123;L2σ&#125;)</span></span><br><span class="line">    = <span class="comment">(&#123;P(a)</span>, R<span class="comment">(x)</span>&#125;-&#123;P<span class="comment">(a)</span>&#125;)∪<span class="comment">(&#123;¬P(a)</span>, Q<span class="comment">(b)</span>&#125;-&#123;¬P<span class="comment">(a)</span>&#125;)</span><br><span class="line">    = <span class="comment">(&#123;R(x)</span>&#125;)∪<span class="comment">(&#123;Q(b)</span>&#125;)</span><br><span class="line">    = &#123; R<span class="comment">(x)</span>, Q<span class="comment">(b)</span> &#125; </span><br><span class="line">    = R<span class="comment">(x)</span>∨Q<span class="comment">(b)</span></span><br></pre></td></tr></table></figure><p>例2、设<code>C1=P(x)∨Q(a)</code>，<code>C2=¬P(b)∨R(x)</code>，求 C12。<br>解：由于C1和C2有相同的变元x，不符合定义的要求。为了进行消解，需要修改C2中变元的名字。令<code>C2=¬P(b)∨R(y)</code>，此时<code>L1= P(x)</code>, <code>L2 =¬P(b)</code>，L1和¬L2的最一般合一是 <code>σ={b/x}</code>。则有:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C<span class="number">12</span> = <span class="comment">(&#123;C1σ&#125;-&#123;L1σ&#125;)</span>∪ <span class="comment">(&#123;C2σ&#125;-&#123;L2σ&#125;)</span></span><br><span class="line">    = <span class="comment">(&#123;P(b)</span>, Q<span class="comment">(a)</span>&#125;-&#123;P<span class="comment">(b)</span>&#125;) ∪ <span class="comment">(&#123;¬P(b)</span>, R<span class="comment">(y)</span>&#125;-&#123;¬P<span class="comment">(b)</span>&#125;)</span><br><span class="line">    = <span class="comment">(&#123;Q(a)</span>&#125;) ∪ <span class="comment">(&#123;R(y)</span>&#125;)</span><br><span class="line">    = &#123;Q<span class="comment">(a)</span>, R<span class="comment">(y)</span>&#125;</span><br><span class="line">    = Q<span class="comment">(a)</span>∨R<span class="comment">(y)</span></span><br></pre></td></tr></table></figure><p>例3、设 <code>C1=P(a)∨¬Q(x)</code>，<code>C2=¬P(y)∨Q(b)</code>，求C12。<br>解：对C1和C2通过最一般合一（<code>σ={b/x, a/y}</code>）的作用，便得到空子句NIL的结论，从而得出C1、C2互相矛盾的结论，而事实上C1、C2并无矛盾。</p><p>例4、设 <code>C1=P(x)∨P(f(a))∨Q(x)</code> ，<code>C2=¬P(y)∨R(b)</code>，求C12。<br>解：本例的C1中有可合一的文字P(x)与P(f(a))，用它们的最一般合一<code>σ={f(a)/x}</code>进行代换，可得到 ：<br><code>C1σ=P(f(a))∨Q(f(a))</code><br>此时对C1σ与C2进行消解。选<code>L1= P(f(a))</code>, <code>L2 =¬P(y)</code>，L1和L2的最一般合一是<code>σ={f(a)/y}</code>，则可得到C1和C2的二元消解式为：<br><code>C12=R(b)∨Q(f(a))</code></p><p>例5、设 <code>C1=P(y)∨P(f(x))∨Q(g(x))</code>、<code>C2=¬P(f(g(a)))∨Q(b)</code>，求C12。<br>解：对C1，取最一般合一<code>σ={f(x)/y}</code>，得C1的因子<code>C1σ=P(f(x))∨Q(g(x))</code>，对C1的因子和C2消解（<code>σ={g(a)/x }</code>），可得：<code>C12=Q(g(g(a)))∨Q(b)</code></p><hr><blockquote><p>谓词逻辑的消解反演：</p></blockquote><p>在谓词逻辑中，已知F，证明G是F的结论的消解反演过程如下：</p><ol><li>否定目标公式G，得¬G;</li><li>把¬G并入到公式集F中，得到{F，¬G}；</li><li>把{F，¬G}化为子句集S；</li><li>应用消解原理对子句集S中的子句进行消解，并把每次得到的消解式并入S中。如此反复进行，若出现空子句，则停止消解，此时就证明了G为真。</li></ol><p>与命题逻辑的消解反演过程比较一下</p><ul><li>步骤基本相同，但每步的处理对象不同。</li><li>在步骤(3)化简子句集时，谓词逻辑需要把由谓词构成的公式集化为子句集。</li><li>在步骤(4)按消解原理进行消解时，谓词逻辑的消解原理需要考虑两个亲本子句的最一般合一。</li></ul><hr><p>【例子】<br>例1、已知<code>F:(∀x)((∃y)(A(x, y)∧B(y))→(∃y)(C(y)∧D(x, y)))</code>、<code>G:¬(∃x)C(x)→(∀x)(∀y)(A(x, y)→¬B(y))</code>，求证G是F的逻辑结论。</p><p>证明：<br>第一步，先把G否定，并放入F中，得到的<code>{F,¬G}</code>：<br>    <code>{(∀ x)((∃ y)(A(x,y)∧B(y))→(∃ y)(C(y)∧D(x,y)))</code>，<code>¬(¬(∃ x)C(x)→(∀ x)(∀ y)(A(x,y)→¬ B(y)))}</code><br>第二步，把{F,¬G}化成子句集，得到<br>    (1) <code>¬A(x,y)∨¬B(y)∨C(f(x))</code><br>    (2) <code>¬A(u,v)∨¬B(v)∨D(u,f(u))</code><br>    (3) <code>¬C(z)</code><br>    (4) <code>A(m,n)</code><br>    (5) <code>B(k)</code><br>第三步，应用谓词逻辑的消解原理对上述子句集进行消解，其过程为：<br>    (6) <code>¬ A(x,y)∨¬ B(y)</code>    <em>(1)和(3)消解，取σ={f(x)/z}</em><br>    (7) <code>¬ B(n)</code>             <em>(4)和(6)消解，取σ={m/x,n/y}</em><br>    (8) <code>NIL</code>                  <em>(5)和(7)消解，取σ={n/k}</em><br>最后，“G是F的逻辑结论”得证。</p><p>上述消解过程可用如下消解树来表示<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%B6%88%E8%A7%A3%E6%A0%912.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>例2、<strong>“快乐学生”问题</strong><br>假设：任何通过计算机考试并获奖的人都是快乐的，任何肯学习或幸运的人都可以通过所有考试，张不肯学习但他是幸运的，任何幸运的人都能获奖。<br>求证：张是快乐的。</p><p>证明：(完整的解题过程)<br>第一步，先定义谓词：<br>    Pass(x, y)：x可以通过y考试<br>    Win(x, prize)：x能获得奖励<br>    Study(x) ：x肯学习<br>    Happy(x)：x是快乐的<br>    Lucky(x) ：x是幸运的<br>第二步，将已知条件以及结论的否定用谓词表示如下：<br>    “任何通过计算机考试并奖的人都是快乐的”<br>            <code>(∀x)(Pass(x, computer)∧Win(x, prize)→Happy(x))</code><br>    “任何肯学习或幸运的人都可以通过所有考试”<br>            <code>(∀x)(∀y)(Study(x)∨Lucky(x)→Pass(x, y))</code><br>    “张不肯学习但他是幸运的”<br>            <code>¬Study(zhang)∧Lucky(zhang)</code><br>    “任何幸运的人都能获奖”<br>            <code>(∀x)(Lucky(x)→Win(x, prize))</code><br>    结论“张是快乐的”的否定<br>            <code>¬Happy(zhang)</code><br>第三步，将上述谓词公式转化为子句集如下：</p><pre><code>1. `¬Pass(x, computer)∨¬Win(x, prize)∨Happy(x)`2. `¬Study(y)∨Pass(y, z)`3. `¬Lucky(u)∨Pass(u, v)`4. `¬Study(zhang)`5. `Lucky(zhang)`6. `¬Lucky(w)∨Win(w, prize)`7. `¬ Happy(zhang)`    (结论的否定)</code></pre><p>第四步，按消解原理进行消解，消解树如下：<br>    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%B6%88%E8%A7%A3%E6%A0%913.jpg" alt=""><br>最后，“张是快乐的”得证。</p><hr><h5 id="消解反演推理的消解策略"><a href="#消解反演推理的消解策略" class="headerlink" title="消解反演推理的消解策略"></a>消解反演推理的消解策略</h5><blockquote><p>在消解演绎推理中，由于事先并不知道哪些子句对可进行消解，更不知道通过对哪些子句对的消解能尽快得到空子句，因此就需要对子句集中的所有子句逐对进行比较，直到得出空子句为止。这种盲目的全面进行消解的方法，不仅会产生许多无用的消解式，更严重的是会产生组核爆炸问题。因此，需要研究有效的消解策略来解决这些问题。</p></blockquote><p>常用的消解策略可分为两大类：</p><ul><li>限制策略：通过限制参加消解的子句减少盲目性</li><li>删除策略：通过删除某些无用的子句缩小消解范围</li></ul><h5 id="用消解反演求取问题的答案"><a href="#用消解反演求取问题的答案" class="headerlink" title="用消解反演求取问题的答案"></a>用消解反演求取问题的答案</h5><p>消解原理除了可用于 <strong>定理证明</strong>外，还可用来 <strong>求取问题答案</strong>，其思想与定理证明相似。<br>其一般步骤为：</p><ol><li>把问题的已知条件用谓词公式表示出来，并化为子句集；</li><li>把问题的目标的否定用谓词公式表示出来，并化为子句集；</li><li>对目标否定子句集中的每个子句，构造该子句的重言式（即把该目标否定子句和此目标否定子句的否定之间再进行析取所得到的子句），用这些重言式代替相应的目标否定子句式，并把这些重言式加入到前提子句集中，得到一个新的子句集；</li><li>对这个新的子句集，应用消解原理求出其证明树，这时证明树的根子句不为空，称这个证明树为修改的证明树；</li><li>用修改证明树的根子句作为回答语句，则答案就在此根子句中。</li></ol><hr><p>【例子】<br>例1、已知：“张和李是同班同学，如果x和y是同班同学，则x的教室也是y的教室，现在张在302教室上课。”<br>问：“现在李在哪个教室上课？”</p><p>解：第一步，首先定义谓词<br>    <code>C(x, y)</code>：x和y是同班同学<br>    <code>At(x, u)</code>：x在u教室上课。<br>第二步，把已知前提用谓词公式表示如下：<br>    <code>C(zhang, li)</code><br>    <code>(∀x)(∀y)(∀u)(C(x, y)∧At(x, u)→At(y,u))</code><br>    <code>At(zhang, 302)</code><br>把目标的否定用谓词公式表示如下：<br>    <code>¬(∃v)At(li, v)</code><br>第三步，把上述表示前提的谓词公式化为子句集：<br>    <code>C(zhang, li)</code><br>    <code>¬C(x, y)∨¬At(x, u)∨At(y, u)</code><br>    <code>At(zhang, 302)</code><br>把目标的否定化成子句式，并用下面的 <strong>重言式</strong>代替：<br>         <code>¬At(li,v) ∨At(li,v)</code><br>第四步，把此 <strong>重言式</strong>加入前提子句集中，得到一个新的子句集，对这个新的子句集，应用消解原理求出其证明树。<br>求解过程如下图所示。该证明树的根子句就是所求的答案，即“李明在302教室”。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%B6%88%E8%A7%A3%E6%A0%914.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>例2、已知：A,B,C三人中有人从不说真话，也有人从不说假话。某人向这三人分别提出同一个问题：谁是说谎者？<br>    A答：“B和C都是说谎者”；<br>    B答：“A和C都是说谎者”；<br>    C答：“A和B中至少有一个是说谎者”。<br>问：求谁是老实人，谁是说谎者？</p><p>解：第一步，首先定义谓词<br><code>T(x)</code>：表示x说真话<br>第二步，把已知前提用谓词公式表示如下：<br>    有人从不说真话：<code>¬T(C)∨¬T(A)∨¬T(B)</code><br>    有人从不说假话：<code>T(C)∨T(A)∨T(B)</code><br>根据“A答：B和C都是说谎者”，则<br>    若A说真话：<code>T(A)→¬T(B)∧¬T(C)</code><br>    若A说假话： <code>¬T(A)→T(B)∨T(C)</code><br>同理，根据“B答：A和C都是说谎者”，则<br>    <code>T(B)→¬T(A)∧¬T(C)</code><br>    <code>¬T(B)→T(A)∨T(C)</code><br>根据“C答：A和B中至少有一个是说谎者”，则<br>    <code>T(C)→¬T(A)∨¬T(B)</code><br>    <code>¬T(C)→T(A)∧T(B)</code><br>第三步，把上述公式化成子句集，得到前提子句集S：<br>    <code>¬T(A)∨¬T(B)</code><br>    <code>¬T(A)∨¬T(C)</code><br>    <code>T(C)∨T(A)∨T(B)</code><br>    <code>¬T(B)∨¬T(C)</code><br>    <code>¬T(C)∨¬T(A)∨¬T(B)</code><br>    <code>T(A)∨T(C)</code><br>    <code>T(B)∨T(C)</code><br>第四步，先求谁是老实人，结论的否定为：<code>¬(∃x)T(x)</code>，把目标的否定化成子句式，并用下面的重言式代替：<br>    <code>¬T(x)∨T(x)</code><br>把此重言式加入前提子句集S，得到一个新子句集。<br>第五步，对这个新的子句集，应用消解原理求出其证明树。<br>    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%B6%88%E8%A7%A3%E6%A0%915.jpg" alt=""><br>第六步，同理证明A不是老实人，结论的否定为： ¬T(A)，将结论的否定¬(¬T(A)) 加入并入前提子句集S中，应用消解原理对新的子句集进行消解：<br>    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%B6%88%E8%A7%A3%E6%A0%916.jpg" alt=""></p><hr><h5 id="消解演绎推理的优缺点："><a href="#消解演绎推理的优缺点：" class="headerlink" title="消解演绎推理的优缺点："></a>消解演绎推理的优缺点：</h5><ul><li>优点：<ul><li>简单，便于在计算机上实现。</li></ul></li><li>缺点：<ul><li>必须把逻辑公式化成子句集。</li><li>不便于阅读与理解：¬P(x)∨Q(x)没有P(x)→Q(x)直观。</li><li>可能丢失控制信息，如下列逻辑公式，化成子句后都是: A∨B∨C<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(¬A∧¬B)</span>→C    ¬A→<span class="comment">(B∨C)</span></span><br><span class="line"><span class="comment">(¬A∧¬C)</span>→B    ¬B→<span class="comment">(A∨C)</span></span><br><span class="line"><span class="comment">(¬C∧¬B)</span>→A    ¬C→<span class="comment">(B∨A)</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="基于规则的演绎推理"><a href="#基于规则的演绎推理" class="headerlink" title="基于规则的演绎推理"></a>基于规则的演绎推理</h4><blockquote><p>在消解演绎推理中，需要把谓词公式化为子句形，这使得原来蕴含在谓词公式中的一些重要信息却会在求取子句形的过程中被丢失。<br>在不少情况下人们多希望使用接近于问题原始描述的形式来进行求解，而不希望把问题描述化为子句集。</p></blockquote><p>基于规则的演绎推理又称为与/或形演绎推理，不再把有关知识转化为子句集，而是把领域知识及已知事实分别用蕴含式及与/或形表示出来，然后通过运用蕴含式进行演绎推理，从而证明某个目标公式。</p><p>规则是一种比较接近于人们习惯的问题描述方式，按照 <strong>蕴含式</strong>（“If →Then”规则）这种问题描述方式进行求解的系统称为基于规则的系统，或者叫做 <strong>规则演绎系统</strong>。</p><p>规则演绎系统按照推理方式可分为：</p><ul><li>规则正向演绎系统</li><li>规则逆向演绎系统(ppt-14)</li><li>规则双向演绎系统(ppt-14)</li></ul><h5 id="规则正向演绎系统"><a href="#规则正向演绎系统" class="headerlink" title="规则正向演绎系统"></a>规则正向演绎系统</h5><p>首先说明一下，在规则正向演绎系统中，对已知事实和规则都有一定的要求，如果不是所要求的形式，需要进行变换。</p><p>事实表达式的与或形变换</p><ul><li>在基于规则的正向演绎系统中，把事实表示为非蕴含形式的与或形，作为系统的总数据库；</li><li>把一个公式化为与或形的步骤与化为子句集类似，只是不必把公式化为子句的合取形式，也不能消去公式中的合取。</li></ul><p>详细来说，把事实表达式化为非蕴含形式的与/或形的步骤如下：</p><ol><li>利用 “P→Q⇔﹁P∨Q”，消去蕴含符号； </li><li>利用狄.摩根定律及量词转换率把“﹁”移到紧靠谓词的位置，直到否定符号的辖域最多只含一个谓词为止；</li><li>重新命名变元，使不同量词约束的变元有不同的名字；</li><li>对存在量词量化的变量用skolem函数代替；</li><li>消去全称量词，且使各主要合取式中的变元具有不同的变量名。</li></ol><hr><p>【例子】<br>有如下表达式<br>        <code>(∃x) (∀y)(Q(y, x)∧﹁((R(y)∨P(y))∧S(x, y)))</code><br>可把它转化为：<br>        <code>Q(z, a)∧(  ( ﹁R(y)∧﹁P(y) )∨﹁S(a, y)  )</code><br>这就是 <strong>与/或形表示</strong>，也可用一棵与/或图表示出来。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E4%B8%8E%E6%88%96%E5%BD%A2%E6%A0%91.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><hr><blockquote><p>关于 <strong>与/或图</strong>说明以下几点：</p></blockquote><ul><li>当某表达式为k个子表达式的析取：<code>E1∨E2∨…∨Ek</code>，其中每个子表达式Ei均被表示为<code>E1∨E2∨…∨Ek</code>的后继节点，并由一个k线连接符（即图中的半圆弧）将这些后继节点都连接到其父节点，即表示成与的关系。</li><li>当某表达式为k个子表达式的合取：<code>E1∧E2∧…∧Ek</code>，其中的每个子表达式Ei均被表示为<code>E1∧E2∧…∧Ek</code>的一个单一的后继节点，无需用连接符连接，即表示成或的关系。</li><li><strong>这样，与/或图的根节点就是整个事实表达式，叶节点均为事实表达式中的一个文字</strong>。</li></ul><blockquote><p>有了与/或图的表示，就可以求出其解树（结束于文字节点上的子树）集。可以发现，事实表达式的子句集与解树集之间存在着一一对应关系，即 <strong>解树集中的每个解树都对应着子句集中的一个子句</strong>。<br><strong>解树集中每个解树的端节点上的文字的析取就是子句集中的一个子句。</strong></p></blockquote><p>上面那个与/或图有3个解树，分别对应这以下3个子句：<br>    <code>Q(z, a)</code>、<code>﹁R(y)∨ ﹁ S(a, y)</code>、<code>﹁P(y)∨ ﹁ S(a, y)</code></p><blockquote><p>还需要注意以下两点：</p><ul><li>这里的与/或图是作为综合数据库的一种表示，其中的变量受全称量词的约束。</li><li>在之前 问题归约表示 中所描述的 <strong>与/或图表示方法</strong>与这里 <strong>与/或形的与/或图表示</strong>有着不同的目的和含义，因此应用时应加以 <strong>区分</strong>。 </li></ul></blockquote><blockquote><p>规则的表示</p></blockquote><p>为简化演绎过程，通常要求规则具有如下形式：<code>L→W</code>，其中，L为单文字，W为与/或形公式。<br>(之所以限制前件L为单文字，是因为在进行正向演绎推理时要用规则作用于表示事实的与/或树，而该与/或树的叶节点都是单文字，这样就可用规则的前件与叶节点进行简单匹配。对非单文字情况，若形式为L1∨L2→W，则可将其转换成与之等价的两个规则L1→W与 L2→W进行处理。)</p><ul><li>假定出现在蕴含式中的任何变量全都受全称量词的约束，并且这些变量已经被换名，使得他们与事实公式和其他规则中的变量不同。</li><li>如果领域知识的规则表示形式与上述要求不同，则应将它转换成要求的形式。</li></ul><blockquote><p>将规则转换为要求形式的步骤：</p></blockquote><p>1、 暂时消去蕴含符号“→”。设有如下公式：<br>        <code>(∀x)(((∃y) (∀ z)P(x, y,z))→(∀u)Q(x, u))</code><br>运用等价关系“P→Q⇔﹁P∨Q”，可将上式变为：<br>        <code>(∀x)(﹁((∃ y) (∀z)P(x, y,z))∨(∀u)Q(x, u))</code><br>2、 把否定符号“﹁”移到紧靠谓词的位置上，使其作用域仅限于单个谓词。通过使用狄.摩根定律及量词转换律可把上式转换为：<br>        <code>(∀ x)( (∀y) (∃z)﹁P(x, y,z))∨ (∀u)Q(x, u))</code><br>3、 引入Skolem函数，消去存在量词。消去存在量词后，上式可变为：<br>        <code>(∀ x)( (∀y) (﹁P(x, y,f(x,y)))∨(∀u)Q(x, u))</code><br>4、 把所有全称量词移至前面化成前束式，消去全部全称量词。消去全称量词后，上式变为：<br>        <code>﹁P(x, y,f(x,y))∨Q(x, u)</code><br>此公式中的变元都被视为受全称量词约束的变元。<br>5、 恢复蕴含式表示。利用等价关系“<code>﹁P∨Q⇔P→Q</code>”将上式变为：<br>        <code>P(x, y,f(x,y))→Q(x, u)</code></p><blockquote><p>目标公式的表示形式</p></blockquote><ul><li>与/或树正向演绎系统要求目标公式用子句形表示。如果目标公式不是子句形，则需要化成子句形。</li></ul><blockquote><p>推理过程</p></blockquote><p>规则正向演绎推理过程是从已知事实出发，不断运用规则，推出欲证明目标公式的过程。<br>先用与/或树把已知事实表示出来，然后再用规则的前件和与/或树的叶节点进行匹配，并通过一个匹配弧把匹配成功的规则加入到与/或树中，依此使用规则，直到产生一个含有以目标节点为终止节点的解树为止。</p><blockquote><p>下面分命题逻辑和谓词逻辑两种情况来讨论规则正向演绎过程。</p></blockquote><p><strong>命题逻辑的规则正向演绎过程</strong><br>已知事实：<code>A∨B</code><br>规则：<code>r1: A→C∧D</code>，<code>r2:  B→E∧G</code><br>目标公式：<code>C∨G</code></p><p>证明：<br>1）先将已知事实用与/或树表示出来；<br>2）然后再用匹配弧把r1和r2分别连接到事实与/或树中与r1和r2 的前件匹配的两个不同端节点；<br>3) 由于出现了以目标节点为终节点的解树，故推理过程结束。这一证明过程可用下图表示。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E8%BF%87%E7%A8%8B%E5%9B%BE.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p><strong>谓词逻辑的规则正向演绎过程</strong><br>已知事实的与/或形表示：P(x, y)∨(Q(x)∧R(v, y))<br>规则：P(u, v)→(S(u)∨N(v))<br>目标公式：S(a)∨N(b)∨Q(c)</p><p>证明：<br>在谓词逻辑情况下，由于事实、规则及目标中均含有变元，因此，其规则演绎过程还需要用最一般合一对变进行置换。证明过程可用下图表示。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E8%BF%87%E7%A8%8B%E5%9B%BE2.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="产生式系统"><a href="#产生式系统" class="headerlink" title="产生式系统"></a>产生式系统</h4><h5 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h5><p>产生式系统的 <strong>基本结构</strong>由 <strong>数据库</strong>、<strong>产生式规则</strong>和 <strong>控制策略</strong>三部分构成。</p><ul><li>总数据库：存放求解问题的各种当前信息，如：问题的初始状态，输入的事实，中间结论及最终结论等。<ul><li>推理过程中，当规则库中某条规则的前提可以和总数据库的已知事实匹配时，该规则被激活，由它推出的结论将被作为新的事实放入总数据库，成为后面推理的已知事实。</li></ul></li><li>产生式规则：是一个规则库，也称知识库 。用于存放与求解问题有关的所有规则的集合。</li><li>控制策略：亦称推理机，用于控制整个产生式系统的运行，决定问题求解过程的推理线路。<ul><li>控制系统的主要任务包括： 选择匹配、 冲突消解、 执行操作、 终止推理、 路径解释…</li></ul></li></ul><h5 id="产生式系统的推理"><a href="#产生式系统的推理" class="headerlink" title="产生式系统的推理"></a>产生式系统的推理</h5><p>产生式系统的推理分为 <strong>正向推理</strong>、<strong>逆向推理</strong>和 <strong>双向推理</strong>三种形式。</p><h5 id="主要优缺点"><a href="#主要优缺点" class="headerlink" title="主要优缺点"></a>主要优缺点</h5><p>产生式系统的主要 <strong>优缺点</strong></p><ul><li>优点：<ul><li>自然性：采用“如果……，则……”的形式，人类的判断性知识基本一致。</li><li>模块性：规则是规则库中最基本的知识单元，各规则之间只能通过总数据库发生联系，而不能相互调用，从而增加了规则的模块性。</li><li>有效性：产生式知识表示法既可以表示确定性知识，又可以表示不确定性知识，既有利于表示启发性知识，又有利于表示过程性知识。</li></ul></li><li>缺点：<ul><li>效率较低：各规则之间的联系必须以总数据库为媒介。并且，其求解过程是一种反复进行的“匹配—冲突消解—执行”过程。这样的执行方式将导致执行的低效率。</li><li>不便于表示结构性知识：由于产生式表示中的知识具有一致格式，且规则之间不能相互调用，因此那种具有结构关系或层次关系的知识则很难以自然的方式来表示。</li></ul></li></ul><h2 id="非经典推理"><a href="#非经典推理" class="headerlink" title="非经典推理"></a>非经典推理</h2><h3 id="经典推理和非经典推理"><a href="#经典推理和非经典推理" class="headerlink" title="经典推理和非经典推理"></a>经典推理和非经典推理</h3><h4 id="非经典推理-1"><a href="#非经典推理-1" class="headerlink" title="非经典推理"></a>非经典推理</h4><p>现实世界中的大多数问题存在随机性、模糊性、不完全性和不精确性。对于这些问题，若采用前面所讨论的精确性推理方法显然是无法解决的。<br>为此，出现了一些新的逻辑学派，称为非经典逻辑，相应的推理方法称为 <strong>非经典推理</strong>。包括非单调性推理、不确定性推理、概率推理和贝叶斯推理等。</p><h4 id="非经典逻辑推理与经典逻辑推理的区别"><a href="#非经典逻辑推理与经典逻辑推理的区别" class="headerlink" title="非经典逻辑推理与经典逻辑推理的区别"></a>非经典逻辑推理与经典逻辑推理的区别</h4><ul><li>在推理方法上，经典逻辑采用演绎逻辑推理，非经典逻辑采用归纳推理。</li><li>在辖域取值上，经典逻辑是二值逻辑，非经典逻辑是多值逻辑。</li><li>在运算法则上，两者大不相同。</li><li>在逻辑运算符上，非经典逻辑有更多的逻辑运算符。</li><li>在单调性上，经典逻辑是单调的，即已知事实均为充分可信的，不会随着新事实的出现而使原有事实变为假。非经典逻辑是非单调的。</li></ul><h3 id="不确定性推理"><a href="#不确定性推理" class="headerlink" title="不确定性推理"></a>不确定性推理</h3><h4 id="不确定性推理的概念"><a href="#不确定性推理的概念" class="headerlink" title="不确定性推理的概念"></a>不确定性推理的概念</h4><ul><li>不确定性推理是建立在非经典逻辑基础上的一种推理，它是对不确定性知识的运用与处理。</li><li>不确定性推理泛指除精确推理以外的其它各种推理问题。包括不完备、不精确知识的推理，模糊知识的推理，非单调性推理等。</li><li>不确定性推理从不确定性的初始证据（即事实）出发，通过运用不确定性的知识，最终推出具有一定程度不确定性的结论。</li></ul><h4 id="为什么要采用不确定性推理"><a href="#为什么要采用不确定性推理" class="headerlink" title="为什么要采用不确定性推理"></a>为什么要采用不确定性推理</h4><ul><li>所需知识不完备或问题的背景知识不足</li><li>所需知识描述不精确或模糊</li><li>多种原因导致同一结论或解题方案不唯一</li></ul><h4 id="不确定性推理的基本问题"><a href="#不确定性推理的基本问题" class="headerlink" title="不确定性推理的基本问题"></a>不确定性推理的基本问题</h4><ol><li>不确定性的表示</li><li>不确定性的匹配</li><li>组合证据的不确定性的计算</li><li>不确定性的更新</li><li>不确定性结论的合成</li></ol><h4 id="知识的不确定性的表示"><a href="#知识的不确定性的表示" class="headerlink" title="知识的不确定性的表示"></a>知识的不确定性的表示</h4><ul><li>考虑因素：1. 问题描述能力; 2. 推理中不确定性的计算</li><li>含义：知识的确定性程度，或静态强度</li><li>表示：<ul><li>概率，[0,1]，0接近于假，1接近于真</li><li>可信度，[-1,1]，大于0接近于真，小于0接近于假</li></ul></li></ul><h4 id="证据的非精确性表示"><a href="#证据的非精确性表示" class="headerlink" title="证据的非精确性表示"></a>证据的非精确性表示</h4><ul><li>证据来源：初始证据，中间结论</li><li>表示：用概率或可信度</li></ul><h4 id="不确定性的匹配"><a href="#不确定性的匹配" class="headerlink" title="不确定性的匹配"></a>不确定性的匹配</h4><ul><li>含义：不确定的前提条件与不确定的事实匹配</li><li>问题：前提是不确定的，事实也是不确定的</li><li>方法：设计一个计算相似程度的算法，给出相似的限度</li><li>标志：相似度落在规定限度内为匹配，否则为不匹配</li></ul><h4 id="组合证据不确定性的计算"><a href="#组合证据不确定性的计算" class="headerlink" title="组合证据不确定性的计算"></a>组合证据不确定性的计算</h4><ul><li>含义：知识的前提条件是多个证据的组合</li><li>方法：<strong>T(E)表示证据E为真的程度</strong><ul><li>最大最小法：<br><code>T(E1 AND E2)=min{T(E1),T(E2)}</code><br><code>T(E1 OR E2)=max{T(E1),T(E2)}</code></li><li>概率法：在事件之间完全独立时使用<br><code>T(E1 AND E2)=T(E1)T(E2)</code><br><code>T(E1 OR E2)=T(E1)＋T(E2)－T(E1)T(E2)</code></li><li>有界法：<br><code>T(E1 AND E2)=max{0,T(E1)＋T(E2)－1}</code><br><code>T(E1 OR E2)=min{1,T(E1)＋T(E2)}</code></li></ul></li></ul><h4 id="不确定性的更新"><a href="#不确定性的更新" class="headerlink" title="不确定性的更新"></a>不确定性的更新</h4><ul><li>主要问题：解决不确定性知识在推理的过程中，知识不确定性的累积和传递。</li><li>解决方法<ul><li>已知规则前提证据E的不确定性<code>T(E)</code>和规则的强度<code>F(E,H)</code>，则结论H的不确定性：<code>T(H) = g1[T(E),F(E,H)]</code></li><li>证据合取： <code>T(E1 AND E2) = g2[T(E1), T (E2)]</code></li><li>证据析取： <code>T(E1   OR  E2) = g3[T(E1), T (E2)]</code></li></ul></li></ul><h4 id="不确定性结论的合成"><a href="#不确定性结论的合成" class="headerlink" title="不确定性结论的合成"></a>不确定性结论的合成</h4><ul><li>主要问题：多个不同知识推出同一结论，且不确定性程度不同</li><li>解决方法：<ul><li>并行规则算法：根据独立证据E1和E2分别求得结论H的不确定性为<code>T1(H)</code>和<code>T2(H)</code>，则证据E1和E2的组合导致结论H的不确定性：<code>T(H)=g[T1(H), T2(H)]</code></li><li>函数g视不同推理方法而定</li></ul></li></ul><h3 id="概率推理"><a href="#概率推理" class="headerlink" title="概率推理"></a>概率推理</h3><h4 id="概率论基础回顾"><a href="#概率论基础回顾" class="headerlink" title="概率论基础回顾"></a>概率论基础回顾</h4><ul><li><a href="https://baike.baidu.com/item/%E5%85%A8%E6%A6%82%E7%8E%87%E5%85%AC%E5%BC%8F" target="_blank" rel="noopener">全概率公式</a></li><li><a href="https://baike.baidu.com/item/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%85%AC%E5%BC%8F/9683982" target="_blank" rel="noopener">贝叶斯(Bayes)公式</a></li></ul><h4 id="概率推理方法"><a href="#概率推理方法" class="headerlink" title="概率推理方法"></a>概率推理方法</h4><ul><li>设有如下产生式规则：IF  E   THEN   H<ul><li>其中，E为前提条件，H为结论。</li><li>条件概率P(H|E)可以作为在证据E出现时结论H的确定性程度，即规则的静态强度。</li></ul></li><li>把贝叶斯方法用于不精确推理的思想<ul><li>已知前提E的概率P(E)和结论H的先验概率P(H)</li><li>已知H成立时E出现的条件概率P(E|H)</li><li>利用规则推出H在E出现的条件下的后验概率：<br><img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E5%85%AC%E5%BC%8F.jpg" alt=""></li></ul></li><li>对于一组产生式规则：IF  E   THEN  Hi<ul><li>一个前提条件E支持多个结论H1, H2, …,Hn</li><li>同样有后验概率如下（ Hi 确定性的程度，或规则的静态强度）：<br><img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E5%85%AC%E5%BC%8F2.jpg" alt=""></li></ul></li><li>对于有多个证据E1, E2, …, Em和多个结论H1, H2, …, Hn,并且每个证据都以一定程度支持结论的情况，上面的式子可进一步扩展为:<br>  <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E5%85%AC%E5%BC%8F3.jpg" alt=""></li></ul><hr><p>【例子】<br>设H1,H2,H3分别是三个结论，E是支持这些结论的证据。已知：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">P</span><span class="params">(H1)</span></span>=<span class="number">0.3</span></span><br><span class="line"><span class="function"><span class="title">P</span><span class="params">(H2)</span></span>=<span class="number">0.4</span></span><br><span class="line"><span class="function"><span class="title">P</span><span class="params">(H3)</span></span>=<span class="number">0.5</span></span><br><span class="line"><span class="function"><span class="title">P</span><span class="params">(E|H1)</span></span>=<span class="number">0.5</span></span><br><span class="line"><span class="function"><span class="title">P</span><span class="params">(E|H2)</span></span>=<span class="number">0.3</span></span><br><span class="line"><span class="function"><span class="title">P</span><span class="params">(E|H3)</span></span>=<span class="number">0.4</span></span><br></pre></td></tr></table></figure></p><p>求P(H1|E),P(H2|E)及P(H3|E)的值各是多少？</p><p>解：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E5%85%AC%E5%BC%8F4.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>同理可得：<br>P(H2|E)=0.26<br>P(H3|E)=0.43<br>观察：( 注：P(E)=0.47 )<br>P(H1)=0.3 , P(E|H1)=0.5     P(H1|E)=0.32<br>P(H2)=0.4 , P(E|H2)=0.3     P(H2|E)=0.26<br>P(H3)=0.5 , P(E|H3)=0.4     P(H3|E)=0.43<br>结论：由于E的出现，H1成立的可能性增加，H2和H3成立的可能性不同程度的下降。</p><hr><h4 id="概率推理方法的特点"><a href="#概率推理方法的特点" class="headerlink" title="概率推理方法的特点"></a>概率推理方法的特点</h4><ul><li>优点：<ul><li>概率推理方法有较强的理论背景和良好的数学特性，当证据彼此独立时计算的复杂度比较低。</li></ul></li><li>缺点：<ul><li>概率推理方法要求给出结论Hi的先验概率P(Hi)及条件概率 P(Ej|Hi)。</li></ul></li></ul><h3 id="贝叶斯推理（主观贝叶斯方法）"><a href="#贝叶斯推理（主观贝叶斯方法）" class="headerlink" title="贝叶斯推理（主观贝叶斯方法）"></a>贝叶斯推理（主观贝叶斯方法）</h3><blockquote><p>使用概率推理方法求结论Hi在存在证据E时的条件概率P(Hi|E) ，需要给出结论Hi的先验概率P(Hi)及证据E的条件概率 P(E|Hi)。这对于实际应用是不容易做到的。<br>Duda 和 Hart 等人在贝叶斯公式的基础上，于1976年提出主观贝叶斯方法，建立了不精确推理的模型，并把它成功地应用于PROSPECTOR专家系统（PROSPECTOR是国际上著名的一个用于勘察固体矿的专家系统）。</p></blockquote><h4 id="主观贝叶斯方法-ppt-24"><a href="#主观贝叶斯方法-ppt-24" class="headerlink" title="主观贝叶斯方法(ppt-24)"></a>主观贝叶斯方法(ppt-24)</h4><ul><li><p>知识不确定性的表示</p><ul><li>在主观Bayes方法中，知识是用产生式表示的，其形式为：<br><code>IF  E  THEN  (LS, LN)   H</code> </li><li>E表示规则前提条件，它既可以是一个简单条件，也可以是用AND或OR把多个简单条件连接起来的复合条件。</li><li><p>H是结论，用P(H)表示H的先验概率，它指出没有任何专门证据的情况下结论H为真的概率，其值由领域专家根据以往的实践经验给出。</p></li><li><p>LS是规则的充分性度量。用于指出E对H的支持程度，取值范围为[0,+∞)，其定义为：<br><img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E5%85%AC%E5%BC%8F5.jpg" alt=""></p></li><li>LN是规则的必要性度量。用于指出E对H为真的必要程度，即﹁E对对H的支持程度。取值范围为[0,+∞)，其定义为：<br><img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E5%85%AC%E5%BC%8F6.jpg" alt=""></li></ul></li><li>证据不确定性的表示</li><li>组合证据不确定性的计算</li><li>不确定性的更新</li><li>主观贝叶斯方法的推理过程</li></ul><h3 id="可信度方法"><a href="#可信度方法" class="headerlink" title="可信度方法"></a>可信度方法</h3><blockquote><p>什么是可信度</p></blockquote><ul><li>可信度是指人们根据以往经验对某个事物或现象为真的程度的一个判断，或者说是人们对某个事物或现象为真的相信程度。</li><li>在可信度方法中，由专家给出规则或知识的可信度，从而 <strong>避免对先验概率、条件概率的要求</strong>。</li><li>可信度方法是肖特里菲（Shortliffe）等人在确定性理论基础上结合概率论等理论提出的一种不精确推理模型。</li></ul><p>该方法 <strong>直观</strong>、<strong>简单</strong>而且 <strong>效果好</strong>，在专家系统等领域获得了较为广泛的应用。</p><blockquote><p>C-F模型</p></blockquote><p>C-F模型：基于可信度表示的不确定性推理的基本方法，其他可信度方法都是基于此发展而来。</p><blockquote><p>知识的不确定性表示</p></blockquote><p>知识的不确定性表示：在C-F模型中，知识是用产生式规则表示的，其一般形式为：<br>                 <code>IF   E   THEN   H (CF(H, E))</code><br><code>E</code>：知识的前提条件，可以是单一或复合条件；<br><code>H</code>：知识的结论，可以是单一结论或多个结论；<br><code>CF(H, E)</code>：知识的可信度，称为 <strong>可信度因子</strong>(Certainty Factor)或规则强度。</p><p>一般情况下，CF(H, E)的取值为[-1, 1]，表示当证据E为真时，对结论H的支持程度。其值越大，表示支持程度越大。</p><ul><li>CF(H,E)&gt;0对应于P(H|E)&gt;P(H)；</li><li>CF(H,E)=0对应于P(H|E)=P(H)；</li><li>CF(H,E)&lt;0对应于P(H|E)&lt;P(H)。</li></ul><p>例如：<code>IF   发烧  AND  流鼻涕   THEN   感冒(0.7)</code>，表示当某人确实有“发烧”及“流鼻涕”症状时，则有七成的把握是患了感冒。</p><blockquote><p>CF(H,E)的定义:</p></blockquote><p><code>CF(H,E) = MB(H,E) - MD(H,E)</code></p><ul><li>MB ( Measure Belief ) 称为信任增长度，反映了证据对结论有利的一面。MB(H, E)定义为：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E5%85%AC%E5%BC%8F7.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li><li>MD ( Measure Disbelief ) 称为不信任增长度，MD反映了证据对结论不利的一面。MD(H,E)定义为：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E5%85%AC%E5%BC%8F8.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ul><blockquote><p>MB和MD的关系：</p></blockquote><ul><li>当<code>P(H|E)&gt;P(H)</code>时： E的出现增加了H的概率<br><code>MB(H,E)&gt;0，MD(H,E)=0</code> </li><li>当<code>P(H|E)&lt;P(H)</code>时： E的出现降低了H的概率<br><code>MB(H,E) =0，MD(H,E)&gt;0</code><br>因此，CF(H, E)的计算公式：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E5%85%AC%E5%BC%8F9.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ul><blockquote><p>可信度的性质(ppt-25)</p></blockquote><ul><li>互斥性：对同一证据，不可能既增加对H的信任程度，又同时增加对H的不信任程度，即MB与MD是互斥的<ul><li>当MB(H, E)&gt;0时，MD(H, E)=0</li><li>当MD(H, E)&gt;0时，MB(H, E)=0</li></ul></li><li>值域：MB(H, E) ∈ [0,1]; MD(H, E) ∈ [0,1]; CF(H, E) ∈[-1,1],<ul><li>当且仅当P(H|E)=1时,  CF(H,E)=1 </li><li>当且仅当P(H|E)=0时,  CF(H,E)=-1</li><li>CF(H,E)定性地反映了P(H|E)的大小，因此可以用CF(H,E)近似表示P(H|E) ，描述规则的可信度。</li></ul></li><li>对H的信任增长度等于对非H的不信任增长度<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E5%85%AC%E5%BC%8F10.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li><li>再根据CF的定义和MB、MD的互斥性有<br><code>CF(H,E)+CF(﹁H,E)=0</code></li><li>对前提E，若支持若干个不同的结论Hi(i=1,2,…,n)，则</li><li>因此，如果发现专家给出的知识有如下情况<br><code>CF(H1, E)=0.7,  CF(H2, E)=0.4</code></li><li>则因0.7+0.4=1.1&gt;1为非法，应进行调整或规范化。</li></ul><blockquote><p>证据不确定性的表示</p></blockquote><ul><li>证据的E不确定性也用可信度因子CF(E)表示</li><li>CF(E)的取值范围：[-1，+1]。 <ul><li>CF(E)=1，证据E肯定它为真</li><li>CF(E)=-1，证据E肯定它为假</li><li>CF(E)=0，对证据E一无所知</li><li>0&lt;CF(E)&lt;1，证据E以CF(E)程度为真</li><li>-1&lt;CF(E)&lt;0，证据E以CF(E)程度为假</li></ul></li></ul><blockquote><p>否定证据的不确定性计算</p></blockquote><p><code>CF(¬E)=－CF(E)</code></p><blockquote><p>组合证据的不确定性计算</p></blockquote><ul><li>可采用最大最小法<ul><li>当组合证据E是多个单一证据的合取时，若已知<code>CF(E1), …, CF(En)</code>，则:<br><code>CF(E)=min{CF(E1), CF(E2), … ,CF(En)}</code></li><li>当组合证据E是多个单一证据的析取时，若已知<code>CF(E1), …, CF(En)</code>，则:<br><code>CF(E)=max{CF(E1), CF(E2), … ,CF(En)}</code> </li></ul></li></ul><blockquote><p>不确定性的更新</p></blockquote><p><code>IF   E   THEN   H  (CF(H, E))</code></p><blockquote><p>结论H的可信度由下式计算：  </p></blockquote><p><code>CF(H)=CF(H,E)×max{0,CF(E)}</code></p><ul><li>CF(H)的取值范围：[-1，+1]。 <ul><li>CF(H)=0: CF(E)&lt;0,即该模型没考虑E为假对H的影响</li><li>CF(H)&gt;0: 表示结论以某种程度为真</li><li>CF(H)&lt;0: 表示结论以某种程度为假</li></ul></li></ul><blockquote><p>结论不确定性的合成</p></blockquote><ul><li>若由多条不同知识推出了相同的结论，但可信度不同，则用合成算法求出综合可信度。设有知识：<br><code>IF  E1   THEN   H  (CF(H, E1))</code><br><code>IF  E2   THEN   H  (CF(H, E2))</code></li><li>则结论H 的综合可信度可分以下两步计算：<br>(1)、分别对每条知识求出其CF(H)。即<br><code>CF1(H)=CF(H, E1) ×max{0, CF(E1)}</code><br><code>CF2(H)=CF(H, E2) ×max{0, CF(E2)}</code></li></ul><p>(2)、用如下公式求E1与E2对H的综合可信度<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E5%85%AC%E5%BC%8F11.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><hr><p>【例子】<br>设有如下一组知识：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r1：<span class="keyword">IF</span>  E1  <span class="keyword">THEN</span>  H  (<span class="number">0.9</span>)</span><br><span class="line">r2：<span class="keyword">IF</span>  E2  <span class="keyword">THEN</span>  H  (<span class="number">0.6</span>)</span><br><span class="line">r3：<span class="keyword">IF</span>  E3  <span class="keyword">THEN</span>  H  (-<span class="number">0.5</span>)</span><br><span class="line">r4：<span class="keyword">IF</span>  E4  <span class="keyword">AND</span>  ( E5  <span class="keyword">OR</span>  E6)  <span class="keyword">THEN</span>  E1  (<span class="number">0.8</span>)</span><br></pre></td></tr></table></figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E5%8F%AF%E4%BF%A1%E5%BA%A6%E4%BE%8B%E5%AD%90.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>已知：<code>CF(E2)=0.8</code>，<code>CF(E3)=0.6</code>，<code>CF(E4)=0.5</code>，<code>CF(E5)=0.6</code>,<code>CF(E6)=0.8</code>，求：<code>CF(H)</code>。</p><p>解：由r4得到：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> CF(E1) = <span class="number">0.8</span>×max&#123;<span class="number">0</span>, CF(E4  AND  (E5  OR   E6))&#125;</span><br><span class="line">        = <span class="number">0.8</span>×max&#123;<span class="number">0</span>, min&#123;CF(E4),  CF(E5  OR   E6)&#125;&#125; </span><br><span class="line">        = <span class="number">0.8</span>×max&#123;<span class="number">0</span>, min&#123;CF(E4),  max&#123;CF(E5),  CF(E6)&#125;&#125;&#125;</span><br><span class="line">        = <span class="number">0.8</span>×max&#123;<span class="number">0</span>, min&#123;CF(E4),  max&#123;<span class="number">0.6</span>,  <span class="number">0.8</span>&#125;&#125;&#125;</span><br><span class="line">        = <span class="number">0.8</span>×max&#123;<span class="number">0</span>, min&#123;<span class="number">0.5</span>,  <span class="number">0.8</span>&#125;&#125;</span><br><span class="line">        = <span class="number">0.8</span>×max&#123;<span class="number">0</span>,  <span class="number">0.5</span>&#125; </span><br><span class="line">        = <span class="number">0.4</span> </span><br><span class="line"> 由r1得到：</span><br><span class="line">    CF1(H) = CF(H, E1)×max&#123;<span class="number">0</span>,  CF(E1)&#125;</span><br><span class="line">           = <span class="number">0.9</span>×max&#123;<span class="number">0</span>,  <span class="number">0.4</span>&#125; </span><br><span class="line">           = <span class="number">0.36</span></span><br><span class="line"></span><br><span class="line"> 由r2得到：</span><br><span class="line">    CF2(H) = CF(H, E2)×max&#123; <span class="number">0</span>,  CF(E2) &#125;</span><br><span class="line">      　   = <span class="number">0.6</span>×max&#123; <span class="number">0</span>,  <span class="number">0.8</span> &#125; </span><br><span class="line">           = <span class="number">0.48</span></span><br><span class="line">由r3得到：</span><br><span class="line">    CF3(H) = CF(H, E3)×max&#123; <span class="number">0</span>,  CF(E3) &#125;</span><br><span class="line">      　   = <span class="number">-0.5</span>×max&#123; <span class="number">0</span>,  <span class="number">0.6</span> &#125; </span><br><span class="line">      　   = <span class="number">-0.3</span></span><br></pre></td></tr></table></figure></p><p>根据结论不精确性的合成算法，CF1(H)和CF2(H)同号，有：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E5%85%AC%E5%BC%8F12.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>CF12(H)和CF3(H)异号，有：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E5%85%AC%E5%BC%8F13.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>综合可信度为CF(H)=0.53。</p><hr><h3 id="证据理论-ppt-25-21"><a href="#证据理论-ppt-25-21" class="headerlink" title="证据理论(ppt-25-21)"></a>证据理论(ppt-25-21)</h3><h2 id="专家系统"><a href="#专家系统" class="headerlink" title="专家系统"></a>专家系统</h2><blockquote><p>专家系统的先行者费根鲍姆（Feigenbaum）曾把专家系统定义为一个应用知识和推理过程来求解那些需要大量的人类专家解决难题经验的智能计算机程序。<br>专家系统主要指的是一个智能计算机程序系统，其内部含有大量的某个领域专家水平的知识与经验，能够利用人类专家的知识和解决问题的经验方法来处理该领域的高水平难题。</p></blockquote><h3 id="专家系统概述"><a href="#专家系统概述" class="headerlink" title="专家系统概述"></a>专家系统概述</h3><ul><li>专家系统是一个具有大量的专门知识与经验的程序系统，它应用人工智能技术和计算机技术，根据某领域一个或多个专家提供的知识和经验，进行推理和判断，模拟人类专家的决策过程，以便解决那些需要人类专家才能处理好的复杂问题。简而言之，专家系统是一种模拟人类专家解决领域问题的计算机程序系统。</li><li>专家系统的基本功能取决于它所含有的知识，因此，有时也把专家系统称为基于知识的系统（knowledge-based system）。</li></ul><h4 id="专家系统的特点"><a href="#专家系统的特点" class="headerlink" title="专家系统的特点"></a>专家系统的特点</h4><ul><li>启发性<ul><li>专家系统要解决的问题，其结构往往是不合理的，其问题求解（problem-solving）知识不仅包括理论知识和常识，而且包括专家本人的启发知识。</li><li>能运用专家的知识和经验进行推理、判断和决策。</li></ul></li><li>透明性<ul><li>专家系统能够解释本身的推理过程和回答用户提出的问题，以便让用户了解推理过程，提高对专家系统的信赖感。</li><li>问题求解过程中知识应用的合理性可由检验专家系统的解释推理路径来验证。</li></ul></li><li>灵活性<ul><li>专家系统的灵活性是指它的扩展和丰富知识库的能力，以及改善非编程状态下的系统性能，即自学习能力。</li><li>专家系统能不断增长知识，修改原有知识，不断更新</li></ul></li></ul><h4 id="专家系统的优点"><a href="#专家系统的优点" class="headerlink" title="专家系统的优点"></a>专家系统的优点</h4><ul><li>专家系统能够高效率、准确、周到、迅速和不知疲倦地进行工作。</li><li>专家系统解决实际问题时不受周围环境的影响，也不可能遗漏和忘记。</li><li>可以使专家的专长不受时间和空间的限制，以便推广珍贵和稀缺的专家知识与经验。</li><li>专家系统能促进各领域的发展，使各领域专家的专业知识和经验得到总结和精炼，能够广泛有力地传播专家的知识、经验和能力。</li><li>专家系统能汇集多领域专家的知识和经验以及他们协作解决重大问题的能力，它拥有更渊博的知识、更丰富的经验和更强的工作能力。</li><li>军事专家系统的水平是一个国家国防现代化的重要标志之一。</li><li>专家系统的研制和应用，具有巨大的经济效益和社会效益。</li><li>研究专家系统能够促进整个科学技术的发展。专家系统对人工智能各个领域的发展起了很大的促进作用，并将对科技、经济、国防、教育、社会和人民生活产生极其深远的影响。</li></ul><h4 id="专家系统的结构"><a href="#专家系统的结构" class="headerlink" title="专家系统的结构"></a>专家系统的结构</h4><ul><li>专家系统简化结构图<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E4%B8%93%E5%AE%B61.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li><li>理想专家系统的结构图<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E4%B8%93%E5%AE%B62.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li><li>专家系统的主要组成部分：<ul><li>知识库</li><li>综合数据库</li><li>推理机</li><li>解释器</li><li>接口</li></ul></li></ul><h4 id="专家系统的建造步骤"><a href="#专家系统的建造步骤" class="headerlink" title="专家系统的建造步骤"></a>专家系统的建造步骤</h4><ul><li>设计初始知识库<ul><li>问题知识化</li><li>知识概念化</li><li>概念形式化</li><li>形式规则化</li><li>规则合法化</li></ul></li><li>原型机（prototype）的开发与实验</li><li>知识库的改进与归纳<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E4%B8%93%E5%AE%B63.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ul><h3 id="基于规则的专家系统基于框架的专家系统"><a href="#基于规则的专家系统基于框架的专家系统" class="headerlink" title="基于规则的专家系统基于框架的专家系统"></a>基于规则的专家系统基于框架的专家系统</h3><p>一个基于规则的专家系统采用下列模块来建立产生式系统的模型：</p><ol><li>知识库：以一套规则建立人的长期存储器模型。</li><li>工作存储器：建立人的短期存储器模型，存放问题事实和由规则激发而推断出的新事实。</li><li>推理机：借助于把存放在工作存储器内的问题事实和存放在知识库内的规则结合起来，建立人的推理模型，以推断出新的信息 。</li></ol><h3 id="基于框架的专家系统"><a href="#基于框架的专家系统" class="headerlink" title="基于框架的专家系统"></a>基于框架的专家系统</h3><ul><li>基于框架的专家系统是一个计算机程序，该程序使用一组包含在知识库内的框架对工作存储器内的具体问题信息进行处理，通过推理机推断出新的信息。</li><li>基于框架的专家系统是建立在框架的基础之上的。一般概念存放在框架内，而该概念的一些特例则被表示在其他框架内并含有实际的特征值。</li><li>基于框架的专家系统能够提供基于规则专家系统所没有的特征，如继承、侧面、信息通信和模式匹配规则等，因而，基于框架的专家系统比基于规则的专家系统拥有更强的功能，适用于解决更复杂的问题。</li></ul><h3 id="基于模型的专家系统"><a href="#基于模型的专家系统" class="headerlink" title="基于模型的专家系统"></a>基于模型的专家系统</h3><ul><li>关于人工智能的一个观点:  认为人工智能是对各种定性模型（物理的、感知的、认识的和社会的系统模型）的获得、表达及使用的计算方法进行研究的学问。一个知识系统中的知识库是由各种模型综合而成的。</li><li>模型类型：基于逻辑的心理模型、定性的物理模型、神经元网络模型、可视知识模型等等。</li><li>综合各种模型的专家系统比基于逻辑心理模型的系统具有更强的功能，从而有可能显著改进专家系统的设计</li><li>在诸多模型中，人工神经网络模型的应用最为广泛</li></ul><h3 id="基于Web的专家系统"><a href="#基于Web的专家系统" class="headerlink" title="基于Web的专家系统"></a>基于Web的专家系统</h3><h3 id="新型专家系统"><a href="#新型专家系统" class="headerlink" title="新型专家系统"></a>新型专家系统</h3><p>以上部分专家系统就不详叙了。</p><hr><h2 id="模糊逻辑系统"><a href="#模糊逻辑系统" class="headerlink" title="模糊逻辑系统"></a>模糊逻辑系统</h2><h3 id="模糊逻辑原理"><a href="#模糊逻辑原理" class="headerlink" title="模糊逻辑原理"></a>模糊逻辑原理</h3><p>模糊逻辑的发展，是由理论准备到理论提出再到理论应用的过程<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%A8%A1%E7%B3%8A1.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="模糊集"><a href="#模糊集" class="headerlink" title="模糊集"></a>模糊集</h3><ul><li>从精确到模糊<ul><li>精确<ul><li>答案确定：要么是，要么不是</li><li><code>f : A → {0,1}</code></li><li>如：他是学生？不是学生？</li></ul></li><li>模糊<ul><li>答案不定：也许是，也许不是，也许介于之间</li><li><code>μA : U → [0,1]</code></li><li>如：他是成年人？不是成年人？大概是成年人？</li></ul></li></ul></li></ul><hr><p>【例子】表示“20岁左右”</p><ul><li>原集合（年龄）<ul><li>{…., 17, 18, 19, 20, 21, 22, 23, …}</li></ul></li><li>模糊集可以表示为：<ul><li>0.8/18 + 0.9/19 + 1/20 + 0.9/21 + 0.8/12</li><li>0.6/17+0.7/18+0.8/19+1/20+0.9/21+0.7/22+0.6/23</li></ul></li></ul><hr><h4 id="集合及其特征函数"><a href="#集合及其特征函数" class="headerlink" title="集合及其特征函数"></a>集合及其特征函数</h4><ul><li>在论域中，把具有某种属性的事物的全体称为集合。由于集合中的元素都具有某种属性，因此可以用集合表示某一种概念，而且可用一个函数来刻画它，该函数称为特征函数。</li><li>设A是论域U上的一个集合，对任意u∈U，令<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%A8%A1%E7%B3%8A2.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li><li>则称CA(u)为集合A的特征函数。特征函数CA(u)在u=u0处的取值CA(u0)称为u0对A的隶属度。</li><li>集合A与其特征函数可以认为是等价的：A={u |CA(u)=1}</li></ul><h4 id="模糊集与隶属函数"><a href="#模糊集与隶属函数" class="headerlink" title="模糊集与隶属函数"></a>模糊集与隶属函数</h4><ul><li>模糊集把特征函数的取值范围从{0,1}推广到[0,1]上。</li><li>设U是论域，μA是把任意u∈U映射为[0,1]上某个值的函数，即<br><code>μA : U→[0,1]   或   u→μA(u)</code></li><li>则称μA为定义在U上的一个隶属函数，由μA(u)(u∈U)所构成的集合A称为U上的一个模糊集，μA(u)称为u对A的隶属度。</li></ul><hr><p>【例子】<br>论域U={1,2,3,4,5}，用模糊集表示“大”和“小”。</p><p>解：设A、B分别表示“大”与“小”的模糊集，μA ，μB分别为相应的隶属函数。<br><code>A = {0, 0, 0.1, 0.6, 1}</code><br><code>B = {1, 0.5, 0.01, 0, 0}</code><br>其中：<br><code>μA(1)=0, μA(2)=0 , μA(3)=0.1 , μA(4)=0.6 , μA(5)=1</code><br><code>μB(1)=1, μB(2)=0.5 , μB(3)=0.01 , μB(4)=0, μB(5)=0</code></p><hr><h4 id="模糊集的表示方法"><a href="#模糊集的表示方法" class="headerlink" title="模糊集的表示方法"></a>模糊集的表示方法</h4><p>(1)、论域离散且为有限<br>若论域 U={u1, … , un}为离散论域，模糊集A表示为：<br><code>A= {μA(u1), μA(u2), … ,  μA(un)}</code><br>也可写为：<br><code>A= μA(u1)/u1 + μA(u2)/u2 + … + μA(un)/un</code><br>其中，隶属度为0的元素可以不写。</p><p>例如：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">1</span>/u1+<span class="number">0.7</span>/u2+<span class="number">0</span>/u3+<span class="number">0.4</span>/u4</span><br><span class="line">  = <span class="number">1</span>/u1+<span class="number">0.7</span>/u2+<span class="number">0.4</span>/u4</span><br></pre></td></tr></table></figure></p><p>(2)、论域连续<br>若论域是连续的，则模糊集可用实函数表示。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%A8%A1%E7%B3%8A3.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>例如：以年龄为论域U=[0,100]， “年轻”和“年老”这两个概念可表示为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%A8%A1%E7%B3%8A%E4%BE%8B%E5%AD%90.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>(3)、一般表示方法<br>不管论域 U 是有限的还是无限的，是连续的亦或是离散的，扎德（ L. A. Zadeh ）又给出了一种类似于积分的一般表示形式：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%A8%A1%E7%B3%8A8.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这里的记号不是数学中的积分符号，也不是求和，只是表示论域中各元素与其隶属度对应关系的总括。</p><h4 id="模糊集的运算"><a href="#模糊集的运算" class="headerlink" title="模糊集的运算"></a>模糊集的运算</h4><ul><li>模糊集的包含运算<ul><li>设A、B分别是U 上的两个模糊集，对任意u∈U，都有 μB(u) ≤ μA(u) 成立，则称A包含B，记为B     A。</li></ul></li><li>模糊集的交、并、补运算<ul><li>设A、B分别是U上的两个模糊集，则A和B两个集合的并集A∪B、交集A∩B和A的补集﹁A的隶属函数分别为： <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%A8%A1%E7%B3%8A9.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ul></li></ul><hr><p>【例子】<br>设U={u1,u2,u3}，<br>A=0.3/u1+0.8/u2+0.6/u3;    B=0.6/u1+0.4/u2+0.7/u3<br>求A∩B，A∪B和¬A。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A∩B = (<span class="number">0.3</span>∧<span class="number">0.6</span>)/u1+(<span class="number">0.8</span>∧<span class="number">0.4</span>)/u2+(<span class="number">0.6</span>∧<span class="number">0.7</span>)/u3</span><br><span class="line">    = <span class="number">0.3</span>/u1+<span class="number">0.4</span>/u2+<span class="number">0.6</span>/u3</span><br><span class="line">A∪B = (<span class="number">0.3</span>∨<span class="number">0.6</span>)/u1+(<span class="number">0.8</span>∨<span class="number">0.4</span>)/u2+(<span class="number">0.6</span>∨<span class="number">0.7</span>)/u3</span><br><span class="line">    = <span class="number">0.6</span>/u1+<span class="number">0.8</span>/u2+<span class="number">0.7</span>/u3</span><br><span class="line">¬A  = (<span class="number">1</span><span class="number">-0.3</span>)/u1+(<span class="number">1</span><span class="number">-0.8</span>)/u2+(<span class="number">1</span><span class="number">-0.6</span>)/u3</span><br><span class="line">    = <span class="number">0.7</span>/u1+<span class="number">0.2</span>/u2+<span class="number">0.4</span>/u3</span><br></pre></td></tr></table></figure></p><hr><h3 id="模糊关系"><a href="#模糊关系" class="headerlink" title="模糊关系"></a>模糊关系</h3><h4 id="模糊关系的定义"><a href="#模糊关系的定义" class="headerlink" title="模糊关系的定义"></a>模糊关系的定义</h4><ul><li><p>设 Ai 是 Ui (i=1,2,…,n) 上的模糊集，则称<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%A8%A1%E7%B3%8A4.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>为A1, A2, …, An的笛卡尔乘积，它是U1×U2×…×Un上的一个模糊集。 </p></li><li><p>在U1×…×Un上一个n元模糊关系R是指以U1×…×Un为论域的一个模糊集，记为:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%A8%A1%E7%B3%8A5.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ul><p>一般地说，当U和V都是有限论域时，<code>U={u1,u2,…,um}</code>，<code>V={v1,v2,…,vn}</code>，则U×V上的模糊关系R可用一个模糊矩阵表示<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%A8%A1%E7%B3%8A6.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h5 id="模糊关系的合成"><a href="#模糊关系的合成" class="headerlink" title="模糊关系的合成"></a>模糊关系的合成</h5><ul><li>设R1与R2分别是U×V与V×W上的两个模糊关系，则R1与R2的合成是指从U到W的一个模糊关系，记为<code>R1°R2</code></li><li>其隶属函数为<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%A8%A1%E7%B3%8A7.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li><li>隶属函数计算方法：取R1的第 i 行元素分别与R2的第 j 列元素相比较，两个数中取其小者，然后再在所得的一组最小数中取最大的一个，以此作为R1°R2的第 i 行第 j 列的元素。</li></ul><hr><p>【例子】<br>设有两个模糊关系<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%A8%A1%E7%B3%8A%E4%BE%8B%E5%AD%901.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>则R1与R2的合成是<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%A8%A1%E7%B3%8A%E4%BE%8B%E5%AD%902.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><hr><h3 id="模糊变换"><a href="#模糊变换" class="headerlink" title="模糊变换"></a>模糊变换</h3><h4 id="模糊变换的概念"><a href="#模糊变换的概念" class="headerlink" title="模糊变换的概念"></a>模糊变换的概念</h4><p>设<code>A={μA(u1),μA(u2),…,μA(un)}</code>是论域U上的模糊集，R是<code>U×V</code>上的模糊关系，则<code>A°R = B</code>称为模糊变换。</p><p>例如：设A={0.2,0.5,0.3}<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%A8%A1%E7%B3%8A10.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="用模糊变换可进行模糊推理"><a href="#用模糊变换可进行模糊推理" class="headerlink" title="用模糊变换可进行模糊推理"></a>用模糊变换可进行模糊推理</h4><p>例如：设对某厨师做的一道菜进行评判<br>评判标准是：色（u1）、香（u2） 、味（u3），它们构成论域：U= { u1, u2 , u3}。<br>评判时由评委对每一个评判因素分别进行打分，评判等级是好（v1）、较好（v2） 、一般（v3）、差（v4），它们构成论域：V= {v1, v2 , v3 , v4}。<br>仅就色而言，有60%的评委认为这道菜“好”， 20%的评委认为 “较好”，20%的评委认为 “一般”，没有评委认为 “差”，则对“色”的评价为：{0.6 , 0.2, 0.2, 0}<br>对“香”的评价为：{0.8 , 0.1, 0.1, 0}<br>对“味”的评价为：{0.3 , 0.3, 0.3, 0.1}<br>这样就可以写出矩阵R：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%A8%A1%E7%B3%8A11.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>假设三个评判因素在评判中所占的权重分别是：“色”为0.3，“香”为0.3，“味”为0.4。这三个权重组成了U上的一个模糊向量：A={0.3 , 0.3, 0.4}<br>由此可得到评委对这道菜的综合评判为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%A8%A1%E7%B3%8A12.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在此例中，评判结果的各项和刚好为1，所以它就是最终评判结果。<br>如果不是这样，还需要对其进行归一化处理，将归一化后的结果作为最终评判结果。</p><h3 id="模糊推理"><a href="#模糊推理" class="headerlink" title="模糊推理"></a>模糊推理</h3><h4 id="简单模糊推理-扎德法"><a href="#简单模糊推理-扎德法" class="headerlink" title="简单模糊推理(扎德法)"></a>简单模糊推理(扎德法)</h4><blockquote><p>知识中只含有简单条件，且不带可信度因子的模糊推理称为简单模糊推理。<br>关于如何由已知的模糊知识和证据具体地推出模糊结论，目前已经提出了多种推理方法。其中包括扎德（ L. A. Zadeh ）等人提出的合成推理规则。</p></blockquote><p>扎德：基于模糊关系合成推理的基本思想</p><ul><li>对于知识 “<code>IF x is A  THEN y is B</code>”，首先构造出A与B之间的模糊关系R；</li><li>再将R与证据合成，求出结论。</li></ul><p><em>合成推理规则</em>：<br>对于知识<code>IF x is A  THEN y is B</code></p><ul><li>首先构造出A与B之间的模糊关系R，然后通过R与证据的合成求出结论。</li><li>如果已知证据是<code>x is A’</code>，且A与A’可以模糊匹配，则通过下述合成运算求取B’：<br><code>B&#39;= A’ ◦R</code></li><li>如果已知证据是<code>y is B&#39;</code>，且B与B’可以模糊匹配，则通过下述合成运算求出A’：<br><code>A’ =R◦B&#39;</code></li></ul><p>至于如何构造模糊关系R：</p><blockquote><p>条件命题的极大极小规则：记获得的模糊关系为Rm</p></blockquote><p>设<code>A∈F(U)</code>, <code>B∈F(V)</code>，其表示分别为<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%A8%A1%E7%B3%8A13.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>扎德把Rm定义为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%A8%A1%E7%B3%8A14.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><hr><p>【例子】<br>设<code>U=V={1,2,3,4,5}</code>, <code>A=1/1+0.5/2</code>, <code>B=0.4/3+0.6/4+1/5</code><br>并设模糊知识为：<code>IF  x is A  THEN  y is B</code><br>模糊证据为：<code>x is A’</code><br>其中， A’的模糊集为： <code>A’ =1/1+0.4/2+0.2/3</code></p><p>则：由模糊知识可得到 Rm<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%A8%A1%E7%B3%8A15.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>求B’：B’= A’ ◦R<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%A8%A1%E7%B3%8A16.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>若已知证据为: y is B’<br><code>B&#39;=0.2/1+0.4/2+0.6/3+0.5/4 +0.3/5</code><br>则：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%A8%A1%E7%B3%8A17.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><hr><h3 id="模糊计算的流程"><a href="#模糊计算的流程" class="headerlink" title="模糊计算的流程"></a>模糊计算的流程</h3><h4 id="模糊计算适用"><a href="#模糊计算适用" class="headerlink" title="模糊计算适用"></a>模糊计算适用</h4><ol><li>复杂且没有完整数学模型的非线性问题：可在不知晓具体模型的情况下利用经验规则求解；</li><li>与其它智能算法结合实现优势互补: 提供了将人类在识别、决策、理解等方面的模糊性引入机器及其控制的途径。</li></ol><h4 id="模糊计算的过程"><a href="#模糊计算的过程" class="headerlink" title="模糊计算的过程"></a>模糊计算的过程</h4><ul><li>模糊规则库：<ul><li>是专家提供的模糊规则。</li></ul></li><li>模糊化：<ul><li>是根据隶属度函数从具体的输入得到对模糊集隶属度的过程。</li></ul></li><li>推理方法：<ul><li>是从模糊规则和输入对相关模糊集的隶属度得到模糊结论的方法。</li></ul></li><li>去模糊化：<ul><li>就是将模糊结论转化为具体的、精确的输出的过程。</li></ul></li></ul><h4 id="模糊计算的一般流程："><a href="#模糊计算的一般流程：" class="headerlink" title="模糊计算的一般流程："></a>模糊计算的一般流程：</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%A8%A1%E7%B3%8A18.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="神经网络系统"><a href="#神经网络系统" class="headerlink" title="神经网络系统"></a>神经网络系统</h2><h3 id="人工神经网络概述"><a href="#人工神经网络概述" class="headerlink" title="人工神经网络概述"></a>人工神经网络概述</h3><p>人工智能的各种学说</p><ul><li>符号（功能）主义：符号逻辑推理</li><li>联结（结构）主义：人工神经网络</li><li>行为主义：智能行为模拟， “模式-动作”<br>联结主义的观点：智能的寓所在大脑皮层，它由大量非线性神经元互联而成 <strong>并行处理</strong>的神经网络。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ul><p>对比这几种模拟方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">神经网络：是一种对人类智能的结构模拟方法，它是通过对大量人工神经元的广泛并行互联，构造人工神经网络系统去模拟生物神经系统的智能机理的。</span><br><span class="line">进化计算：是一种对人类智能的演化模拟方法，它是通过对生物遗传和演化过程的认识，用进化算法去模拟人类智能的进化规律的。</span><br><span class="line">模糊计算：是一种对人类智能的逻辑模拟方法，它是通过对人类处理模糊现象的认知能力的认识，用模糊逻辑去模拟人类的智能行为的。</span><br></pre></td></tr></table></figure></p><ul><li>人工神经网络（ANN）是反映人脑结构及功能的一种抽象数学模型，是由大量神经元节点互连而成的复杂网络，用以模拟人类进行知识的表示与存储以及利用知识进行推理的行为。</li><li>简单地讲，它是一个数学模型，可以用电子线路来实现，也可以用计算机程序来模拟，是人工智能研究的一种方法。</li><li>人工神经网络力求从四个方面模拟人脑的智能行为： 物理结构，计算模拟，存储与操作，训练 </li></ul><h3 id="人工神经网络的特性"><a href="#人工神经网络的特性" class="headerlink" title="人工神经网络的特性"></a>人工神经网络的特性</h3><ul><li>并行分布处理：并行结构，耐故障；</li><li>非线性映射：任意非线性映射能力；</li><li>通过训练进行学习：通过数据记录进行训练，能处理由数学模型或描述规则难以处理的问题；</li><li>适应与集成：自适应和信息融合能力；</li><li>硬件实现：快速和大规模处理能力。</li></ul><h3 id="人工神经元模型"><a href="#人工神经元模型" class="headerlink" title="人工神经元模型"></a>人工神经元模型</h3><p>MP模型是美国心理学家麦克洛奇(W.McM  ulloch)和数理逻辑学家皮茨(W.Pitts) 根据生物神经元的功能和结构，于1943年提出的一种将神经元看作二进制阈值元件的简单模型。MP模型是大多数神经网络模型的基础。<br>MP模型示意图：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C1.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><ul><li>人工神经元是仿照生物神经元提出的，神经元可以有N个输入：<br><code>x1,x2,x3,...,xN</code></li><li>每个输入端与神经元之间有一定的联接权值：<br><code>w1,w2,w3,...,wN</code></li><li>神经元总的输入为对每个输入的加权求和，同时减去阈值θ。u代表神经元的活跃值，即神经元状态：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C2.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li><li>神经元的输出y是对u的映射：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C3.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li><li>f 称为输出函数（激励函数，激活函数），可以有很多形式：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C4.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ul><p>输出函数的作用</p><ul><li>控制输入对输出的激活作用</li><li>对输入、输出进行函数转换</li><li><p>将可能无限域的输入变换成指定的有限范围内的输出</p></li><li><p>神经元的模型确定之后，一个神经网络的特性及能力主要取决于网络的拓扑结构及学习方法</p></li><li>人工神经网络（ANN）可以看成是以人工神经元为结点，用有向加权弧连接起来的有向图<ul><li>人工神经元就是对生物神经元的模拟</li><li>有向弧则是轴突—突触—树突对的模拟</li><li>有向弧的权值表示相互连接的两个人工神经元间相互作用的强弱。</li></ul></li></ul><h3 id="人工神经网络的分类"><a href="#人工神经网络的分类" class="headerlink" title="人工神经网络的分类"></a>人工神经网络的分类</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C5.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>人工神经网络模型是指对网络结构、联结权值和学习能力的总括。常用的网络模型已有数十种。例如：<br>传统的感知机模型；具有误差反向传播功能的反向传播网络模型；采用多变量插值的径向基函数网络模型；建立在统计学习理论基础上的支撑向量机网络模型；采用反馈联接方式的反馈网络模型；基于模拟退火算法的随机网络模型。</p><blockquote><p>前馈网络</p></blockquote><h4 id="单层前馈网络"><a href="#单层前馈网络" class="headerlink" title="单层前馈网络"></a>单层前馈网络</h4><p>单层前馈网络是指那种只拥有单层计算节点的前向网络。它仅含有输入层和输出层，且只有输出层的神经元是可计算节点。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C6.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中，输入向量为X=(x1,x2,…,xn)；输出向量为Y=(y1,y2,…,ym)；输入层各个输入到相应神经元的连接权值分别是wij，i=1,2,..,n，j=1,2,.., m。<br>若假设各神经元的阈值分别是θj，j=1,2,…,m，则各神经元的输出yj, j=1,2,..,m分别为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C17.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中，由所有连接权值wij构成的连接权值矩阵W为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C18.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在实际应用中，该矩阵是通过大量的训练示例学习而形成的。</p><h4 id="多层前馈网络"><a href="#多层前馈网络" class="headerlink" title="多层前馈网络"></a>多层前馈网络</h4><p>多层前馈网络是指那种除拥有输入、输出层外，还至少含有一个、或更多个隐含层的前馈网络。典型代表：BP网络。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C7.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>隐含层作用：通过对输入层信号的加权处理，将其转移成更能被输出层接受的形式。 </p><blockquote><p>反馈网络</p></blockquote><p>反馈网络是指允许采用反馈联结方式所形成的神经网络。反馈联结方式：是指一个神经元的输出可以被反馈至同层或前层的神经元。典型代表：Hopfield网络。 </p><h4 id="前馈网络与反馈网络的区别"><a href="#前馈网络与反馈网络的区别" class="headerlink" title="前馈网络与反馈网络的区别"></a>前馈网络与反馈网络的区别</h4><ul><li>前馈网络：非循环连接模式，每个神经元的输入都没有包含该神经元先前的输出，因此不具有“短期记忆”的性质。</li><li>反馈网络：每个神经元的输入都有可能包含有该神经元先前输出的反馈信息，这就有点类似于人类的短期记忆的性质。<br><img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C8.jpg" alt=""></li></ul><h3 id="传统的感知器模型"><a href="#传统的感知器模型" class="headerlink" title="传统的感知器模型"></a>传统的感知器模型</h3><blockquote><p>感知器是美国学者罗森勃拉特（Rosenblatt）于1957年为研究大脑的存储、学习和认知过程而提出的一类具有自学习能力的神经网络模型，其拓扑结构是一种分层前向网络。包括：单层感知器和多层感知器。</p></blockquote><p>使用感知器的主要目的是 <strong>为了对外部输入进行分类</strong>。<br>罗森勃拉特已经证明，如果外部输入是线性可分的（指存在一个超平面可以将它们分开），则单层感知器一定能够把它划分为两类。其判别超平面由如下判别式确定：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C10.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>作为例子，下面讨论用单个感知器实现逻辑运算的问题。</p><h4 id="单层感知器"><a href="#单层感知器" class="headerlink" title="单层感知器"></a>单层感知器</h4><p>单层感知器是一种只具有单层可调节连接权值神经元的前向网络，这些神经元构成了单层感知器的输出层，是感知器的可计算节点。</p><ul><li>在单层感知器中，每个可计算节点都是一个线性阈值神经元。当输入信息的加权和大于或等于阈值时，输出为1，否则输出为0或-1。</li><li>单层感知器的输出层的每个神经元都只有一个输出，且该输出仅与本神经元的输入及联接权值有关，而与其他神经元无关。</li><li>单层感知器可以很好地实现“与”、“或”、“非”运算，但却 <strong>不能解决“异或”问题</strong>。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C9.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ul><h4 id="多层感知器"><a href="#多层感知器" class="headerlink" title="多层感知器"></a>多层感知器</h4><p>多层感知器是通过在单层感知器的输入、输出层之间加入一层或多层处理单元所构成的。</p><ul><li>拓扑结构与多层前馈网络相似，差别在于其计算节点的连接权值是可变的。</li><li>输入与输出呈现高度非线性的映射关系。</li></ul><h3 id="BP网络模型"><a href="#BP网络模型" class="headerlink" title="BP网络模型"></a>BP网络模型</h3><blockquote><p>误差反向传播(Error Back Propagation)网络简称为BP网络，是由美国加州大学的鲁梅尔哈特和麦克莱兰于1985年提出的一种网络模型。</p></blockquote><p>在BP网络中，同层节点之间不存在相互连接，层与层之间多采用全互连方式，且各层的连接权值可调。BP网络实现了明斯基的多层网络的设想，是当今神经网络模型中使用最广泛的一种。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C11.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如上图所示，BP网络的网络拓扑结构是多层前向网络。</p><p>对BP网络需说明以下两点：<br>第一，BP网络的每个处理单元均为非线性输入/输出关系，其作用函数通常采用的是可微的Sigmoid函数，如：<br>！<a href="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C12.jpg" target="_blank" rel="noopener"></a><br>第二，BP网络的学习过程是由工作信号的正向传播和误差信号的反向传播组成的。所谓正向传播，是指输入模式经隐层到输出层，最后形成输出模式；所谓误差反向传播，是指从输出层开始逐层将误差传到输入层，并修改各层联接权值，使误差信号为最小的过程。</p><h3 id="BP网络模型-1"><a href="#BP网络模型-1" class="headerlink" title="BP网络模型"></a>BP网络模型</h3><blockquote><p>Hopfield网络是由美国加州工学院物理学家霍普菲尔特1982年提出来的一种单层全互连的对称反馈网络模型。分为离散Hopfield网络和连续Hopfield网络。</p></blockquote><p>离散Hopfield网络是在非线性动力学的基础上由若干基本神经元构成的一种单层全互连网络，其任意神经元之间均有连接，并且是一种对称连接结构。<br>离散Hopfield网络模型是一个离散时间系统，每个神经元只有0和1（或-1和1）两种状态，任意神经元i和j之间的连接权值为Wij。由于神经元之间为对称连接，且神经元自身无连接，因此有<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C13.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>由该连接权值所构成的连接矩阵是一个零对角的对称矩阵。</p><p>在 Hopfield网络中，虽然神经元自身无连接，但由于每个神经元都与其他神经元相连，即每个神经元的输出都将通过突触连接权值传递给别的神经元，同时每个神经元又都接受其他神经元传来的信息，这样对每个神经元来说，其输出经过其他神经元后又有可能反馈给自己，因此Hopfidld网络是一种反馈神经网络 。</p><hr><p>【例子】<br>已知网络结构如图所示，网络输入输出路标所示。其中，f(x)为x的符号函数<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C14.jpg)，bias取常数1，设初始值随机取成(0.75,0.5,-0.6" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>。利用误差传播学习算法调整神经网络权值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C15.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>解题过程：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C16.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><hr><h2 id="机器学习系统"><a href="#机器学习系统" class="headerlink" title="机器学习系统"></a>机器学习系统</h2><h3 id="机器学习的基本概念"><a href="#机器学习的基本概念" class="headerlink" title="机器学习的基本概念"></a>机器学习的基本概念</h3><ul><li>机器学习是人工智能的核心，通过使机器模拟人类学习行为，智能化地从过去的经历中获得经验，从而改善其整体性能，重组内在知识结构，并对未知事件进行准确的推断。</li><li>机器学习在科学和工程诸多领域都有着非常广泛的应用，例如金融分析、数据挖掘、生物信息学、医学诊断等。生活中常见的一些智能系统也广泛使用机器学习算法，例如电子商务、手写输入、邮件过滤等。</li></ul><blockquote><p>机器学习的定义:<br>西蒙（Simon,1983）：学习就是系统中的适应性变化，这种变化使系统在重复同样工作或类似工作时，能够做得更好。</p><p>明斯基（Minsky,1985）：学习是在人们头脑里（心理内部）有用的变化。</p><p>学习是一个有特定目的知识获取和能力增长过程，其内在行为是获得知识、积累经验、发现规律等，其外部表现是改进性能、适应环境、实现自我完善等。</p><p>机器学习是研究如何使用机器来模拟人类学习活动的一门学科。</p></blockquote><p>进入21世纪，机器学习的阶段研究热点：<br>2000-2006年的流形学习、2006-2011年的稀疏学习、2012年-至今的深度学习、未来：迁移学习？</p><h3 id="机器学习与深度学习的关系"><a href="#机器学习与深度学习的关系" class="headerlink" title="机器学习与深度学习的关系"></a>机器学习与深度学习的关系</h3><ul><li><strong>机器学习是一种实现人工智能的方法，深度学习是一种实现机器学习的技术</strong>。深度学习本来并不是一种独立的学习方法，其本身也会用到监督和无监督的学习方法来训练深度神经网络。</li><li>最初的深度学习是利用深度神经网络来解决特征表达的一种学习过程。</li></ul><p>提一下，深度学习目前存在以下问题</p><ol><li>深度学习模型需要大量的训练数据，才能展现出神奇的效果，但现实生活中往往会遇到小样本问题，此时深度学习方法无法下手，传统的机器学习方法就可以处理。</li><li>有些领域，采用传统的简单的机器学习方法，可以很好地解决了，没必要非得用复杂的深度学习方法。</li><li>深度学习的思想，来源于人脑的启发，但绝不是人脑的模拟。举个例子，一个三岁的小孩看一辆自行车之后，再见到哪怕外观完全不同的自行车，小孩也十有八九就能做出那是一辆自行车的判断，也就是说，人类的学习过程往往不需要大规模的训练数据，而现在的深度学习方法显然不是对人脑的模拟。</li></ol><h3 id="机器学习策略与基本结构"><a href="#机器学习策略与基本结构" class="headerlink" title="机器学习策略与基本结构"></a>机器学习策略与基本结构</h3><h4 id="机器学习的主要策略"><a href="#机器学习的主要策略" class="headerlink" title="机器学习的主要策略"></a>机器学习的主要策略</h4><ul><li>按照学习中使用推理的多少，机器学习所采用的策略大体上可分为4种：<ul><li>机械学习：记忆学习方法，即把新的知识存储起来，供需要时检索调用，而不需要计算和推理。</li><li>示教学习：外界输入知识与内部知识的表达不完全一致，系统在接受外部知识时需要推理、翻译和转化。</li><li>类比学习：需要发现当前任务与已知知识的相似之处，通过类比给出完成当前任务的方案。</li><li>示例学习：需要从一组正例和反例中分析和总结出一般性的规律，在新的任务中推广、验证、修改规律。</li></ul></li></ul><h4 id="学习系统的基本结构"><a href="#学习系统的基本结构" class="headerlink" title="学习系统的基本结构"></a>学习系统的基本结构</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/ML.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>影响学习系统设计的要素<ul><li>环境：环境向系统提供信息的水平（一般化程度）和质量（正确性）</li><li>知识库：表达能力，易于推理，容易修改，知识表示易于扩展。</li></ul></li></ul><h3 id="归纳学习"><a href="#归纳学习" class="headerlink" title="归纳学习"></a>归纳学习</h3><ul><li>归纳学习是应用归纳推理进行学习的一种方法。</li><li><p>归纳学习的模式：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/ML1.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>实验规划过程通过对实例空间的搜索完成实例选择，并将这些选中拿到的活跃实例提交给解释过程。解释过程对实例加以适当转换，把活跃实例变换为规则空间中的特定概念，以引导规则空间的搜索。</p></li><li><p>归纳学习是目前研究得最多的学习方法，其学习目的是为了获得新概念、构造新规则或发现新理论。</p></li><li>根据归纳学习有无教师指导，可把它分为<ul><li>示例学习：给学习者提供某一概念的一组正例和反例，学习者归纳出一个总的概念描述（规则），并使这个描述适合于所有的正例，排除所有的反例。</li><li>观察发现学习：<ul><li>概念聚类：按照一定的方式和准则分组，归纳概念</li><li>机器发现：从数据和事例中发现新知识</li></ul></li></ul></li></ul><h3 id="类比学习"><a href="#类比学习" class="headerlink" title="类比学习"></a>类比学习</h3><ul><li>类比学习（learning by analogy）就是通过类比，即通过对相似事物加以比较所进行的一种学习 。</li><li>类比学习是利用二个不同领域（源域、目标域）中的知识相似性，可以通过类比，从源域的知识（包括相似的特征和其它性质）推导出目标域的相应知识，从而实现学习。例如：<ul><li>一个从未开过truck的司机，只要他有开car的知识就可完成开truck的任务。</li><li>若把某个人比喻为消防车，则可通过观察消防车的行为，推断出这个人的性格。</li></ul></li><li>类比学习系统可以使一个已有的计算机应用系统转变为适应于新的领域，来完成原先没有设计的相类似的功能。</li><li><p>类比推理过程：</p><ul><li>回忆与联想：找出当前情况的相似情况</li><li>选择：选择最相似的情况及相关知识</li><li>建立对应关系：建立相似元素之间的映射</li><li>转换：求解问题或产生新的知识</li></ul></li><li><p>类比学习研究类型</p><ul><li>问题求解型的类比学习：求解一个新问题时，先回忆以前是否求解过类似问题，若是，则以此为依据求解新问题。</li><li>预测推理型的类比学习<ul><li>传统的类比法：用来推断一个不完全确定的事物可能还有的其他属性</li><li>因果关系型：已知因果关系<code>S1:A-&gt;B</code>，如果有<code>A&#39;≌A</code>，则可能有B’满足<code>A&#39;-&gt;B&#39;</code></li></ul></li></ul></li></ul><h3 id="解释学习"><a href="#解释学习" class="headerlink" title="解释学习"></a>解释学习</h3><blockquote><p>解释学习(Explanation-based learning, EBL)兴起于20世纪80年代中期，根据任务所在领域知识和正在学习的概念知识，对当前实例进行分析和求解，得出一个表征求解过程的因果解释树，以获取新的知识。<br>例如：学生根据教师提供的目标概念、该概念的一个例子、领域理论及可操作准则，首先构造一个解释来说明为什么该例子满足目标概念，然后将解释推广为目标概念的一个满足可操作准则的充分条件。</p></blockquote><p>解释学习过程和算法<br>米切尔提出了一个解释学习的统一算法EBG，建立了基于解释的概括过程，并用知识的逻辑表示和演绎推理进行问题求解。其一般性描述为：</p><ul><li>给定：领域知识DT、目标概念TC、训练实例TE、操作性准则OC</li><li>找出：满足OC的关于TC的充分条件<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/ML2.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ul><p>EBG算法可概括为两步：</p><ol><li>构造解释：运用领域知识进行演绎，证明提供给系统的训练实例为什么是满足目标概念的一个实例。</li><li>获取一般性的知识：<ul><li>任务：对上一步得到的解释结构进行一般化的处理，从而得到关于目标概念的一般性知识。</li><li>方法：将常量换成变量，并把某些不重要的信息去掉，只保留求解问题必须的关键信息。</li></ul></li></ol><h3 id="神经网络学习-ppt-21-32"><a href="#神经网络学习-ppt-21-32" class="headerlink" title="神经网络学习(ppt-21-32)"></a>神经网络学习(ppt-21-32)</h3><h4 id="Hebb学习"><a href="#Hebb学习" class="headerlink" title="Hebb学习"></a>Hebb学习</h4><h4 id="纠错学习"><a href="#纠错学习" class="headerlink" title="纠错学习"></a>纠错学习</h4><h4 id="竞争学习及随机学习"><a href="#竞争学习及随机学习" class="headerlink" title="竞争学习及随机学习"></a>竞争学习及随机学习</h4><h4 id="感知器学习"><a href="#感知器学习" class="headerlink" title="感知器学习"></a>感知器学习</h4><p>单层感知器学习算法可描述如下：<br>(1)、设t=0，初始化连接权和阈值。即给wi(0)(i=1, 2, … ,n)及θ(0)分别赋予一个较小的非零随机数，作为初值。其中，wi(0)是第0次迭代时输入向量中第i个输入的连接权值；θ(0)是第0次迭代时输出节点的阈值；<br>(2)、提供新的样本输入xi(t)(i=1, 2, … , n)和期望输出d(t)；<br>(3)、计算网络的实际输出：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/ML3.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>(4)、若y(t)=d(t)，不需要调整连接权值，转(6)。否则，需要调整权值；<br>(5)、调整连接权值；<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/ML4.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中，η是一个增益因子，用于控制修改速度，其值如果太大，会影响wi(t)的收敛性；如果太小，又会使wi(t)的收敛速度太慢;<br>(6)、判断是否满足结束条件，若满足，算法结束；否则，将t值加1，转(2)重新执行。这里的结束条件一般是指wi(t)对一切样本均稳定不变。<br>若输入的两类样本是线性可分的，则该算法就一定会收敛。否则，不收敛。</p><hr><p>【例子】用单层感知器实现逻辑“与”运算。</p><p>解：根据“与”运算的逻辑关系，可将问题转换为：<br>输入向量：<br><code>X1=[0, 0, 1, 1]</code><br><code>X2=[0, 1, 0, 1]</code><br>输出向量：<br><code>Y=[0, 0, 0, 1]</code><br>为减少算法的迭代次数，设初始连接权值和阈值取值如下：<br><code>w1(0)=0.5</code>,   <code>w2(0)=0.7</code>,   <code>θ(0)=0.6</code><br>并取增益因子<code>η=0.4</code>。</p><p>算法的学习过程如下：<br>设两个输入为<code>x1(0)=0</code>和<code>x2(0)=0</code>，其期望输出为<code>d(0)=0</code>，实际输出为：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">y(<span class="number">0</span>)=f(w1(<span class="number">0</span>)x1(<span class="number">0</span>)+ w2(<span class="number">0</span>)x2(<span class="number">0</span>)-θ(<span class="number">0</span>)) </span><br><span class="line">    =f(<span class="number">0.5</span>*<span class="number">0</span>+<span class="number">0.7</span>*<span class="number">0</span><span class="number">-0.6</span>)</span><br><span class="line">    =f(<span class="number">-0.6</span>)</span><br><span class="line">    =<span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>实际输出与期望输出相同，不需要调节权值。<br>再取下一组输入：<code>x1(0)=0</code>和<code>x2(0)=1</code>，期望输出<code>d(0)=0</code>，实际输出：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">y(<span class="number">0</span>)=f(w1(<span class="number">0</span>) x1(<span class="number">0</span>)+ w2(<span class="number">0</span>) x2(<span class="number">0</span>)-θ(<span class="number">0</span>)) </span><br><span class="line">    =f(<span class="number">0.5</span>*<span class="number">0</span>+<span class="number">0.7</span>*<span class="number">1</span><span class="number">-0.6</span>)</span><br><span class="line">    =f(<span class="number">0.1</span>)</span><br><span class="line">    =<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>实际输出与期望输出不同，需要调节权值，其调整如下：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">θ(<span class="number">1</span>)=θ(<span class="number">0</span>)+η(d(<span class="number">0</span>)- y(<span class="number">0</span>))*(<span class="number">-1</span>)=<span class="number">0.6</span>+<span class="number">0.4</span>*(<span class="number">0</span><span class="number">-1</span>)*(<span class="number">-1</span>)=<span class="number">1</span></span><br><span class="line">w1(<span class="number">1</span>)=w1(<span class="number">0</span>)+η(d(<span class="number">0</span>)- y(<span class="number">0</span>))x1(<span class="number">0</span>)=<span class="number">0.5</span>+<span class="number">0.4</span>*(<span class="number">0</span><span class="number">-1</span>)*<span class="number">0</span>=<span class="number">0.5</span></span><br><span class="line">w2(<span class="number">1</span>)=w2(<span class="number">0</span>)+η(d(<span class="number">0</span>)- y(<span class="number">0</span>))x2(<span class="number">0</span>)=<span class="number">0.7</span>+<span class="number">0.4</span>*(<span class="number">0</span><span class="number">-1</span>)*<span class="number">1</span>=<span class="number">0.3</span></span><br></pre></td></tr></table></figure></p><p>取下一组输入：<code>x1(1)=1</code>和<code>x2(1)=0</code>，其期望输出为<code>d(1)=0</code>，实际输出为：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">y(<span class="number">1</span>)=f(w1(<span class="number">1</span>) x1(<span class="number">1</span>)+ w2(<span class="number">1</span>) x2(<span class="number">1</span>)-θ(<span class="number">1</span>))</span><br><span class="line">      =f(<span class="number">0.5</span>*<span class="number">1</span>+<span class="number">0.3</span>*<span class="number">0</span><span class="number">-1</span>)</span><br><span class="line">      =f(<span class="number">-0.51</span>)</span><br><span class="line">      =<span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>实际输出与期望输出相同，不需要调节权值。<br>再取下一组输入：<code>x1(1)=1和x2(1)=1</code>，其期望输出为<code>d(1)=1</code>，实际输出为：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">y(<span class="number">1</span>)=f(w1(<span class="number">1</span>) x1(<span class="number">1</span>)+ w2(<span class="number">1</span>) x2(<span class="number">1</span>)-θ(<span class="number">1</span>))</span><br><span class="line">    =f(<span class="number">0.5</span>*<span class="number">1</span>+<span class="number">0.3</span>*<span class="number">1</span><span class="number">-1</span>)</span><br><span class="line">    =f(<span class="number">-0.2</span>)</span><br><span class="line">    =<span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>实际输出与期望输出不同，需要调节权值，其调整如下：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">θ(<span class="number">2</span>)=θ(<span class="number">1</span>)+η(d(<span class="number">1</span>)- y(<span class="number">1</span>))*(<span class="number">-1</span>)=<span class="number">1</span>+<span class="number">0.4</span>*(<span class="number">1</span><span class="number">-0</span>)*(<span class="number">-1</span>)=<span class="number">0.6</span></span><br><span class="line">w1(<span class="number">2</span>)=w1(<span class="number">1</span>)+η(d(<span class="number">1</span>)- y(<span class="number">1</span>))x1(<span class="number">1</span>)=<span class="number">0.5</span>+<span class="number">0.4</span>*(<span class="number">1</span><span class="number">-0</span>)*<span class="number">1</span>=<span class="number">0.9</span></span><br><span class="line">w2(<span class="number">2</span>)=w2(<span class="number">1</span>)+η(d(<span class="number">1</span>)- y(<span class="number">1</span>))x2(<span class="number">1</span>)=<span class="number">0.3</span>+<span class="number">0.4</span>*(<span class="number">1</span><span class="number">-0</span>)*<span class="number">1</span>=<span class="number">0.7</span></span><br></pre></td></tr></table></figure></p><p>取下一组输入：<code>x1(2)=0</code>和<code>x2(2)=0</code>，其期望输出为<code>d(2)=0</code>，实际输出为：<br><code>y(2)=f(0.9*0+0.7*0-0.6)=f(-0.6)=0</code><br>实际输出与期望输出相同，不需要调节权值.<br>再取下一组输入：<code>x1(2)=0</code>和<code>x2(2)=1</code>，期望输出为<code>d(2)=0</code>，实际输出为：<br><code>y(2)=f(0.9*0+0.7*1-0.6)=f(0.1)=1</code><br>实际输出与期望输出不同，需要调节权值，其调整如下：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">θ(<span class="number">3</span>)=θ(<span class="number">2</span>)+η(d(<span class="number">2</span>)- y(<span class="number">2</span>))*(<span class="number">-1</span>)=<span class="number">0.6</span>+<span class="number">0.4</span>*(<span class="number">0</span><span class="number">-1</span>)*(<span class="number">-1</span>)=<span class="number">1</span></span><br><span class="line">w1(<span class="number">3</span>)=w1(<span class="number">2</span>)+η(d(<span class="number">2</span>)- y(<span class="number">2</span>))x1(<span class="number">2</span>)=<span class="number">0.9</span>+<span class="number">0.4</span>*(<span class="number">0</span><span class="number">-1</span>)*<span class="number">0</span>=<span class="number">0.9</span></span><br><span class="line">w2(<span class="number">3</span>)=w2(<span class="number">2</span>)+η(d(<span class="number">2</span>)- y(<span class="number">2</span>))x2(<span class="number">2</span>)=<span class="number">0.7</span>+<span class="number">0.4</span>*(<span class="number">0</span><span class="number">-1</span>)*<span class="number">1</span>=<span class="number">0.3</span></span><br></pre></td></tr></table></figure></p><p>实际上，由与运算的阈值条件可知，此时的阈值和连接权值以满足结束条件，算法可以结束。<br>对此，可检验如下：<br>对输入：“0 0”有<code>y=f(0.9*0+0.3*0-1)=f(-1)=0</code><br>对输入：“0 1”有<code>y=f(0.9*0+0.3*0.1-1)=f(-0.7)=0</code><br>对输入：“1 0”有<code>y=f(0.9*1+0.3*0-1)=f(-0.1)=0</code><br>对输入：“1 1”有<code>y=f(0.9*1+0.3*1-1)=f(0.2)=1</code></p><hr><p>多层感知器可以解决非线性可分问题，但其隐层神经元的期望输出却不易给出。<br>而单层感知器学习是一种有导师指导的学习过程，因此其学习算法无法直接用于多层感知器。<br>由于多层感知器和BP网络都属于前向网络，并能较好解决多层前馈网络的学习问题.<br>因此，可用BP学习来解决多层感知器学习问题。</p><h4 id="BP网络学习"><a href="#BP网络学习" class="headerlink" title="BP网络学习"></a>BP网络学习</h4><h4 id="Hopfield网络学习"><a href="#Hopfield网络学习" class="headerlink" title="Hopfield网络学习"></a>Hopfield网络学习</h4><h3 id="其他机器学习方法"><a href="#其他机器学习方法" class="headerlink" title="其他机器学习方法"></a>其他机器学习方法</h3><ul><li>迁移学习：将在先前任务中学到的知识或技能应用于一个新的任务或新的领域</li><li>增强机器学习：从变化环境中学习蕴含在环境中的知识</li><li>流形机器学习：把一组在高维空间中的数据在低维空间中重新表示</li><li>半监督机器学习：结合标记和非标记样本</li><li>多实例机器学习：一个对象可能同时有多个描述</li><li>Ranking机器学习：获得关于检索中“喜欢”顺序的模型</li><li>数据流机器学习：从数据流中发现知识</li><li>……</li></ul><p>相关的一些概念：决策树、 随机森林、逻辑回归、朴素贝叶斯、K最近临算法、马尔可夫……</p><h2 id="仿生进化系统-GA"><a href="#仿生进化系统-GA" class="headerlink" title="仿生进化系统(GA)"></a>仿生进化系统(GA)</h2><blockquote><p>遗传算法最早由美国密西根大学的J. Holland 教授提出，起源于20世纪60年代对自然和人工自适应系统的研究。70年代，De Jong 基于遗传算法的思想在计算机上进行了大量的纯数值函数优化计算实验。在一系列研究工作的基础上，80年代由Goldberg进行归纳总结，形成了遗传算法的基本框架</p></blockquote><h3 id="遗传算法的定义"><a href="#遗传算法的定义" class="headerlink" title="遗传算法的定义"></a>遗传算法的定义</h3><p>遗传算法（Genetic Algorithm, GA）是模拟生物在自然环境种的遗传和进化过程而形成的一种自适应全局优化概率搜索算法。</p><h3 id="遗传算法的基本思想"><a href="#遗传算法的基本思想" class="headerlink" title="遗传算法的基本思想"></a>遗传算法的基本思想</h3><p>是从初始种群出发，采用优胜劣汰、适者生存的自然法则选择个体，并通过杂交、变异来产生新一代种群，如此逐代进化，直到满足目标为止。</p><h3 id="遗传算法的基本过程"><a href="#遗传算法的基本过程" class="headerlink" title="遗传算法的基本过程"></a>遗传算法的基本过程</h3><blockquote><p>算法主要内容和基本步骤</p></blockquote><p>(1) 选择编码策略，将问题搜索空间中每个可能的点用相应的编码策略表示出来，即形成染色体；<br>(2) 定义遗传策略，包括种群规模N，交叉、变异方法，以及选择概率Pr、交叉概率Pc、变异概率Pm等遗传参数；<br>(3) 令t=0，随机选择N个染色体初始化种群P(0)；<br>(4) 定义适应度函数f（f&gt;0）；<br>(5) 计算P(t)中每个染色体的适应值；<br>(6) t=t+1；<br>(7) 运用选择算子，从P(t-1)中得到P(t)；<br>(8) 对P(t)中的每个染色体，按概率Pc参与交叉；<br>(9) 对染色体中的基因，以概率Pm参与变异运算；<br>(10) 判断群体性能是否满足预先设定的终止标准，若不满足则返回(5)。</p><blockquote><p>常用的遗传编码算法</p></blockquote><ul><li>霍兰德二进制码<ul><li>二进制编码是将原问题的结构变换为染色体的位串结构。在二进制编码中，首先要确定二进制字符串的长度    ，该长度与变量的定义域和所求问题的计算精度有关。</li></ul></li><li>格雷编码（Gray Code）<ul><li>格雷编码是对二进制编码进行变换后所得到的一种编码方法。这种编码方法要求两个连续整数的编码之间只能有一个码位不同，其余码位都是完全相同的。它有效地解决了汉明悬崖问题。</li></ul></li><li>实数编码<ul><li>实数编码是将每个个体的染色体都用某一范围的一个实数（浮点数）来表示，其编码长度等于该问题变量的个数。</li><li>这种编码方法是将问题的解空间映射到实数空间上，然后在实数空间上进行遗传操作。由于实数编码使用的是变量的真实值，因此这种编码方法也叫做真值编码方法。</li><li>实数编码适应于那种多维、高精度要求的连续函数优化问题。 </li></ul></li><li>字符编码</li></ul><blockquote><p>适应度函数</p></blockquote><p>适应度函数是一个用于对个体的适应性进行度量的函数。通常，一个个体的适应度值越大，它被遗传到下一代种群中的概率也就越大。</p><p>(1) 常用的适应度函数</p><ul><li>原始适应度函数：直接将待求解问题的目标函数f(x)定义为遗传算法的适应度函数。<ul><li>优点：能够直接反映出待求解问题的最初求解目标</li><li>缺点：是有可能出现适应度值为负的情况。    </li></ul></li><li>标准适应度函数<ul><li>在遗传算法中，一般要求适应度函数非负，并其适应度值越大越好。这就往往需要对原始适应函数进行某种变换，将其转换为标准的度量方式，以满足进化操作的要求，这样所得到的适应度函数被称为标准适应度函数。<br>(2) 适应度函数的加速变换</li></ul></li><li>在某些情况下，需要对适应度函数进行加速速度。</li><li><p>适应度函数的加速变换有两种基本方法，即线性加速与非线性加速。</p></li><li><p><strong>线性加速</strong></p><ul><li>线性加速的适应度函数的定义如下：</li><li><code>f&#39;(x)=αf(x)+β</code></li><li>其中，f(x)是加速转换前的适应度函数；f’(x)是加速转换后的适应度函数；α和β是转换系数,它们应满足如下条件：<ul><li>变化后得到的新的适应度函数平均值要等于原适应度函数的平均值。即<br><img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/GA.jpg" alt=""></li><li>其中，<code>xi(i=1,…,n)</code>为当前代中的染色体。</li><li>变换后所得到的新的种群个体所具有的最大适应度要等于其平均适应度的指数倍数。即有关系：<br><img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/GA1.jpg" alt=""></li><li>式中，<code>xi(i=1,…,n)</code>为当前代中的染色体，M是指将当前的最大适应度放大为平均值的M倍。目的是通过M拉开不同染色体适应度值的差距。</li></ul></li></ul></li><li><strong>非线性加速</strong><ul><li>幂函数变换方法<ul><li><code>f&#39;(x)=f(x)k</code>              </li></ul></li><li>指数变换方法 <ul><li><code>f&#39;(x)=exp(-βf(x))</code>              </li></ul></li></ul></li></ul><blockquote><p>基本遗传操作</p></blockquote><p>(1)、选择操作<br>选择（Selection）操作是指根据选择概率按某种策略从当前种群中挑选出一定数目的个体，使它们能够有更多的机会被遗传到下一代中。<br>常用的选择策略: </p><ul><li>比例选择</li><li>排序选择</li><li>竞技选择<ul><li>其中比例选择基本思想是：各个个体被选中的概率与其适应度大小成正比。</li><li>常用的比例选择策略:轮盘赌选择、繁殖池选择</li><li>轮盘赌选择<br>轮盘赌选择法又被称为转盘赌选择法或轮盘选择法。在这种方法中，个体被选中的概率取决于该个体的相对适应度。而相对适应度的定义为：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/GA2.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>其中，P(xi)是个体xi的相对适应度，即个体xi被选中的概率；f(xi)是个体xi的原始适应度；是种群的累加适应度。</li></ul></li></ul><p>轮盘赌选择算法的基本思想是：根据每个个体的选择概率P(xi)将一个圆盘分成N个扇区，其中第i个扇区的中心角为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/GA3.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>再设立一个移动指针，将圆盘的转动等价为指针的移动。选择时，假想转动圆盘，若静止时指针指向第i个扇区，则选择个体i。<br>从统计角度看，个体的适应度值越大，其对应的扇区的面积越大，被选中的可能性也越大。这种方法有点类似于发放奖品使用的轮盘，并带有某种赌博的意思，因此亦被称为轮盘赌选择。</p><p>(2)、交叉操作</p><ul><li>交配重组是自然界中生物遗传进化的一个主要环节，也是遗传算法中产生新的个体的最主要方法。</li><li>交叉（Crossover）操作是指按照某种方式对选择的父代个体的染色体的部分基因进行交配重组，从而形成新的个体。</li><li>根据个体编码方法的不同，遗传算法中的交叉操作可分为二进制交叉和实值交叉两种类型。<ul><li>二进制交叉</li><li>二进制交叉（Binary Valued Crossover）是指二进制编码情况下所采用的交叉操作，它主要包括单点交叉、两点交叉、多点交叉和均匀交叉等方法。<ul><li>单点交叉<ul><li>单点交叉也称简单交叉，它是先在两个父代个体的编码串中随机设定一个交叉点，然后对这两个父代个体交叉点前面或后面部分的基因进行交换，并生成子代中的两个新的个体。假设两个父代的个体串分别是：</li><li><code>X=x1 x2 … xk xk+1 … xn</code></li><li><code>Y=y1 y2 … yk yk+1 … yn</code></li><li>随机选择第k位为交叉点，若采用对交叉点后面的基因进行交换的方法，但点交叉是将X中的xk+1到xn部分与Y中的yk+1到yn部分进行交叉，交叉后生成的两个新的个体是：</li><li><code>X&#39;= x1 x2 … xk yk+1 … yn</code> </li><li><code>Y&#39;= y1 y2 … yk xk+1 … xn</code> </li></ul></li><li>两点交叉<ul><li>两点交叉是指先在两个父代个体的编码串中随机设定两个交叉点，然后再按这两个交叉点进行部分基因交换，生成子代中的两个新的个体。</li><li>假设两个父代的个体串分别是：</li><li><code>X=x1 x2 … xi … xj … xn</code></li><li><code>Y=y1 y2 … yi … yj …,yn</code></li><li>随机设定第i、j位为两个交叉点（其中<code>i&lt; j &lt; n</code>），两点交叉是将X中的xi+1到xj部分与Y中的yi+1到yj部分进行交换，交叉后生成的两个新的个体是：</li><li><code>X&#39;= x1 x2 … xi yi+1 … yj xj+1 … xn</code> </li><li><code>Y&#39;= y1 y2 … yi xi+1 … xj yj+1 … yn</code> </li></ul></li><li>多点交叉<ul><li>多点交叉是指先随机生成多个交叉点，然后再按这些交叉点分段地进行部分基因交换，生成子代中的两个新的个体。</li><li>假设交叉点个数为m，则可将个体串划分为m+1个分段，其划分方法是：<ul><li>当m为偶数时，对全部交叉点依次进行两两配对，构成m/2个交叉段。</li><li>当m为奇数时，对前(m-1)个交叉点依次进行两两配对，构成(m-1)/2个交叉段，而第m个交叉点则按单点交叉方法构成一个交叉段。</li></ul></li></ul></li><li>均匀交叉<ul><li>均匀交叉（Uniform Crossover）是先随机生成一个与父串具有相同长度，并被称为交叉模版（或交叉掩码）的二进制串，然后再利用该模版对两个父串进行交叉，即将模版中1对应的位进行交换，而0对应的位不交换，依此生成子代中的两个新的个体。事实上，这种方法对父串中的每一位都是以相同的概率随机进行交叉的。</li></ul></li></ul></li><li>实值交叉<ul><li>实值交叉是在实数编码情况下所采用的交叉操作，主要包括离散交叉和算术交叉，下面主要讨论离散交叉（部分离散交叉和整体离散交叉） 。</li><li>部分离散交叉是先在两个父代个体的编码向量中随机选择一部分分量，然后对这部分分量进行交换，生成子代中的两个新的个体。</li><li>整体交叉则是对两个父代个体的编码向量中的所有分量，都以1/2的概率进行交换，从而生成子代中的两个新的个体。</li><li>以部分离散交叉为例，假设两个父代个体的n维实向量分别是 <code>X=x1x2… xi…xk…xn</code>和<code>Y=y1y2…yi…yk…yn</code>，若随机选择对第k个分量以后的所有分量进行交换，则生成的两个新的个体向量是：<ul><li><code>X&#39;= x1 x2 … xk yk+1 … yn</code></li><li><code>Y&#39;= y1 y2 … yk xk+1 … xn</code></li></ul></li></ul></li></ul></li></ul><p>(3)、变异操作<br>变异（Mutation）是指对选中个体的染色体中的某些基因进行变动，以形成新的个体。变异也是生物遗传和自然进化中的一种基本现象，它可增强种群的多样性。遗传算法中的变异操作增加了算法的局部随机搜索能力，从而可以维持种群的多样性。根据个体编码方式的不同，变异操作可分为二进制变异和实值变异两种类型。</p><ul><li>二进制变异<ul><li>当个体的染色体采用二进制编码表示时，其变异操作应采用二进制变异方法。该变异方法是先随机地产生一个变异位，然后将该变异位置上的基因值由“0”变为“1”，或由“1”变为“0”，产生一个新的个体。</li></ul></li><li>实值变异<ul><li>当个体的染色体采用实数编码表示时，其变异操作应采用实值变异方法。该方法是用另外一个在规定范围内的随机实数去替换原变异位置上的基因值，产生一个新的个体。<ul><li>基于位置的变异方法<ul><li>该方法是先随机地产生两个变异位置，然后将第二个变异位置上的基因移动到第一个变异位置的前面。</li></ul></li><li>基于次序的变异<ul><li>该方法是先随机地产生两个变异位置，然后交换这两个变异位置上的基因。</li></ul></li></ul></li></ul></li></ul><h3 id="遗传算法的优势"><a href="#遗传算法的优势" class="headerlink" title="遗传算法的优势"></a>遗传算法的优势</h3><ol><li>适应度函数不受连续、可微等条件的约束，适用范围很广。</li><li>不容易陷入局部极值，能以很大的概率找到全局最优解。</li><li>由于其固有的并行性，适合于大规模并行计算。</li><li>不是盲目穷举，而是启发式搜索。</li></ol><h2 id="群智能系统"><a href="#群智能系统" class="headerlink" title="群智能系统"></a>群智能系统</h2><blockquote><p>由James Kenney（社会心理学博士）和<a href="http://www.engr.iupui.edu/~eberhart/" target="_blank" rel="noopener">Russ Eberhart</a>（电子工程学博士）于1995年提出粒子群算法（Particle Swarm Optimization, PSO）。</p></blockquote><h3 id="蚁群算法-Ant-Colony-Optimization-ACO"><a href="#蚁群算法-Ant-Colony-Optimization-ACO" class="headerlink" title="蚁群算法(Ant Colony Optimization,ACO)"></a>蚁群算法(Ant Colony Optimization,ACO)</h3><p>通过遗留在来往路径上的信息素（Pheromone）的挥发性化学物质来进行通信和协调。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/CAO.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><ul><li>蚂蚁在寻找食物的过程中往往是随机选择路径的，但它们能感知当前地面上的信息素浓度，并倾向于往信息素浓度高的方向行进。信息素由蚂蚁自身释放，是实现蚁群内间接通信的物质。</li><li>由于较短路径上蚂蚁的往返时间比较短，单位时间内经过该路径的蚂蚁多，所以信息素的积累速度比较长路径快。因此，当后续蚂蚁在路口时，就能感知先前蚂蚁留下的信息，并倾向于选择一条较短的路径前行。</li><li>这种正反馈机制使得越来越多的蚂蚁在巢穴与食物之间的最短路径上行进。由于其他路径上的信息素会随着时间蒸发，最终所有的蚂蚁都在最优路径上行进。</li></ul><h4 id="ACO基本要素"><a href="#ACO基本要素" class="headerlink" title="ACO基本要素"></a>ACO基本要素</h4><ul><li>路径构建<br>伪随机比例选择规则<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/CAO1.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>对于每只蚂蚁k，路径记忆向量Rk按照访问顺序记录了所有k已经经过的城市序号。</li><li>设蚂蚁k当前所在城市为i，则其选择城市j作为下一个访问对象的概率如上式。Jk(i) 表示从城市i 可以直接到达的、且又不在蚂蚁访问过的城市序列Rk中的城市集合。</li><li><code>η(i, j)</code>是一个启发式信息，通常由<code>η (i, j)=1/dij</code> 直接计算。</li><li><code>τ (i, j)</code> 表示边<code>(i, j)</code>上的信息素量。</li><li>长度越短、信息素浓度越大的路径被蚂蚁选择的概率越大。</li><li>α和β是两个预先设置的参数，用来控制启发式信息与信息素浓度作用的权重关系。</li><li>当<code>α =0</code>时，算法演变成传统的随机贪心算法，最邻近城市被选中的概率最大。当<code>β =0</code>时，蚂蚁完全只根据信息素浓度确定路径，算法将快速收敛，这样构建出的最优路径与实际目标差异较大，算法性能较差。</li></ul></li><li>信息素更新：<br>(1) 在算法初始化时，问题空间中所有的边上的信息素都被初始化为τ0。<br>(2) 算法迭代每一轮，问题空间中的所有路径上的信息素都会发生蒸发，我们为所有边上的信息素乘上一个小于1的常数( ρ: 信息素的蒸发率)。信息素蒸发是自然界本身固有的特征，在算法中能够帮助避免信息素的无限积累，使得算法可以快速丢弃之前构建过的较差的路径。<br>(3) 蚂蚁根据自己构建的路径长度在它们本轮经过的边上释放信息素。蚂蚁构建的路径越短、释放的信息素就越多。一条边被蚂蚁爬过的次数越多、它所获得的信息素也越多。<br>(4) 迭代 (2)，直至算法终止。<br>信息素的更新公式：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/CAO2.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><code>m</code>：蚂蚁个数；</li><li><code>ρ</code>：信息素的蒸发率，规定<code>0&lt;r≤1</code>。             </li><li><code>Δτ (i, j)</code>：第k只蚂蚁在它经过的边上释放的信息素量，它等于蚂蚁k本轮构建路径长度的倒数。</li><li><code>Ck</code>：路径长度，它是Rk中所有边的长度和。</li></ul></li></ul><h3 id="粒子群优化算法"><a href="#粒子群优化算法" class="headerlink" title="粒子群优化算法"></a>粒子群优化算法</h3><ul><li>源于对鸟群捕食行为的研究，是基于迭代的方法</li><li>简单易于实现，需要调整的参数相对较少</li><li>在函数优化、神经网络训练、工业系统优化和模糊系统控制等领域得到了广泛的应用。<ul><li>鸟群：假设一个区域，所有的鸟都不知道食物的位置，但是它们知道当前位置离食物还有多远。</li><li>PSO算法：每个解看作一只鸟，称为“粒子(particle)”，所有的粒子都有一个适应值，每个粒子都有一个速度决定它们的飞翔方向和距离，粒子们追随当前最优粒子在解空间中搜索。</li></ul></li></ul><h4 id="粒子群算法的特点"><a href="#粒子群算法的特点" class="headerlink" title="粒子群算法的特点"></a>粒子群算法的特点</h4><ul><li>PSO算法收敛速度快，特别是在算法的早期，但也存在着精度较低，易发散等缺点。</li><li>若加速系数、最大速度等参数太大，粒子群可能错过最优解，算法不收敛；</li><li>而在收敛的情况下，由于所有的粒子都向最优解的方向飞去，所以粒子趋向同一化（失去了多样性），使得后期收敛速度明显变慢，同时算法收敛到一定精度时，无法继续优化，所能达到的精度也不高。</li></ul><h3 id="其他计算智能方法"><a href="#其他计算智能方法" class="headerlink" title="其他计算智能方法"></a>其他计算智能方法</h3><p>模拟退火、工免疫系统、粗集理论、EDA算法、文化进化计算、量子计算、DNA计算、智能Agent、……</p><h2 id="多真体及自然语言理解"><a href="#多真体及自然语言理解" class="headerlink" title="多真体及自然语言理解 *"></a>多真体及自然语言理解 *</h2><h3 id="Agent的定义和译法"><a href="#Agent的定义和译法" class="headerlink" title="Agent的定义和译法"></a>Agent的定义和译法</h3><blockquote><p>Agent的定义</p></blockquote><ul><li>定义1.社会中某个个体经过协商后可求得问题的解，这个个体就是agent.（明斯基，1986年）</li><li>定义2.是一种通过传感器知其环境，并通过执行器作用于该环境的实体，因此，可以把真体定义为一种从感知序列到实体动作的映射。（Russell and Norving,1995）</li><li>定义3.是一种具有智能的实体。</li></ul><blockquote><p>Agent的译法</p></blockquote><p>建议把agent译为“(艾)真体”的理由：</p><ul><li>Agent是一种通过传感器感知其环境，并通过执行器作用于该环境的实体。 这个“实体”也可叫做“真体”。因此，可以把真体定义为一种从感知序列到实体动作的映射。</li><li>译为“主体”可能是考虑到agent具有自主性。但交互性、协调性、社会性、适应性和分布性等不可能在译名上全部反映出来，因而是片面的。</li><li>译为“代理”是受到社会科学和管理科学的影响。也不能表示出agent的原义。</li><li>音译不失为一种可取方法。</li><li>有一定的物理意义。  </li></ul><h3 id="真体的要素和特性"><a href="#真体的要素和特性" class="headerlink" title="真体的要素和特性"></a>真体的要素和特性</h3><blockquote><p>真体的要素</p></blockquote><p>真体必须利用知识修改其内部状态（心理状态），以适应环境变化和协作求解的需要。真体的行动受其心理状态驱动。人类心理状态的要素有认知（信念、知识、学习等）、情感（愿望、兴趣、爱好等）和意向（意图、目标、规划和承诺等）三种。着重研究信念（belief）、愿望（desire）和意图（intention）的关系及其形式化描述，力图建立真体的BDI（信念、愿望和意图）模型，已成为真体理论模型研究的主要方向。</p><blockquote><p>真体的特性</p></blockquote><ul><li>行为自主性：能够控制自身行为，其行为是主动的、自发的/有目标和意图的，并能根据目标和环境要求对短期行为做出规划。 </li><li>作用交互性：能够与环境交互作用，能够感知其所处环境，并借助自己的行为结果，对环境做出适当反应。 </li><li>环境协调性：真体存在于一定的环境中，感知环境的状态、事件和特征，并通过其动作和行为影响环境，与环境保持协调。环境和真体互相依存，互相作用。 </li><li>面向目标性：真体能够表现出某种目标指导下的行为，为实现其内在目标而采取主动行为。 </li><li>存在社会性：真体存在于由多个真体构成的社会环境中，与其它真体交换信息、交互作用和通讯。各真体通过社会承诺，进行社会推理，实现社会意向和目标。 </li><li>工作协调性：各真体合作和协调工作，求解单个真体无法处理的问题，提高处理问题的能力。 </li><li>运行持续性：真体的程序在起动后，能够在相当长的一段时间内维持运行状态，不随运算的停止而立即结束运行。 </li><li>系统适应性：真体不仅能够感知环境，对环境做出反应，而且能够把新建立的真体集成到系统中而无需对原有的多真体系统进行重新设计，因而具有很强的适应性和可扩展性。 </li><li>结构分布性：在物理上或逻辑上分布和异构的实体（或真体），如主动数据库、知识库、控制器和执行器等，在多真体系统中具有分布式结构，便于技术集成、资源共享、性能优化和系统整合。 </li><li>功能智能性：真体强调理性作用，可作为描述机器智能、动物智能和人类智能的统一模型。</li></ul><h3 id="自然语言理解"><a href="#自然语言理解" class="headerlink" title="自然语言理解"></a>自然语言理解</h3><blockquote><p>Natural Language Understanding 俗称人机对话。研究用电子计算机模拟人的语言交际过程，使计算机能理解和运用人类社会的自然语言如汉语、英语等，实现人机之间的自然语言通信，以代替人的部分脑力劳动，包括查询资料、解答问题、摘录文献、汇编资料以及一切有关自然语言信息的加工处理。<br>这一领域的研究涉及自然语言，即人们日常使用的语言，包括中文、英文、俄文、日文、德文、法文等等，所以它与语言学的研究有着密切的联系，但又有重要的区别。<br>自然语言处理并不是一般地研究自然语言，而在于研制能有效地实现自然语言通信的计算机系统，特别是其中的软件系统。</p></blockquote><p>实现人机间自然语言通信意味着要使计算机既能理解自然语言文本的意义(即自然语言理解)，也能以自然语言文本来表达给定的意图、思想等(即自然语言生成)。<br>无论实现自然语言理解，还是自然语言生成，都远不如人们原来想象的那么简单，而是十分困难的。从目前的理论和技术现状看，通用的、高质量的自然语言处理系统，仍然是较长期的努力目标，但是针对一定应用，具有相当自然语言处理能力的实用系统已经出现，有些已商品化，甚至开始产业化。典型的例子有：各种数据库和专家系统的自然语言接口、各种机器翻译系统、全文信息检索系统、自动文摘系统等。</p><p>自然语言处理，即实现人机间自然语言通信，或实现 <strong>自然语言理解</strong>和 <strong>自然语言生成</strong>是十分困难的。<br>造成困难的 <strong>根本原因</strong>是自然语言文本和对话的各个层次上广泛存在的各种各样的歧义性或多义性（ambiguity）。<br>一般情况下，它们中的大多数都是可以根据相应的语境和场景的规定而得到解决的。也就是说，从总体上说，并不存在歧义。这也就是我们平时并不感到自然语言歧义，和能用自然语言进行正确交流的原因。但是一方面，我们也看到，为了消解歧义，是需要极其大量的知识和进行推理的。如何将这些知识较完整地加以收集和整理出来；又如何找到合适的形式，将它们存入计算机系统中去；以及如何有效地利用它们来消除歧义，都是工作量极大且十分困难的工作。这不是少数人短时期内可以完成的，还有待长期的、系统的工作。</p><h3 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h3><ul><li>一方面，迄今为止的语法都限于分析一个孤立的句子，上下文关系和谈话环境对本句的约束和影响还缺乏系统的研究，因此分析歧义、词语省略、代词所指、同一句话在不同场合或由不同的人说出来所具有的不同含义等问题，尚无明确规律可循。</li><li>另一方面，人理解一个句子不是单凭语法，还运用了大量的有关知识，包括生活知识和专门知识，这些知识无法全部贮存在计算机里。因此一个书面理解系统只能建立在有限的词汇、句型和特定的主题范围内。</li></ul><h3 id="如何看待语言理解"><a href="#如何看待语言理解" class="headerlink" title="如何看待语言理解"></a>如何看待语言理解</h3><ul><li>从微观上讲，语言理解是指从自然语言到机器(计算机系统)内部之间的一种映射。</li><li>从宏观上看，语言理解是指机器能够执行人类所期望的某些语言功能。这些功能包括：<ul><li>回答有关提问；</li><li>提取材料摘要；</li><li>不同词语叙述；</li><li>不同语言翻译。</li></ul></li></ul><h3 id="自然语言理解的研究领域和方向"><a href="#自然语言理解的研究领域和方向" class="headerlink" title="自然语言理解的研究领域和方向"></a>自然语言理解的研究领域和方向</h3><p>文字识别、语音识别、机器翻译、自动文摘、句法分析、文本分类、信息检索、信息获取、信息过滤、自然语言生成、中文自动分词、语音合成、问答系统</p><p>用自然语言与计算机进行通信，这是人们长期以来所追求的。因为它既有明显的实际意义，同时也有重要的理论意义：人们可以用自己最习惯的语言来使用计算机，而无需再花大量的时间和精力去学习不很自然和习惯的各种计算机语言；人们也可通过它进一步了解人类的语言能力和智能的机制。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="复习" scheme="https://zhouie.cn/categories/%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="XTU" scheme="https://zhouie.cn/tags/XTU/"/>
    
      <category term="AI" scheme="https://zhouie.cn/tags/AI/"/>
    
  </entry>
  
</feed>
