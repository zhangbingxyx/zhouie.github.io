---
title: 人工智能入门复习总结
categories:
  - XTU
tags:
  - XTU
  - 专业课
  - AI
abbrlink: 201801101
date: 2018-01-10 13:03:51
---


## 绪论

### 人工智能的定义与发展

#### 定义

1. *一般解释*：人工智能就是用 **人工**的方法在 **机器（计算机）**上实现的智能，或称 **机器智能**；
2. *人工智能(学科)*：从学科的角度来说，人工智能是一门研究如何 **构造智能机器或智能系统**，使之能模拟、延伸、扩展人类智能的学科；
3. *人工智能(能力)*：从智能能力的角度来说，人工智能是智能机器所执行的通常 **与人类智能有关的智能行为**，如判断、推理、证明、识别、感知、理解、通信、设计、思考、规划、学习和问题求解等思维活动。 

<**补充**> 2018年1月发布的[人工智能标准化白皮书](https://download.csdn.net/download/jave_f/10464580)上关于“人工智能的概念”有如下一段详尽描述（仅供参考）：

>2.1.2 人工智能的概念
>
>人工智能作为一门前沿交叉学科，其定义一直存有不同的观点：**《人工智能——一种现代方法》**中将已有的一些人工智能定义分为四类：像人一样思考的系统、像人一样行动的系统、理性地思考的系统、理性地行动的系统。**维基百科**上定义“人工智能就是机器展现出的智能”，即只要是某种机器，具有某种或某些“智能”的特征或表现，都应该算作“人工智能”。**大英百科全书**则限定人工智能是数字计算机或者数字计算机控制的机器人在执行智能生物体才有的一些任务上的能力。**百度百科**定义人工智能是“研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门新的技术科学”，将其视为计算机科学的一个分支，指出其研究包括机器人、语言识别、图像识别、自然语言处理和专家系统等。
>
>本白皮书认为，**人工智能是利用数字计算机或者数字计算机控制的机器模拟、延伸和扩展人的智能，感知环境、获取知识并使用知识获得最佳结果的理论、方法、技术及应用系统。**
>
>人工智能的定义对人工智能学科的基本思想和内容作出了解释，即围绕智能活动而构造的人工系统。人工智能是知识的工程，是机器模仿人类利用知识完成一定行为的过程。根据人工智能是否能真正实现推理、思考和解决问题，可以将人工智能分为弱人工智能和强人工智能。
>
>**弱人工智能**是指不能真正实现推理和解决问题的智能机器，这些机器表面看像是智能的，但是并不真正拥有智能，也不会有自主意识。迄今为止的人工智能系统都还是实现特定功能的专用智能，而不是像人类智能那样能够不断适应复杂的新环境并不断涌现出新的功能，因此都还是弱人工智能。目前的主流研究仍然集中于弱人工智能，并取得了显著进步，如语音识别、图像处理和物体分割、机器翻译等方面取得了重大突破，甚至可以接近或超越人类水平。
>
>**强人工智能**是指真正能思维的智能机器，并且认为这样的机器是有知觉的和自我意识的，这类机器可分为类人（机器的思考和推理类似人的思维）与非类人（机器产生了和人完全不一样的知觉和意识，使用和人完全不一样的推理方式）两大类。从一般意义来说，达到人类水平的、能够自适应地应对外界环境挑战的、具有自我意识的人工智能称为“通用人工智能”、“强人工智能”或“类人智能”。强人工智能不仅在哲学上存在巨大争论（涉及到思维与意识等根本问题的讨论），在技术上的研究也具有极大的挑战性。强人工智能当前鲜有进展，美国私营部门的专家及国家科技委员会比较支持的观点是，至少在未来几十年内难以实现。
>
>靠符号主义、连接主义、行为主义和统计主义这四个流派的经典路线就能设计制造出强人工智能吗？其中一个主流看法是：即使有更高性能的计算平台和更大规模的大数据助力，也还只是量变，不是质变，人类对自身智能的认识还处在初级阶段，在人类真正理解智能机理之前，不可能制造出强人工智能。理解大脑产生智能的机理是脑科学的终极性问题，绝大多数脑科学专家都认为这是一个数百年乃至数千年甚至永远都解决不了的问题。
>
>通向强人工智能还有一条“新”路线，这里称为“仿真主义”。这条新路线通过制造先进的大脑探测工具从结构上解析大脑，再利用工程技术手段构造出模仿大脑神经网络基元及结构的仿脑装置，最后通过环境刺激和交互训练仿真大脑实现类人智能，简言之，“先结构，后功能”。虽然这项工程也十分困难，但都是有可能在数十年内解决的工程技术问题，而不像“理解大脑”这个科学问题那样遥不可及。
>
>仿真主义可以说是符号主义、连接主义、行为主义和统计主义之后的第五个流派，和前四个流派有着千丝万缕的联系，也是前四个流派通向强人工智能的关键一环。经典计算机是数理逻辑的开关电路实现，采用冯•诺依曼体系结构，可以作为逻辑推理等专用智能的实现载体。但要靠经典计算机不可能实现强人工智能。要按仿真主义的路线“仿脑”，就必须设计制造全新的软硬件系统，这就是“类脑计算机”，或者更准确地称为“仿脑机”。“仿脑机”是“仿真工程”的标志性成果，也是“仿脑工程”通向强人工智能之路的重要里程碑。

#### 起源与发展

人工智能始于20世纪50年代，50多年来，人工智能走过了一条起伏和曲折的发展道路。回顾历史，可以按照不同时期的主要特征，将其产生与发展过程分为5个阶段。

1、孕育期（1956年前）

2、形成期（1956-1970年）

1956年夏，麦卡锡 (J.McCarthy，数学家、计算机专家)、明斯基(M.L.Minsky，哈佛大学数学家、神经学家)、洛切斯特(N.Lochester，IBM公司信息中心负责人)、香农(C.E.Shannon，贝尔实验室信息部数学家和信息学家)
邀请莫尔(T.more)、塞缪尔(A.L.Samuel) 、塞尔夫里奇(O.Selfridge)、索罗蒙夫(R.Solomonff)、纽厄尔(A.Newell)、西蒙(H.A.Simon)在 **美国达特莫斯(Dartmouth)大学**举办了长达历时两个月的研讨会。会上，麦卡锡正式使用“人工智能AI”这一术语。这是人类历史上首次第一次人工智能研讨会，**标志着人工智能学科的诞生**。

3、暗淡期（1966-1974年）

* 失败的预言给人工智能的声誉造成重大伤害

60年代初，西蒙预言：10年内计算机将成为世界冠军、将证明一个未发现的数学定理、将能谱写出具有优秀作曲家水平的乐曲、大多数心理学理论将在计算机上形成。

* 挫折和困境

    - **在博弈方面**：塞缪尔的下棋程序在与世界冠军对弈时，5局败了4局。
    - **在定理证明方面**：发现鲁宾逊归结法的能力有限。当用归结原理证明两个连续函数之和还是连续函数时，推了10万步也没证出结果。
    - **在问题求解方面**：对于不良结构，会产生组合爆炸问题。
    - **在机器翻译方面**：发现并不那么简单，甚至会闹出笑话。例如，把“心有余而力不足”的英语句子翻译成俄语，再翻译回来时竟变成了“酒是好的，肉变质了”
    - **在神经生理学方面**：研究发现人脑有1011-12以上的神经元，在现有技术条件下用机器从结构上模拟人脑是根本不可能的。
    - **在其它方面**：人工智能也遇到了不少问题。在英国，剑桥大学的詹姆教授指责“人工智能研究不是骗局，也是庸人自扰” 。从此，形势急转直下，在全世界范围内人工智能研究陷入困境、落入低谷。 

* Minsky的批评

1969年 M. Minsky 和 S. Papert 在《感知机》一书中指出了感知机无法解决异或（XOR）问题的缺陷，并表示出对这方面研究的悲观态度，使得神经网络的研究从兴起期进入了停滞期。 
该批评对人工智能的发展造成了重要的影响
    - 在以后的二十年，感知机的研究方向被忽视
    - 基于符号的知识表示成为主流
    - 基于逻辑的推理成为主要研究方向

* 当时的人工智能存在三个方面的局限性

    - **知识局限性**：早期开发的人工智能程序中包含了太少的主题知识，甚至没有知识，而且只采用简单的句法处理。
    - **解法局限性**：求解方法和步骤的局限性使得设计的人工智能程序在实际上无法求得问题的解答，或者只能得到简单问题的解答，而这种简单问题并不需要人工智能的参与。
    - **结构局限性**：用于产生智能行为的人工智能系统或程序在一些基本结构上严重局限，如没有考虑不良结构，无法处理组合爆炸问题，因而只能用于解决比较简单的问题，影响到人工智能系统的推广应用。

4、知识应用期（ 1970-1988年）

5、集成发展期（1986年至今）

人工智能具体的发展历程图示如下：
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/AI_history.jpg)

这两年人工智能得到了突飞猛进的发展，实现这种发展的基本条件有三个：

* 大数据的积累
* 计算能力的提升
* 理论算法的革新

### 各种认知观

>目前人工智能主要有以下三个学派：

* **符号主义**（Symbolicism）: 基于物理符号系统假设和有限合理性原理（逻辑）

符号主义观点认为：智能的基础是知识，**其核心是知识表示和知识推理**；知识可用符号表示，也可用符号进行推理，因而可以建立基于知识的人类智能和机器智能的统一的理论体系。

* **连接主义****（Connectionism）: 基于神经网络及其间的连接机制与学习算法（仿生）

连接主义观点认为：**思维的基元是神经元**，而不是符号；思维过程是神经元的联结活动过程，而不是符号运算过程；反对符号主义关于物理符号系统的假设。

* **行为主义**（Actionism）: 基于控制论及感知—动作型控制系统（进化）

行为主义观点认为：**智能取决于感知和行动**，提出了智能行为的“感知—动作”模型；**智能不需要知识、不需要表示、不需要推理**；人工智能可以像人类智能那样逐步进化。

此外，还有一种由[钟义信](https://baike.baidu.com/item/%E9%92%9F%E4%B9%89%E4%BF%A1/7371623?fr=aladdin)院士提出的一种认知学派：

* **机制主义**（mechanism）：结构（连接）主义、功能（符号）主义、行为主义的和谐统一。

>几种学派各自不足之处：

* **符号主义的不足**(功能模拟法/认知学观点)
    - 在用符号表示知识的概念时，有效性很大程度上取决于符号表示的正确性和准确性
    - 将知识概念转换成符号时，可能丢失一些重要信息
    - 难于对含噪信息、不确定性信息和不完全性信息进行处理

* **连接主义的不足**(结构模拟法/生物学观点)
    - 由于大脑的生理结构和工作机理还远未搞清楚，因而现在只能对人脑的局部进行模拟或进行近似模拟
    - 不适合模拟人的逻辑思维过程
    - 受大规模人工神经网络制造的制约
    - 尚不能满足人脑完全模拟的要求

* **行为主义的不足**
    - 难以获得高级智能控制行为

### 研究目标与内容

#### 研究目标

* 远期目标
构造出可以实现人类思维活动和智力功能的智能系统。

* 近期目标
使现有的计算机更聪明更有用，使它不仅能够进行一般的数值计算和非数值信息的处理，而且能够运用知识去处理问题，能够模拟人类的智能行为。

#### 研究的基本内容

1、认知建模
认知：可一般地认为是和情感、动机、意志相对应的理智或认识过程，或者是为了一定的目的，在一定的心理结构中进行的信息加工过程。

2、知识表示：基础

3、知识推理：实现问题求解

4、知识应用：目的

> 知识表示、知识推理、知识应用是传统人工智能的三大核心研究内容。

5、机器感知：就是要让计算机具有类似于人的感知能力，如视觉、听觉、触觉、嗅觉、味觉……，是机器获取外部信息的基本途径
* 相当于智能系统的输入部分
* 机器视觉（或叫计算机视觉）：就是给计算机配上能看的视觉器官，如摄像机等，使它可以识别并理解文字、图像、景物等
* 机器听觉（或叫计算机听觉）：就是给计算配上能听的听觉器官，如话筒等，使计算机能够识别并理解语言、声音等。
* 模式识别：对客体的识别与分类
* 自然语言理解：实现人机对话
* 机器翻译

6、机器思维：
机器思维是让计算机能够对感知到的外界信息和自己产生的内部信息进行思维性加工，包括逻辑思维、形象思维和灵感思维，涉及信息的表示，组织，积累，管理，搜索，推理等过程。

7、机器学习：
* 让计算机能够像人那样自动地获取新知识，并在实践中不断地完善自我和增强能力。
* 是机器获取智能的途径
* 学习是一个有特定目的的知识获取过程，学习的本质是对信息的理解与应用

8、机器行为：
* 让计算机能够具有像人那样地行动和表达能力，如走、跑、拿、说、唱、写画等。
* 相当于智能系统的输出部分

9、智能系统构建
* 无论是人工智能的近期目标还是远期目标，都需要建立智能系统或构造智能机器
* 需要开展对系统模型、构造技术、构造工具及语言环境等研究

### 应用领域

问题求解、机器学习、自然语言理解、专家系统、模式识别、计算机视觉、机器人学、博弈、计算智能、人工生命、自动定理证明、自动程序设计、智能控制、智能检索、智能调度与指挥、智能决策支持系统、人工神经网络、数据挖掘与知识发现......

### 课后习题

1-1 什么是人工智能？是从科学与能力两方面加以说明。
1-3 在人工智能的发展过程中，有哪些思想和思潮起到了重要作用？
1-5 人工智能有哪些学派？他们的认知观是什么？现在这些学派的关系如何？
1-9 人工智能的基本研究方法有哪些类？
1-10 人工智能的主要研究和应用领域是什么？其中，哪些是新的研究热点？

## 知识表示与推理

### 知识表示方法

>知识的一般概念

知识是人们在改造客观世界的实践中积累起来的 **认识**和 **经验**。
其中，**认识**与 **经验**可以这样定义：
* 认识：包括对事物现象、本质、属性、状态、联系等的认识
* 经验：包括解决问题的微观方法和宏观方法
    - 微观方法：如步骤、操作、规则、过程、技巧等
    - 宏观方法：如战略、战术、计谋、策略等

>人工智能系统中的知识

一个智能程序高水平的运行需要有关的 **事实知识**、 **规则知识**、 **控制知识**和 **元知识**。

* 事实知识 ：是有关问题环境的一些事物的知识，常以“…是…”的形式出现。
    - 如事物的分类、属性、事物间关系、科学事实、客观事实等。
    - 事实是静态的为人们共享的可公开获得的公认的知识，在知识库中属低层的知识，如：雪是白色的、鸟有翅膀、张三李四是好朋友、这辆车是张三的……
* 规则知识 ：是有关问题中与事物的行动、动作相联系的因果关系知识，是动态的，常以“如果…那么…” 形式出现。
* 控制知识 ：是有关问题的求解步骤、技巧的知识，告诉人们怎么做一件事，也包括当有多个动作同时被激活时应选哪一个动作来执行的知识。控制知识常与程序结合在一起出现，如一个问题求解的算法可以看做是一种知识表示。
* 元知识 ：是有关知识的知识，是知识库中的高层知识。包括怎样使用规则、解释规则、校验规则、解释程序结构等知识。

元知识与控制知识是有重迭的，对一个大的程序来说，以元知识或说元规则形式体现控制知识更为方便，因为元知识存于知识库中，而控制知识常与程序结合在一起出现，从而不容易修改。 

>知识表示

研究用机器表示知识的可行性、有效性的一般方法，是一种数据结构与控制结构的统一体，既考虑知识的存储又考虑知识的使用。

知识表示的要求：
* 表示能力：能否正确、有效地表示问题。包括：表范围的广泛性、领域知识表示的高效性、对非确定性知识表示的支持程度；
* 可利用性：可利用这些知识进行有效推理。包括：对推理的适应性，对高效算法的支持程度；
* 可实现性：要便于计算机直接对其进行处理；
* 可组织性：可以按某种方式把知识组织成某种知识结构；
* 可维护性：便于对知识的增、删、改等操作；
* 自然性：符合人们的日常习惯；
* 可理解性：知识应易读、易懂、易获取等。

#### 状态空间法

状态空间法的三要素： 
1. **状态**（state）：描述某类不同事物间的差别而引入的一组最少变量 q0，q1，…，qn的有序集合，是表示问题解法中每一步问题状况的数据结构。有序集合中每个元素qi（i= 0,1,...,n）为集合的分量，称为状态变量。给定每个分量的一组值就得到一个具体的状态。
2. **算符**（operator）：使问题从一种状态变化为另一种状态的手段称为操作符或算符。
3. **问题的状态空间****：即解答空间，也就是一个表示该问题全部可能状态及其关系的图。它是以状态和算符为基础来表示和求解问题的。它包含三种说明的集合，即S：所有可能的问题初始状态集合、F：操作符集合、G：目标状态集合。可将状态空间记为三元状态`（S，F，G）`。

---

【例子】 
**猴子和香蕉问题**：在一个房间内有一只猴子、一个箱子和一束香蕉。香蕉挂在天花板下方，但猴子的高度不足以碰到它。那么这只猴子怎样才能摘到香蕉呢?

![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E7%8C%B4%E5%AD%90%E6%91%98%E9%A6%99%E8%95%89.jpg)

**解题过程**
用一个四元表列`(W，x，Y，z)`来表示这个问题状态空间 
其中W：猴子的水平位置；x：当猴子在箱子顶上时取1；否则取0；Y：箱子的水平位置；z：当猴子摘到香蕉时取1；否则取0。 
则可见初始状态为`(a,0,b,0)`，目标状态为`(c,1,c,1)` 

这个问题的算符如下： 
`goto(U)`表示猴子走到水平位置U；`pushbox(V)`表示猴子把箱子推到水平位置V；`climbbox`表示猴子爬上箱顶；`grasp`表示猴子摘到香蕉。

由初始状态变换为目标状态的操作序列为：
    Step1: `goto(b) `
    Step2: `pushbox(c) `
    Step3: `climbbox `
    Step4: `grasp `
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E7%8A%B6%E6%80%81%E7%A9%BA%E9%97%B4%E6%B3%95.jpg)

---

#### 问题归约法

> 问题规约（Problem Reduction）：

* 另外一种 **基于状态空间**的问题描述与求解方法；
* 已知问题的描述，通过一系列 **变换** 把此问题变为一个 **子问题集合**；
* 这些子问题的解可以直接得到（**本原问题**），从而解决了初始问题。

> 问题归约的组成部分：

* 一个初始问题描述；
* 一套把问题变换为子问题的 **操作符**；
* 一套本原问题描述。(本原问题:不能再分解或变换且直接可解的子问题)。

> 问题归约的 **实质**：

* 从目标（要解决的问题）出发 **逆向推理**，建立子问题以及子问题的子问题，直到 **最后把初始问题归约为一个本原问题集合**。

> 问题归约法举例：

---

【例子】
**汉诺塔问题**(Hanoi):规定每次移动一个盘子、且总个过程中大盘在下小盘在上、目标是将盘子从柱子1移到柱子3。

![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/Hanoi.jpg)

**解题过程**

原始问题可以归约为下列3个子问题：

![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E9%97%AE%E9%A2%98%E8%A7%84%E7%BA%A6%E6%B3%95.jpg)

规约过程：

![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E8%A7%84%E7%BA%A6%E8%BF%87%E7%A8%8B.jpg)

归约图示：

![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E8%A7%84%E7%BA%A6%E5%9B%BE.jpg)

---

>与或图表示

用一个类似于图的结构来表示,把问题归约为后继问题的替换集合。
* 与图：把一个复杂问题分解为若干个较为简单的子问题，形成“与”树。
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E4%B8%8E%E5%9B%BE.jpg)

* 或图：把原问题变换为若干个较为容易求解的新问题，形成“或”树。
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%88%96%E5%9B%BE.jpg)

#### 谓词逻辑法
##### 谓词演算

>语法和语义

* 基本符号：谓词符号、变量符号、函数符号、常量符号、括号和逗号
* 原子公式由若干谓词符号和项组成

>连词和量词

* 连词
合取、析取、蕴涵、非、双条件

* 量词
全称量词、存在量词

>谓词公式

* 原子谓词公式
由谓词符号和若干项组成的谓词演算

* 分子谓词公式
可以用 **连词**把原子谓词公式组成复合谓词公式，并把它叫做分子谓词公式
通常把合式公式叫做谓词公式。在谓词演算中合式公式的递归定义如下：
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E5%90%88%E5%BC%8F%E5%85%AC%E5%BC%8F.jpg)

>合式公式的性质

![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%80%A7%E8%B4%A8.jpg)

##### 置换与合一

>置换

置换是用变元、常量、函数来替换变元，使该变元不在公式中出现，形如`{t1/x1, t2/x2,...，tn/xn}`的有限集合，其中：
* `t1，t2，...，tn`是项；
* `x1，x2，...，xn`是互不相同的变元；
* `ti/xi`表示用ti项替换变元`xi`，不允许`ti`和`xi`相同，也不允许变元`xi`循环地出现在另一个tj中。

推理规则：用合式公式的集合产生新的合式公式
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%8E%A8%E7%90%86%E8%A7%84%E5%88%99.jpg)

置换是 **可结合的**；
用`s1s2`表示两个置换s1和s2的合成，L表示一个表达式，则有`(Ls1)s2 = L(s1s2)`以及`(s1s2)s3 = s1(s2s3)`，即用s1和s2相继作用于表达式L是与用`s1s2`作用于L一样的。
一般说来，置换是 **不可交换的**，即`s1s2 ≠ s2s1`。

>合一

寻找项对变量的置换，以使两表达式一致，叫做合一。
如果一个置换s作用于表达式集合`{Ei}`的每个元素，则用`{Ei}s`来表示置换的集。称表达式{Ei}是可合一的，如果存在一个置换s使得：`E1s = E2s =  E3s =……`，那么，称此s为`{Ei}`的合一者，因为s的作用是使集合`{Ei}`成为单一形式。
例如：设有公式集`E={ P( x, y, f(y)),  P( a, g(x), z) }`，则`s={a/x, g(a)/y, f(g(a))/z}`是它的一个合一。


#### 语义网路法

语义网络是通过概念及其语义关系来表达知识一种网络图。从图论的观点看，语义网络是一个“带标识的有向图”，节点代表实体、概念、情况等，弧代表语义关系，必须带标识。

语义网络中最基本的语义单元称为语义基元，可用三元组表示为：(结点1，弧，结点2)。

> 二元语义网络的表示

例如：用语义网络表示：李新的汽车的款式是“捷达”、银灰色；王红的汽车的款式是“凯越”、红色；李新和王红的汽车均属于具体概念,可增加“汽车” 这个抽象概念。
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E8%AF%AD%E4%B9%89%E7%BD%91%E7%BB%9C.jpg)

> 多元语义网络的表示

* 增加情况和动作节点；
* 增加事件节点；
* 连接词和量词的表示；
* ......


#### 其他方法

* 框架表示法
框架理论是明斯基于1975年作为理解视觉、自然语言对话及其它复杂行为的一种基础提出来的。
框架理论认为，人们对现实世界中各种事物的认识都是以一种类似于框架的结构存储在记忆中的。当遇到一个新事物时，就从记忆中找出一个合适的框架，并根据新的情况对其细节加以修改、补充，从而形成对这个新事物的认识。

框架网络：
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%A1%86%E6%9E%B6%E7%BD%91%E7%BB%9C.jpg)

框架结构：
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%A1%86%E6%9E%B6%E7%BB%93%E6%9E%84.jpg)
* 每个框架都有框架名，代表某一类对象
* 一个框架由若干个槽（项目）组成，用于表示对象的某个方面的属性
* 有时一个槽（属性）还要从不同的侧面来描述，每个侧面可具有一个或多个值。
注意：框架中的槽与侧面可任意定义，也可以是另一框架，形成框架网络。

* 剧本表示法(ppt-6)
* 过程表示法(ppt-6)
* ......

### 确定性推理

#### 推理的基本概念

>推理方法及其分类

1. 按推理的逻辑基础分：演绎推理，归纳推理，类比归纳推理
2. 按推理过程所用知识的确定性分：确定性推理、 不确定性推理
3. 按推理过程推出的结论是否单调增加分：单调推理、非单调推理
4. 按推理过程是否利用问题的启发性知识分：启发式推理、非启发式推理

>推理的控制策略及其分类

推理的控制策略是指如何使用领域知识使推理过程尽快达到目标的策略。

* 推理策略
    - **推理方向控制策略**可分为
        + 正向推理
        + 逆向推理
        + 混合推理
        + 双向推理
    - **求解策略**：是指仅求一个解，还是求所有解或最优解等。
    - **限制策略**：是指对推理的深度、宽度、时间、空间等进行的限制。
    - **冲突消解策略**：是指当推理过程有多条知识可用时，如何从这多条可用知识中选出一条最佳知识用于推理的策略。
* 搜索策略（下面会详述）

#### 搜索策略

* 按是否使用启发式信息：
    - 盲目搜索：按预定的控制策略进行搜索，在搜索过程中获得的中间信息并不改变控制策略。 
    - 启发式搜索：在搜索中加入了与问题有关的启发性信息，用于指导搜索朝着最有希望的方向前进，加速问题的求解过程并找到最优解。 
* 按问题的表示方式：
    - 状态空间搜索：用指用状态空间法来表示问题所进行的搜索 
    - 与或树搜索：用指用问题归约法来表示问题所进行的搜索 

##### 状态空间的搜索策略

* 状态空间的盲目搜索
    - 广度优先搜索
    - 深度优先搜索
    - 代价树搜索
* 状态空间的启发式搜索
    - 启发性信息和估价函数
    - A算法和A*算法
* 基本思想
    - 先把问题的初始状态作为当前扩展节点对其进行扩展，生成一组子节点。
    - 然后检查问题的目标状态是否出现在这些子节点中。若出现，则搜索成功，找到了问题的解；若没出现，则再按照某种搜索策略从已生成的子节点中选择一个节点作为当前扩展节点。
    - 重复上述过程，直到目标状态出现在子节点中或者没有可供操作的节点为止。
    - 所谓对一个节点进行“扩展”是指对该节点用某个可用操作进行作用，生成该节点的一组子节点。 
* 数据结构和符号约定
    - **OPEN表**：未扩展节点表，用于存放刚生成节点
    - **CLOSED表**：已扩展节点表，用于存放已经扩展或将要扩展的节点
    - S：用表示问题的初始状态
    - G：表示搜索过程所得到的搜索图
    - M：表示当前扩展节点新生成的且不为自己先辈的子节点集

*各种搜索策略的主要区别在于对OPEN表中节点的排列顺序不同。*例如，广度优先搜索把先生成的子节点排在前面，而深度优先搜索则把后生成的子节点排在前面。

>广度优先搜索算法流程：

1. 把初始节点S放入OPEN表中；
2. 如果OPEN表为空，则问题无解，失败退出；
3. 把OPEN表的第一个节点取出放入CLOSED表，并记该节点为n；
4. 考察节点n是否为目标节点。若是，则得到问题的解，成功退出；
5. 若节点n不可扩展，则转第(2)步；
6. 扩展节点n，将其子节点放入OPEN表的 **尾部**，并为每一个子节点设置指向父节点的指针，然后转第(2)步。

以八数码问题为例，得到下面这个广度优先搜索树：
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88.jpg)

在上述广度优先算法中需要注意两个问题：
* 对于任意一个可扩展的节点，总是按照固定的操作符的顺序对其进行扩展（空格左移、上移、右移、下移）。
* 在对任一节点进行扩展的时候，如果所得的某个子节点（状态）前面已经出现过，则立即将其放弃，不再重复画出（不送入OPEN表）。
因此，广度优先搜索的本质是，以初始节点为根节点，在状态空间图中按照广度优先的原则，生成一棵搜索树。

广度优先搜索的优缺点：
* 优点
    - 只要问题有解，用广度优先搜索总可以得到解，而且得到的是路径最短的解。
* 缺点
    - 广度优先搜索盲目性较大，当目标节点距初始节点较远时将会产生许多无用节点，搜索效率低。

>深度优先搜索算法流程： 

1. 把初始节点S放入OPEN表中；
2. 如果OPEN表为空，则问题无解 ，失败退出；
3. 把OPEN表的第一个节点取出放入CLOSED表，并记该节点为n；
4. 考察节点n是否为目标节点。若是，则得到问题的解，成功退出；
5. 若节点n不可扩展，则转第(2)步； 
6. 扩展节点n，将其子节点放入OPEN表的 **首部**，并为每一个子节点设置 指向父节点的指针，然后转第(2)步。

在深度优先搜索中，搜索一旦进入某个分支，就将沿着该分支一直向下搜索。如果目标节点恰好在此分支上，则可较快地得到解。但是，如果目标节点不在此分支上，而该分支又是一个无穷分支，则就不可能得到解。所以深度优先搜索是不完备的，即使问题有解，它也不一定能求得解。
因此，为了防止搜索过程沿着无益的路径扩展下去，往往给出一个节点扩展的最大深度，即 **深度界限**。当搜索深度达到了深度界限而仍未出现目标节点时，就换一个分支进行搜索。

有界深度优先搜索的特点：
* 如果问题有解，且其路径长度≤dm，则上述搜索过程一定能求得解。
* 但是若解的路径长度> dm,则上述搜索过程就得不到解。。
* 这说明在有界深度优先搜索中，深度界限的选择是很重要的，但是要恰当地给出dm的值是比较困难的。
* 即使能求出解，它也不一定是最优解。

>代价树搜索

考虑边的代价的搜索方法，代价树搜索的目的是为了找到一条代价最小的解路径。代价树搜索方法包括：
* 代价树的广度优先搜索
* 代价树的深度优先搜索

>启发式信息与代价函数

采用问题自身的特性信息，以指导搜索朝着最有希望的方向前进。
启发性信息是指那种与具体问题求解过程有关的，并可指导搜索过程朝着最有希望方向前进的控制信息。启发信息的启发能力越强，扩展的无用结点越少。

启发性信息的种类
* 有效地帮助确定扩展节点的信息；
* 有效的帮助决定哪些后继节点应被生成的信息；
* 能决定在扩展一个节点时哪些节点应从搜索树上删除的信息。

估价函数的一般形式为：`f(x) = g(x)+h(x)`，其中`g(x)`表示从初始节点S0到节点x的代价；`h(x)`是从节点x到目标节点Sg的最优路径的代价的估计，它体现了问题的启发性信息，`h(x)`称为启发函数。

>A算法与A*算法

A算法：在图搜索算法中，如果能在搜索的每一步都利用估价函数`f(n)=g(n)+h(n)`对OPEN表中的节点进行排序，则该搜索算法为A算法。

A算法的类型
可根据搜索过程中选择扩展节点的范围，将启发式搜索算法分为：
* 全局择优搜索算法： 从OPEN表的所有节点中选择一个估价函数值最小的一个进行扩展。
* 局部择优搜索算法：仅从刚生成的子节点中选择一个估价函数值最小的一个进行扩展。

A*算法是对A算法的估价函数`f(n)=g(n)+h(n)`加上某些限制后得到的一种启发式搜索算法。

假设`f*(n)`是从初始节点出发经过节点n达到目标节点的最小代价，估价函数`f(n)`是对`f*(n)`的 **估计值**。且`f*(n)=g*(n)+h*(n)`，`g*(n)`是从初始节点S0到节点n的最小代价。`h*(n)`是从节点n到目标节点的最小代价，**若有多个目标节点，则为其中最小的一个**。

A*算法对A算法（全局择优的启发式搜索算法）中的`g(n)`和`h(n)`分别提出如下限制：

* 第一，`g(n)`是对最小代价`g*(n)`的估计，且`g(n)>0`；
* 第二，`h(n)`是最小代价`h*(n)`的下界，即对任意节点n均有`h(n)≤h*(n)`。

即：满足上述两条限制的A算法称为A*算法。


##### 与/或树的搜索策略(ppt-9~10)

1、 与/或树的一般搜索过程

```
(1) 把原始问题作为初始节点S0，并把它作为当前节点； 
(2) 应用分解或等价变换操作对当前节点进行扩展； 
(3) 为每个子节点设置指向父节点的指针； 
(4) 选择合适的子节点作为当前节点，反复执行第(2)步和第(3)步，在此期间需要多次调用可解标记过程或不可解标记过程，直到初始节点被标记为可解节点或不可解节点为止。
```

2、 与/或树的广度优先搜索

```
(1)把初始节点S0放入OPEN表中； 
(2)把OPEN表的第一个节点取出放入CLOSED表，并记该节点为n； 
(3)如果节点n可扩展，则做下列工作：
    ① 扩展节点n，将其子节点放入OPEN表的尾部，并为每一个子节点设置指向父节点的指针；
    ② 考察这些子节点中有否终止节点。若有，则标记这些终止节点为可解节点，并用可解标记过程对其父节点及先辈节点中的可解解节点进行标记。如果初始解节点S0能够被标记为可解节点，就得到了解树，搜索成功，退出搜索过程；如果不能确定S0为可解节点，则从OPEN表中删去具有可解先辈的节点。
    ③ 转第(2)步。
(4) 如果节点n不可扩展，则作下列工作： 
    ① 标记节点n为不可解节点；
    ② 应用不可解标记过程对节点n的先辈中不可解解的节点进行标记。如果初始解节点S0也被标记为不可解节点，则搜索失败，表明原始问题无解，退出搜索过程；如果不能确定S0为不可解节点，则从Open表中删去具有不可解先辈的节点。
    ③ 转第(2)步。  
```

---

【例子】 设有下图所示的与/或树，节点按标注顺序进行扩展，其中标有t1、t2、t3的节点是终止节点，A、B、C为不可解的端节点。
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E4%BE%8B%E5%AD%90.jpg)

本例中与/或树的广度优先搜索过程：

(1) 先扩展1号节点，生成2号节点和3号节点。 
(2) 扩展2号节点，生成A节点和4号节点。
(3) 扩展3号节点，生成t1节点和5号节点。由于t1为终止节点，则标记它为可解节点，并应用可解标记过程，不能确定3号节点是否可节。
(4)  扩展节点A，由于A是端节点，因此不可扩展。调用不可解标记过程。
(5) 扩展4号节点，生成t2节点和B节点。由于t2为终止节点，标记为可解节点，应用可解标记过程，可标记2号节点为可解，但不能标记1号节点为可解。
(6) 扩展5号节点，生成t3节点和C节点。由于t3为终止节点，标记它为可解节点，应用可解标记过程，可标记1号节点为可解节点。
(7) 搜索成功，得到由1、2、3、4、5号节点和t1、t2、t3节点构成的解树。

---

3、 与/或树的深度优先搜索

```
(1)把初始节点S0放入OPEN表中； 
(2)把OPEN表第一个节点取出放入CLOSED表，并记该节点为n； 
与/或树的深度优先搜索算法如下：
(3)如果节点n的深度等于dm，则转第(5)步的第①点； 
(4)如果节点n可扩展，则做下列工作： 
    ① 扩展节点n，将其子节点放入OPEN表的首部，并为每一个子节点设置指向父节点的指针；  
    ② 考察这些子节点中是否有终止节点。若有，则标记这些终止节点为可解节点，并用可解标记过程对其父节点及先辈节点中的可解解节点进行标记。如果初始解节点S0能够被标记为可解节点，就得到了解树，搜索成功；如果不能确定S0为可解节点，则从OPEN表中删去具有可解先辈的节点。
    ③ 转第(2)步。 
(5)如果节点n不可扩展，则作下列工作： 
    ① 标记节点n为不可解节点；
    ② 应用不可解标记过程对节点n的先辈中不可解解的节点进行标记。如果初始解节点S0也被标记为不可解节点，则搜索失败，表明原始问题无解，退出搜索过程；如果不能确定S0为不可解节点，则从Open表中删去具有不可解先辈的节点。
    ③ 转第(2)步。
```

4、 与/或树的启发式搜索

```
(1) 把初始节点S0放入OPEN表中；
(2) 求出希望树T，即根据当前搜索树中节点的代价h求出以S0为根的希望树T； 
(3) 依次在OPEN表中取出T的端节点放入CLOSED表，并记该节点为n；节点n有三种不同情况：
    ①n为终止节点，
    ②n不是终止节点，但可扩展，
    ③n不是终止节点，且不可扩展，
对三种情况分别进行步骤(4) (5) (6)的操作过程； 
(4)如果节点n为终止节点，则： 
    ① 标记节点n为可解节点；
    ② 在T上应用可解标记过程，对n的先辈节点中的所有可解解节点进行标记；
    ③ 如果初始解节点S0能够被标记为可解节点，则T就是最优解树，成功退出；
    ④ 否则，从OPEN表中删去具有可解先辈的所有节点。 
    ⑤ 转第(2)步。 
(5) 如果节点n不是终止节点，但可扩展，则： 
    ① 扩展节点n，生成n的所有子节点；
    ② 把这些子节点都放入OPEN表中，并为每一个子节点设置指向父节点n的指针；
    ③ 计算这些子节点及其先辈节点的h值；
    ④ 转第(2)步。
(6) 如果节点n不是终止节点，且不可扩展，则： 
    ① 标记节点n为不可解节点；
    ② 在T上应用不可解标记过程，对n的先辈节点中的所有不可解解节点进行标记；
    ③ 如果初始解节点S0能够被标记为不可解节点，则问题无解，失败退出；
    ④ 否则，从OPEN表中删去具有不可解先辈的所有节点。 
    ⑤ 转第(2)步。
```

5、 博弈树的启发式搜索
6、 α-β剪枝技术

>搜索的完备性与效率

**完备性**
* 对于一类 **可解的问题**和一个搜索过程，如果运用该搜索过程一定能求得该类问题的解，则称该搜索过程为 **完备**的，否则为不完备的。
* 完备的搜索过程称为“搜索算法”。不完备的搜索过程不是算法，称为“过程”。
* 广度优先搜索、代价树的广度优先搜索、改进后的有界深度优先搜索以及A*算法都是完备的搜索过程，其它搜索过程都是不完备的。

**搜索效率**
* 一个搜索过程的搜索效率不仅取决于过程自身的启发能力，而且还与被解问题的有关属性等多种因素有关。
* 为了比较求解同一问题的不同搜索方法的效率，常用以下两种指标来衡量：
    - **外显率**
    - **有效分支因数**

其中，外显率定义为：`P=L/T`；L为从初始节点到目标节点的路径长度；T为整个搜索过程中所生成的节点总数。
外显率反映了搜索过程中从初始节点向目标节点前进时 **搜索区域的宽度**。当`T=L`时，`P=1`，表示搜索过程中每次只生成一个节点，它恰好是解路径上的节点，搜索效率最高。P越小表示搜索时产生的无用节点愈多，搜索效率愈低。

有效分枝因数B定义为：`B+B^2+…+B^L=T`；B是有效分枝因数，它表示在整个搜索过程中 **每个节点平均生成的子节点数目**；L为从初始节点到目标节点的路径长度；T为整个搜索过程中所生成的节点总数。当`B＝1`时，`L=T`，此时所生成的节点数最少，搜索效率最高。


#### 自然演绎推理

从一组已知为真的事实出发，直接运用经典逻辑中的推理规则推出结论的过程称为自然演绎推理。
自然演绎推理最基本的推理规则是三段论推理，它包括：
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E8%87%AA%E7%84%B6%E6%BC%94%E7%BB%8E%E6%8E%A8%E7%90%86.jpg)

---

【例子】 设已知如下事实：
(1) 只要是需要编程序的课，王程都喜欢。
(2) 所有的程序设计语言课都是需要编程序的课。
(3) C是一门程序设计语言课。
求证：王程喜欢C这门课。

证明：
第一步，首先定义谓词
    `Prog(x)`：x是需要编程序的课。
    `Like(x, y)`: x喜欢y。
    `Lang(x)`: x是一门程序设计语言课
第二步，把已知事实及待求解问题用谓词公式表示如下：
    `Prog(x)→Like(Wang , x)`
    `(∀x)( Lang(x)→Prog(x))`
    `Lang(C)`
第三步，应用推理规则进行推理：
    `Lang(y)→Prog(y)`                                    全称固化
    `Lang(C)，Lang(y)→Prog(y) ⇒ Prog(C)`                 假言推理 {C/y}
    `Prog(C),  Prog(x)→Like(Wang , x) ⇒ Like(Wang , C)`  假言推理  {C/x}
因此，王程喜欢C这门课。

---

##### 注意避免以下两类错误：
* 肯定后件的错误：当`P→Q`为真时，希望通过肯定后件Q为真来推出前件P为真，这是不允许的。
* 否定前件的错误：当`P→Q`为真时，希望通过否定前件P来推出后件Q为假，这也是不允许的。

##### 自然演绎推理的优缺点
* 优点
    - 定理证明过程自然，易于理解，并且有丰富的推理规则可用。
* 缺点
    - 是容易产生知识爆炸，推理过程中得到的中间结论一般按指数规律递增，对于复杂问题的推理不利，甚至难以实现。


#### 消解演绎推理

一种基于 **鲁滨逊（Robinson）消解原理**的机器推理技术。鲁滨逊消解原理亦称为消解原理，是鲁滨逊于1965年在海伯伦（Herbrand）理论的基础上提出的一种基于逻辑的“反证法”。

>在人工智能中，几乎所有的问题都可以转化为一个定理证明问题。定理证明的实质，就是要对前提P和结论Q，证明`P→Q`永真。
>而要证明`P→Q`永真，就是要证明`P→Q`在任何一个非空的个体域上都是永真的。这将是非常困难的，甚至是不可实现的。

**鲁滨逊消解原理**把永真性的证明转化为关于 **不可满足性**的证明。即：要证明`P→Q`永真，只需证明`P∧¬Q`不可满足。（`¬(P→Q) ⇔ ¬(¬P∨Q) ⇔ P∧¬Q`）

##### 子句集及其化简

>鲁滨逊消解原理是在子句集的基础上讨论问题的。因此，讨论消解演绎推理之前，需要先讨论子句集的有关概念。

* 原子谓词公式及其否定统称为 **文字**。例如: P(x)、Q(x)、¬ P(x)、 ¬ Q(x)等都是文字。
* 任何文字的析取式称为 **子句**。例如，P(x)∨Q(x)，P(x，f(x))∨Q(x，g(x))都是子句。
* 不含任何文字的子句称为 **空子句**。
    - 由于空子句不含有任何文字，也就不能被任何解释所满足，因此 **空子句是永假的**，不可满足的。
    - 空子句一般被记为NIL。
* 由子句或空子句所构成的集合称为 **子句集**。
    - 在子句集中，子句之间是 **合取关系**；
    - 子句集中的变元受 **全称量词**的约束；
    - 任何谓词公式都可通过等价关系及推理规则化为相应的子句集。

把谓词公式化成子句集的步骤
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E5%8C%96%E5%AD%90%E5%8F%A5%E9%9B%86.jpg)

子句集的意义
在上述化简过程中，由于在消去存在量词时所用的Skolem函数可以不同，因此化简后的标准子句集是不唯一的。因此，当原谓词公式为非永假时，它与其标准子句集并不等价。但当原谓词公式为永假（或不可满足）时，其标准子句集则一定是永假的，即Skolem化并不影响原谓词公式的永假性。

不可满足性
对于任意论域中的任意一个解释，S中的子句不能同时取得真值T。

>定理：设有谓词公式F，其子句集为S，则F不可满足的充要条件是S不可满足。

* 由此定理可知，要证明一个谓词公式是不可满足的，只要证明其相应的标准子句集是不可满足的就可以了。
* 由于子句集中的子句之间是合取关系，**子句集中只要有一个子句为不可满足，则整个子句集就是不可满足的**。
* 空子句是不可满足的。因此，**一个子句集中如果包含有空子句，则此子句集就一定是不可满足的**。
* 这个定理是 **鲁滨逊消解原理的主要依据**。

##### 鲁滨逊消解原理

鲁滨逊消解原理的基本思想
* 首先把欲证明问题的 **结论否定**，并加入子句集，得到一个扩充的子句集S'；
* 然后设法检验子句集S'是否含有空子句，若含有空子句，则表明S'是不可满足的；若不含有空子句，则继续使用消解法，在子句集中选择合适的子句进行消解，**直至导出空子句或不能继续消解为止**。

鲁滨逊消解原理包括
* 命题逻辑的消解
* 谓词逻辑的消解

>命题逻辑的消解

消解推理的核心是求两个子句的 **消解式**。
* 设C1和C2是子句集中的任意两个子句，如果C1中的文字L1与C2中的文字L2 **互补**，那么可从C1和C2中分别消去L1和L2，并将C1和C2中余下的部分按析取关系构成一个新的子句C12，则称这一过程为 **消解**，称C12为C1和C2的 **消解式**，称C1和C2为C12的 **亲本子句**。

---

【例子】
1. 设C1=¬Q，C2=Q，则C1和C2的消解式C12 = NIL .
2. 设C1=P∨Q∨R，C2=¬P∨S，则C1和C2的消解式C12 = Q∨R∨S .
3. 设C1 =¬P ∨ Q ，C2=¬Q，C3=P，则C1、C2、C3的消解式C123 = NIL .

---

* 很显然，可以得出定理：**消解式C12是其亲本子句C1和C2的逻辑结论。**根据该定理，可以得到以下推论：
    - 推论1：设C1和C2是子句集S中的两个子句，C12是C1和C2的消解式，若用C12代替C1和C2后得到新的子句集S1，则由S1的不可满足性可以推出原子句集S的不可满足性。即：
    `S1的不可满足性⇔S的不可满足性`
    - 推论2：设C1和C2是子句集S中的两个子句，C12是C1和C2的消解式，若把C12加入S中得到新的子句集S2，则S与S2的不可满足性是等价的。即：
    `S2的不可满足性⇔S的不可满足性`

上述两个推论说明，*为证明子句集S的不可满足性，只要对其中可进行消解得子句进行消解，**并把消解式加入到子句集S中，或者用消解式代替他的亲本子句**，然后对新的子句集证明其不可满足性就可以了*。
如果经消解能得到空子句，根据空子句的不可满足性，即可得到原子句集S是不可满足的结论。
在命题逻辑中，对不可满足的子句集S，其消解原理是完备的。即：**子句集S是不可满足的，当且仅当存在一个从S到空子句的消解过程。**

应用消解原理证明定理的过程称为 **消解反演**。

**命题逻辑的消解反演：**
在命题逻辑中，已知F，证明G为真的消解反演过程如下：
1. 否定目标公式G，得¬G;
2. 把¬G并入到公式集F中，得到{F，¬G}；
3. 把{F，¬G}化为子句集S；
4. 应用消解原理对子句集S中的子句进行消解，并把每次得到的消解式并入S中。如此反复进行，若 **出现空子句**，则停止消解，此时就证明了G为真。

---

【例子】 设已知的公式集为`{P,(P∧Q)→R,(S∨T)→Q,T}`，求证：R为真。

解：假设结论R为假, 将¬R加入公式集，并化为子句集：
    `S={P,¬P∨¬Q∨R,¬S∨Q,¬T∨Q,T,¬R}`
其消解过程如下图的消解演绎树所示。
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%B6%88%E8%A7%A3%E6%A0%91.jpg)
该树根为空子句NIL，则子句集S不可满足，即假设有误，于是证得R为真。

---

>谓词逻辑的消解

* 在谓词逻辑中，由于子句集中的谓词一般都含有变元，因此不能象命题逻辑那样直接消去互补文字。
* 对于谓词逻辑，需要先用一个最一般合一对变元进行置换，然后才能进行消解。

设C1和C2是两个没有公共变元的子句，L1和L2分别是C1和C2中的文字。如果 σ 是L1和¬ L2存在的`最一般合一`，则称：
    `C12=({C1σ}-{ L1σ})∪({ C2σ}-{ L2σ})`
为C1和C2的二元消解式，L1和L2为消解式上的文字。

**注意**：在谓词逻辑的消解过程中，要注意以下几个问题：
1. 若C1和C2有相同的变元x，需要将其中一个变元更名。（例2）
2. 求消解式不能同时消去两个互补对，消去这两个互补文字所得的结果不是两个亲本子句的逻辑结论。(例3)
3. 对参加消解的某个子句，若其内部有可合一的文字，则在进行消解之前应先对这些文字进行合一，以实现这些子句内部的化简。(例4)

---

【例子】
例1、设`C1=P(a)∨R(x)`，`C2=¬P(y)∨Q(b)`，求 C12。
解：取`L1= P(a)`, `L2=¬P(y)`，则L1和¬L2的最一般合一是`σ={a/y}`。因此：

```
    C12 = ( {C1σ}-{L1σ}) ∪ ({C2σ}-{L2σ})
        = ({P(a), R(x)}-{P(a)})∪({¬P(a), Q(b)}-{¬P(a)})
        = ({R(x)})∪({Q(b)})
        = { R(x), Q(b) } 
        = R(x)∨Q(b)
```

例2、设`C1=P(x)∨Q(a)`，`C2=¬P(b)∨R(x) `，求 C12。
解：由于C1和C2有相同的变元x，不符合定义的要求。为了进行消解，需要修改C2中变元的名字。令`C2=¬P(b)∨R(y)`，此时`L1= P(x)`, `L2 =¬P(b)`，L1和¬L2的最一般合一是 `σ={b/x}`。则有:

```
    C12 = ({C1σ}-{L1σ})∪ ({C2σ}-{L2σ})
        = ({P(b), Q(a)}-{P(b)}) ∪ ({¬P(b), R(y)}-{¬P(b)})
        = ({Q(a)}) ∪ ({R(y)})
        = {Q(a), R(y)}
        = Q(a)∨R(y)
```

例3、设 `C1=P(a)∨¬Q(x)`，`C2=¬P(y)∨Q(b)`，求C12。
解：对C1和C2通过最一般合一（`σ={b/x, a/y}`）的作用，便得到空子句NIL的结论，从而得出C1、C2互相矛盾的结论，而事实上C1、C2并无矛盾。

例4、设 `C1=P(x)∨P(f(a))∨Q(x)` ，`C2=¬P(y)∨R(b)`，求C12。
解：本例的C1中有可合一的文字P(x)与P(f(a))，用它们的最一般合一`σ={f(a)/x}`进行代换，可得到 ： 
`C1σ=P(f(a))∨Q(f(a))`
此时对C1σ与C2进行消解。选`L1= P(f(a))`, `L2 =¬P(y)`，L1和L2的最一般合一是`σ={f(a)/y}`，则可得到C1和C2的二元消解式为：
`C12=R(b)∨Q(f(a))`

例5、设 `C1=P(y)∨P(f(x))∨Q(g(x))`、`C2=¬P(f(g(a)))∨Q(b)`，求C12。
解：对C1，取最一般合一` σ={f(x)/y}`，得C1的因子`C1σ=P(f(x))∨Q(g(x))`，对C1的因子和C2消解（`σ={g(a)/x }`），可得：`C12=Q(g(g(a)))∨Q(b)`

---

**谓词逻辑的消解反演：**
在谓词逻辑中，已知F，证明G是F的结论的消解反演过程如下：
1. 否定目标公式G，得¬G;
2. 把¬G并入到公式集F中，得到{F，¬G}；
3. 把{F，¬G}化为子句集S；
4. 应用消解原理对子句集S中的子句进行消解，并把每次得到的消解式并入S中。如此反复进行，若出现空子句，则停止消解，此时就证明了G为真。

与命题逻辑的消解反演过程比较一下
* 步骤基本相同，但每步的处理对象不同。
* 在步骤(3)化简子句集时，谓词逻辑需要把由谓词构成的公式集化为子句集。
* 在步骤(4)按消解原理进行消解时，谓词逻辑的消解原理需要考虑两个亲本子句的最一般合一。

---

【例子】
例1、已知`F:(∀x)((∃y)(A(x, y)∧B(y))→(∃y)(C(y)∧D(x, y)))`、`G:¬(∃x)C(x)→(∀x)(∀y)(A(x, y)→¬B(y))`，求证G是F的逻辑结论。

证明：
第一步，先把G否定，并放入F中，得到的`{F,¬G}`：
    `{(∀ x)((∃ y)(A(x,y)∧B(y))→(∃ y)(C(y)∧D(x,y)))`，`¬(¬(∃ x)C(x)→(∀ x)(∀ y)(A(x,y)→¬ B(y)))}`
第二步，把{F,¬G}化成子句集，得到
    (1) `¬A(x,y)∨¬B(y)∨C(f(x))`
    (2) `¬A(u,v)∨¬B(v)∨D(u,f(u))`
    (3) `¬C(z)`
    (4) `A(m,n)`
    (5) `B(k)`
第三步，应用谓词逻辑的消解原理对上述子句集进行消解，其过程为：
    (6) `¬ A(x,y)∨¬ B(y)`    *(1)和(3)消解，取σ={f(x)/z}*
    (7) `¬ B(n) `             *(4)和(6)消解，取σ={m/x,n/y}*
    (8) `NIL`                  *(5)和(7)消解，取σ={n/k}*
最后，“G是F的逻辑结论”得证。

上述消解过程可用如下消解树来表示
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%B6%88%E8%A7%A3%E6%A0%912.jpg)

例2、**“快乐学生”问题**
假设：任何通过计算机考试并获奖的人都是快乐的，任何肯学习或幸运的人都可以通过所有考试，张不肯学习但他是幸运的，任何幸运的人都能获奖。
求证：张是快乐的。

证明：(完整的解题过程)
第一步，先定义谓词：
    Pass(x, y)：x可以通过y考试
    Win(x, prize)：x能获得奖励
    Study(x) ：x肯学习
    Happy(x)：x是快乐的
    Lucky(x) ：x是幸运的
第二步，将已知条件以及结论的否定用谓词表示如下：
    “任何通过计算机考试并奖的人都是快乐的”
            `(∀x)(Pass(x, computer)∧Win(x, prize)→Happy(x))`
    “任何肯学习或幸运的人都可以通过所有考试”
            `(∀x)(∀y)(Study(x)∨Lucky(x)→Pass(x, y))`
    “张不肯学习但他是幸运的”
            `¬Study(zhang)∧Lucky(zhang)`
    “任何幸运的人都能获奖”
            `(∀x)(Lucky(x)→Win(x, prize))`
    结论“张是快乐的”的否定
            `¬Happy(zhang)`
第三步，将上述谓词公式转化为子句集如下：
    1. `¬Pass(x, computer)∨¬Win(x, prize)∨Happy(x)`
    2. `¬Study(y)∨Pass(y, z)`
    3. `¬Lucky(u)∨Pass(u, v)`
    4. `¬Study(zhang)`
    5. `Lucky(zhang)`
    6. `¬Lucky(w)∨Win(w, prize)`
    7. `¬ Happy(zhang)`    (结论的否定)
第四步，按消解原理进行消解，消解树如下：
    ![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%B6%88%E8%A7%A3%E6%A0%913.jpg)
最后，“张是快乐的”得证。

---

##### 消解反演推理的消解策略

>在消解演绎推理中，由于事先并不知道哪些子句对可进行消解，更不知道通过对哪些子句对的消解能尽快得到空子句，因此就需要对子句集中的所有子句逐对进行比较，直到得出空子句为止。这种盲目的全面进行消解的方法，不仅会产生许多无用的消解式，更严重的是会产生组核爆炸问题。因此，需要研究有效的消解策略来解决这些问题。

常用的消解策略可分为两大类：
* 限制策略：通过限制参加消解的子句减少盲目性
* 删除策略：通过删除某些无用的子句缩小消解范围

##### 用消解反演求取问题的答案

消解原理除了可用于 **定理证明**外，还可用来 **求取问题答案**，其思想与定理证明相似。
其一般步骤为：
1. 把问题的已知条件用谓词公式表示出来，并化为子句集；
2. 把问题的目标的否定用谓词公式表示出来，并化为子句集；
3. 对目标否定子句集中的每个子句，构造该子句的重言式（即把该目标否定子句和此目标否定子句的否定之间再进行析取所得到的子句），用这些重言式代替相应的目标否定子句式，并把这些重言式加入到前提子句集中，得到一个新的子句集；
4. 对这个新的子句集，应用消解原理求出其证明树，这时证明树的根子句不为空，称这个证明树为修改的证明树；
5. 用修改证明树的根子句作为回答语句，则答案就在此根子句中。

---

【例子】
例1、已知：“张和李是同班同学，如果x和y是同班同学，则x的教室也是y的教室，现在张在302教室上课。”
问：“现在李在哪个教室上课？”

解：第一步，首先定义谓词
    `C(x, y)`：x和y是同班同学
    `At(x, u)`：x在u教室上课。
第二步，把已知前提用谓词公式表示如下：
    `C(zhang, li)`
    `(∀x)(∀y)(∀u)(C(x, y)∧At(x, u)→At(y,u))`
    `At(zhang, 302)`   
把目标的否定用谓词公式表示如下：
    `¬(∃v)At(li, v) `
第三步，把上述表示前提的谓词公式化为子句集：          
    `C(zhang, li)`
    `¬C(x, y)∨¬At(x, u)∨At(y, u)`
    `At(zhang, 302)`
把目标的否定化成子句式，并用下面的 **重言式**代替：
         `¬At(li,v) ∨At(li,v)`
第四步，把此 **重言式**加入前提子句集中，得到一个新的子句集，对这个新的子句集，应用消解原理求出其证明树。
求解过程如下图所示。该证明树的根子句就是所求的答案，即“李明在302教室”。
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%B6%88%E8%A7%A3%E6%A0%914.jpg)

例2、已知：A,B,C三人中有人从不说真话，也有人从不说假话。某人向这三人分别提出同一个问题：谁是说谎者？
    A答：“B和C都是说谎者”；
    B答：“A和C都是说谎者”；
    C答：“A和B中至少有一个是说谎者”。
问：求谁是老实人，谁是说谎者？

解：第一步，首先定义谓词
`T(x)`：表示x说真话
第二步，把已知前提用谓词公式表示如下：
    有人从不说真话：`¬T(C)∨¬T(A)∨¬T(B)`
    有人从不说假话：`T(C)∨T(A)∨T(B)`  
根据“A答：B和C都是说谎者”，则
    若A说真话：`T(A)→¬T(B)∧¬T(C)`    
    若A说假话： `¬T(A)→T(B)∨T(C)`
同理，根据“B答：A和C都是说谎者”，则
    `T(B)→¬T(A)∧¬T(C)`    
    `¬T(B)→T(A)∨T(C)`     
根据“C答：A和B中至少有一个是说谎者”，则
    `T(C)→¬T(A)∨¬T(B)`
    `¬T(C)→T(A)∧T(B)`
第三步，把上述公式化成子句集，得到前提子句集S：
    `¬T(A)∨¬T(B)`
    `¬T(A)∨¬T(C)`
    `T(C)∨T(A)∨T(B)`
    `¬T(B)∨¬T(C)`
    `¬T(C)∨¬T(A)∨¬T(B)`
    `T(A)∨T(C)`
    `T(B)∨T(C)`
第四步，先求谁是老实人，结论的否定为：`¬(∃x)T(x)`，把目标的否定化成子句式，并用下面的重言式代替：
    `¬T(x)∨T(x)`
把此重言式加入前提子句集S，得到一个新子句集。
第五步，对这个新的子句集，应用消解原理求出其证明树。
    ![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%B6%88%E8%A7%A3%E6%A0%915.jpg)
第六步，同理证明A不是老实人，结论的否定为： ¬T(A)，将结论的否定¬(¬T(A)) 加入并入前提子句集S中，应用消解原理对新的子句集进行消解：
    ![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%B6%88%E8%A7%A3%E6%A0%916.jpg)

---

##### 消解演绎推理的优缺点：
* 优点：
    - 简单，便于在计算机上实现。
* 缺点：
    - 必须把逻辑公式化成子句集。
    - 不便于阅读与理解：¬P(x)∨Q(x)没有P(x)→Q(x)直观。
    - 可能丢失控制信息，如下列逻辑公式，化成子句后都是: A∨B∨C
```
    (¬A∧¬B)→C    ¬A→(B∨C)
    (¬A∧¬C)→B    ¬B→(A∨C)
    (¬C∧¬B)→A    ¬C→(B∨A)
```

#### 基于规则的演绎推理

>在消解演绎推理中，需要把谓词公式化为子句形，这使得原来蕴含在谓词公式中的一些重要信息却会在求取子句形的过程中被丢失。
>在不少情况下人们多希望使用接近于问题原始描述的形式来进行求解，而不希望把问题描述化为子句集。

基于规则的演绎推理又称为与/或形演绎推理，不再把有关知识转化为子句集，而是把领域知识及已知事实分别用蕴含式及与/或形表示出来，然后通过运用蕴含式进行演绎推理，从而证明某个目标公式。

规则是一种比较接近于人们习惯的问题描述方式，按照 **蕴含式**（“If →Then”规则）这种问题描述方式进行求解的系统称为基于规则的系统，或者叫做 **规则演绎系统**。

规则演绎系统按照推理方式可分为：
* 规则正向演绎系统
* 规则逆向演绎系统(ppt-14)
* 规则双向演绎系统(ppt-14)

##### 规则正向演绎系统

首先说明一下，在规则正向演绎系统中，对已知事实和规则都有一定的要求，如果不是所要求的形式，需要进行变换。

事实表达式的与或形变换
* 在基于规则的正向演绎系统中，把事实表示为非蕴含形式的与或形，作为系统的总数据库；
* 把一个公式化为与或形的步骤与化为子句集类似，只是不必把公式化为子句的合取形式，也不能消去公式中的合取。

详细来说，把事实表达式化为非蕴含形式的与/或形的步骤如下：
1. 利用 “P→Q⇔﹁P∨Q”，消去蕴含符号； 
2. 利用狄.摩根定律及量词转换率把“﹁”移到紧靠谓词的位置，直到否定符号的辖域最多只含一个谓词为止；
3. 重新命名变元，使不同量词约束的变元有不同的名字；
4. 对存在量词量化的变量用skolem函数代替；
5. 消去全称量词，且使各主要合取式中的变元具有不同的变量名。

---

【例子】
有如下表达式
        `(∃x) (∀y)(Q(y, x)∧﹁((R(y)∨P(y))∧S(x, y)))`
可把它转化为：
        `Q(z, a)∧(  ( ﹁R(y)∧﹁P(y) )∨﹁S(a, y)  )`
这就是 **与/或形表示**，也可用一棵与/或图表示出来。
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E4%B8%8E%E6%88%96%E5%BD%A2%E6%A0%91.jpg)

---

>关于 **与/或图**说明以下几点：

* 当某表达式为k个子表达式的析取：`E1∨E2∨…∨Ek`，其中每个子表达式Ei均被表示为`E1∨E2∨…∨Ek`的后继节点，并由一个k线连接符（即图中的半圆弧）将这些后继节点都连接到其父节点，即表示成与的关系。
* 当某表达式为k个子表达式的合取：`E1∧E2∧…∧Ek`，其中的每个子表达式Ei均被表示为`E1∧E2∧…∧Ek`的一个单一的后继节点，无需用连接符连接，即表示成或的关系。
* **这样，与/或图的根节点就是整个事实表达式，叶节点均为事实表达式中的一个文字**。

>有了与/或图的表示，就可以求出其解树（结束于文字节点上的子树）集。可以发现，事实表达式的子句集与解树集之间存在着一一对应关系，即 **解树集中的每个解树都对应着子句集中的一个子句**。
>**解树集中每个解树的端节点上的文字的析取就是子句集中的一个子句。**

上面那个与/或图有3个解树，分别对应这以下3个子句：
    `Q(z, a)`、`﹁R(y)∨ ﹁ S(a, y)`、`﹁P(y)∨ ﹁ S(a, y)`

>还需要注意以下两点：
* 这里的与/或图是作为综合数据库的一种表示，其中的变量受全称量词的约束。
* 在之前 问题归约表示 中所描述的 **与/或图表示方法**与这里 **与/或形的与/或图表示**有着不同的目的和含义，因此应用时应加以 **区分**。 


> 规则的表示

为简化演绎过程，通常要求规则具有如下形式：`L→W`，其中，L为单文字，W为与/或形公式。
(之所以限制前件L为单文字，是因为在进行正向演绎推理时要用规则作用于表示事实的与/或树，而该与/或树的叶节点都是单文字，这样就可用规则的前件与叶节点进行简单匹配。对非单文字情况，若形式为L1∨L2→W，则可将其转换成与之等价的两个规则L1→W与 L2→W进行处理。)

* 假定出现在蕴含式中的任何变量全都受全称量词的约束，并且这些变量已经被换名，使得他们与事实公式和其他规则中的变量不同。
* 如果领域知识的规则表示形式与上述要求不同，则应将它转换成要求的形式。

>将规则转换为要求形式的步骤：

1、 暂时消去蕴含符号“→”。设有如下公式：
        `(∀x)(((∃y) (∀ z)P(x, y,z))→(∀u)Q(x, u))`
运用等价关系“P→Q⇔﹁P∨Q”，可将上式变为：
        `(∀x)(﹁((∃ y) (∀z)P(x, y,z))∨(∀u)Q(x, u))`
2、 把否定符号“﹁”移到紧靠谓词的位置上，使其作用域仅限于单个谓词。通过使用狄.摩根定律及量词转换律可把上式转换为：
        `(∀ x)( (∀y) (∃z)﹁P(x, y,z))∨ (∀u)Q(x, u))`
3、 引入Skolem函数，消去存在量词。消去存在量词后，上式可变为：
        `(∀ x)( (∀y) (﹁P(x, y,f(x,y)))∨(∀u)Q(x, u))`
4、 把所有全称量词移至前面化成前束式，消去全部全称量词。消去全称量词后，上式变为：
        `﹁P(x, y,f(x,y))∨Q(x, u)`
此公式中的变元都被视为受全称量词约束的变元。
5、 恢复蕴含式表示。利用等价关系“`﹁P∨Q⇔P→Q`”将上式变为：
        `P(x, y,f(x,y))→Q(x, u)`

>目标公式的表示形式

* 与/或树正向演绎系统要求目标公式用子句形表示。如果目标公式不是子句形，则需要化成子句形。

>推理过程

规则正向演绎推理过程是从已知事实出发，不断运用规则，推出欲证明目标公式的过程。
先用与/或树把已知事实表示出来，然后再用规则的前件和与/或树的叶节点进行匹配，并通过一个匹配弧把匹配成功的规则加入到与/或树中，依此使用规则，直到产生一个含有以目标节点为终止节点的解树为止。

>下面分命题逻辑和谓词逻辑两种情况来讨论规则正向演绎过程。

**命题逻辑的规则正向演绎过程**
已知事实：`A∨B`
规则：`r1: A→C∧D`，`r2:  B→E∧G`
目标公式：`C∨G`

证明：
1）先将已知事实用与/或树表示出来；
2）然后再用匹配弧把r1和r2分别连接到事实与/或树中与r1和r2 的前件匹配的两个不同端节点；
3) 由于出现了以目标节点为终节点的解树，故推理过程结束。这一证明过程可用下图表示。
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E8%BF%87%E7%A8%8B%E5%9B%BE.jpg)

**谓词逻辑的规则正向演绎过程**
已知事实的与/或形表示：P(x, y)∨(Q(x)∧R(v, y))
规则：P(u, v)→(S(u)∨N(v)) 
目标公式：S(a)∨N(b)∨Q(c)

证明：
在谓词逻辑情况下，由于事实、规则及目标中均含有变元，因此，其规则演绎过程还需要用最一般合一对变进行置换。证明过程可用下图表示。
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E8%BF%87%E7%A8%8B%E5%9B%BE2.jpg)

#### 产生式系统

##### 基本结构

产生式系统的 **基本结构**由 **数据库**、**产生式规则**和 **控制策略**三部分构成。

* 总数据库：存放求解问题的各种当前信息，如：问题的初始状态，输入的事实，中间结论及最终结论等。
    - 推理过程中，当规则库中某条规则的前提可以和总数据库的已知事实匹配时，该规则被激活，由它推出的结论将被作为新的事实放入总数据库，成为后面推理的已知事实。
* 产生式规则：是一个规则库，也称知识库 。用于存放与求解问题有关的所有规则的集合。
* 控制策略：亦称推理机，用于控制整个产生式系统的运行，决定问题求解过程的推理线路。
    - 控制系统的主要任务包括： 选择匹配、 冲突消解、 执行操作、 终止推理、 路径解释...

##### 产生式系统的推理

产生式系统的推理分为 **正向推理**、**逆向推理**和 **双向推理**三种形式。

##### 主要优缺点

产生式系统的主要 **优缺点**
* 优点：
    - 自然性：采用“如果……，则……”的形式，人类的判断性知识基本一致。
    - 模块性：规则是规则库中最基本的知识单元，各规则之间只能通过总数据库发生联系，而不能相互调用，从而增加了规则的模块性。
    - 有效性：产生式知识表示法既可以表示确定性知识，又可以表示不确定性知识，既有利于表示启发性知识，又有利于表示过程性知识。
* 缺点：
    - 效率较低：各规则之间的联系必须以总数据库为媒介。并且，其求解过程是一种反复进行的“匹配—冲突消解—执行”过程。这样的执行方式将导致执行的低效率。
    - 不便于表示结构性知识：由于产生式表示中的知识具有一致格式，且规则之间不能相互调用，因此那种具有结构关系或层次关系的知识则很难以自然的方式来表示。


